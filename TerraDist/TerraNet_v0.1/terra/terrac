#!/usr/bin/env lua

--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

_CEU = true

_OPTS = {
    input     = nil,
    output    = '_ceu_code.cceu',
    output2    = '_ceu_opcode.vmx',

    --defs_file  = '_ceu_defs.h',

    analysis      = false,
    analysis_run  = false,
    analysis_use  = false,
    analysis_file = '_ceu_analysis.lua',

    join      = true,
    c_calls   = false,

    m4        = true,
    m4_args   = false,

    tp_word    = 2,
    tp_pointer = 2,
    tp_off     = 2,
    tp_lbl     = 2,
}

_OPTS_NPARAMS = {
    input     = nil,
    output    = 1,

    --defs_file  = 1,

    analysis      = 0,
    analysis_run  = 0,
    analysis_use  = 0,
    analysis_file = 1,

    join      = 0,
    c_calls   = 1,

    m4        = 0,
    m4_args   = 1,

    tp_word    = 1,
    tp_pointer = 1,
    tp_off     = 1,
    tp_lbl     = 1,
}

function trim (s)
  return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

local params = {...}
local i = 1
while i <= #params
do
    local p = params[i]
    i = i + 1

    if p == '-' then
        _OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if _OPTS_NPARAMS[opt] == 0 then
            _OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            _OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            i = i + 1
        end

    else
        _OPTS.input = p
    end
end
if not _OPTS.input then
    io.stderr:write([[

    ./ceu <filename>           # Ceu input file, or `-´ for stdin
    
        --output <filename>    # C output file (stdout)
    
        --defs-file <filename> # define constants in a separate output file (no)

        --analysis                 # TODO
        --analysis-run             # TODO
        --analysis-use             # TODO
        --analysis-file <filename> # TODO

        --join (--no-join)     # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --c-calls              # TODO

        --m4 (--no-m4)         # preprocess the input with `m4´ (no-m4)
        --m4-args              # preprocess the input with `m4´ passing arguments in between `"´ (no)

        --tp-word              # sizeof a word in bytes    (4)
        --tp-pointer           # sizeof a pointer in bytes (4)
        --tp-off               # sizeof an offset in bytes (2)
        --tp-lbl               # sizeof a label in bytes   (2)

]])
    os.exit(1)
end

if _OPTS.analysis then
    assert((not _OPTS.analysis_use) and (not _OPTS.analysis_run)
            and _OPTS.input~='-',
        'invalid analysis invocation')
    local params = table.concat(params,' ')
    do
        params = string.gsub(params, '--analysis[^ ]*', '')
        os.execute('./ceu '..params..
                    ' --analysis-run --analysis-file '.._OPTS.analysis_file)
        assert(os.execute('gcc -std=c99 -o ceu.exe analysis.c') == 0)
        assert(os.execute('./ceu.exe '.._OPTS.analysis_file) == 0)
    end
    _OPTS.analysis_use = true
    _OPTS.analysis = false
end

assert(not (_OPTS.analysis_use and _OPTS.analysis_run),
        'invalid analysis invocation')

-- C_CALLS
if _OPTS.c_calls then
    local t = {}
    for v in string.gmatch(_OPTS.c_calls, "(%w+)") do
        t[v] = true
    end
    _OPTS.c_calls = t
end


-- INPUT
local inp
if _OPTS.input == '-' then
    inp = io.stdin
else
    inp = assert(io.open(_OPTS.input))
end
_STR = inp:read'*a'

if _OPTS.m4 or _OPTS.m4_args then
    local args = _OPTS.m4_args and string.sub(_OPTS.m4_args, 2, -2) or ''   -- remove `"´
    local m4_file = (_OPTS.input=='-' and '_ceu_tmp.ceu_m4') or _OPTS.input..'_m4'
    local m4 = assert(io.popen('m4 '..args..' - > '..m4_file, 'w'))
    m4:write(_STR)
    m4stat = m4:close()
--print('m4stat=',m4stat)

    _STR = assert(io.open(m4_file)):read'*a'
    os.remove(m4_file)
end

-- PARSE
do
    
do
_TP = {}

local types = {
    void=true,
    int=true,
    u64=true, s64=true,
    u32=true, s32=true,
    u16=true, s16=true,
    u8=true,  s8=true,
}

-- TODO: enforce passing parameter `c´ to isNumeric/deref/contains/max ?

function _TP.raw (tp)
    return (string.match(tp, '^([_%w]*)%**'))
end

function _TP.c (tp)
    return (string.gsub(tp, '^_', ''))
end

function _TP.isNumeric (tp, c)
    return tp~='void' and types[tp] or (c and _TP.ext(tp))
end

function _TP.deref (tp, c)
    return string.match(tp, '(.-)%*$') or (c and _TP.ext(tp))
end

function _TP.ext (tp)
    return (string.sub(tp,1,1) == '_') and
            (not string.match(tp, '(.-)%*$')) and tp
end

function _TP.contains (tp1, tp2, c)
    local _tp1, _tp2 = _TP.deref(tp1), _TP.deref(tp2)
    if tp1 == tp2 then
        return true
    elseif _TP.isNumeric(tp1) and _TP.isNumeric(tp2) then
        return true
    elseif c and (_TP.ext(tp1) or _TP.ext(tp2)) then
        return true
    elseif _tp1 and _tp2 then
        return tp1=='void*' or tp2=='void*' or _TP.contains(_tp1, _tp2, c)
    end
    return false
end

function _TP.max (tp1, tp2, c)
    if _TP.contains(tp1, tp2, c) then
        return tp1
    elseif _TP.contains(tp2, tp1, c) then
        return tp2
    else
        return nil
    end
end

function _TP.getConstType(val)
	local nval = tonumber(val)
	if (nval <= 0xff) then return 'u8' end
	if (nval <= 0xffff) then return 'u16' end
	return 'u32'
end

function _TP.getConstLen(val)
	local nval = tonumber(val)
	if (nval <= 0xff) then return 0 end
	if (nval <= 0xffff) then return 1 end
	if (nval <= 0xffffff) then return 2 end
	return 3
end

function _TP.getConstBytes(val,len)
	len = len or 0;
	nx=1
	local nval = tonumber(val)
	local bytes = string.format('%02x ',nval % 256)
	while (math.floor(nval/256) > 0 or len>1)  and nx < 4 do
	  nx = nx+1;
	  len = len - 1;
	  nval = math.floor(nval/256)
	  -- big-endian byte order
	  bytes = string.format('%02x %s ',nval % 256,bytes)
	end
	return trim(bytes)
end


end

    
do
m = require 'lpeg'
m.setmaxstack(1000)

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, me, msg)
    local ln = (type(me)=='number' and me) or me.ln
    if not cond then
        DBG('WRN : line '..ln..' : '..msg)
    end
    return cond
end
function ASR (cond, me, msg)
    local ln = (type(me)=='number' and me) or me.ln
    if _CEU then
        if not cond then
            DBG('ERR : line '..ln..' : '..msg)
            os.exit(1)
        end
        return cond
    else
        return assert(cond, 'ERR : line '..ln..' : '..msg)
    end
end

_I2L = {}

local CNT = 1
local open = m.Cmt('/*{-{*/',
    function ()
        if _OPTS.join then
            CNT = CNT - 1
        end
    end )
local close = m.Cmt('/*}-}*/',
    function ()
        if _OPTS.join then
            CNT = CNT + 1
        end
    end )

local LINE = 1
local line = m.Cmt('\n',
    function (s,i)
        for i=#_I2L, i do
            _I2L[i] = LINE
        end
        if CNT > 0 then
            LINE = LINE + 1
        end
    end )

local patt = (line + open + close + 1)^0
patt:match(_STR..'\n')

end

    
do
_PARSER = {
}

local P, C, V, Cc, Ct = m.P, m.C, m.V, m.Cc, m.Ct

local S = V'_SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt)
    ERR_msg = '?'
    return m.Cmt(patt, f)*S
end
local CK = function (patt)
    ERR_msg = '?'
    return C(m.Cmt(patt, f))*S
end
local EK = function (tk)
    return K(tk) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."´"
            end
            return false
        end)
end

local _V2NAME = {
    Exp = 'expression',
    _Exp = 'expression',
    _Stmt = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    ID_c  = 'identifier',
    ID_var  = 'identifier',
    ID_int  = 'identifier',
    ID_ext  = 'identifier',
    ID_type = 'type',
    __Dcl_c  = 'declaration',
    _Dcl_c   = 'declaration',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    __ID = 'identifier',
}
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end)
end

local EM = function (msg)
    return m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. msg
                return false
            end
        end)
end

TYPES = P'void' + 'int'
      + 'u8' + 'u16' + 'u32' + 'u64'
      + 's8' + 's16' + 's32' + 's64'

KEYS = P'and'     + 'async'    + 'await'    + 'break'    + 'C'
     + 'constant' + 'deterministic'         + 'do'       + 'else'
     + 'else/if'  + 'emit'     + 'end'      + 'event'    --+ 'external'
     + 'finally'  + 'FOREVER'  + 'if'       + 'input'    + 'loop'
     + 'nohold'   + 'not'      + 'null'     + 'or'       + 'output'
     + 'par'      + 'par/and'  + 'par/or'   + 'pause/if' + 'pure'
     + 'return'   + 'sizeof'   + 'then'     + 'var'      + 'with'
     + TYPES

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber

_GG = { [1] = CK'' * V'Block' * P(-1)-- + EM'expected EOF')

    , _Block = ( V'_Stmt' * (EK';'*K';'^0) +
                 V'_StmtB' * (K';'^-1*K';'^0)
               )^0
             * ( V'_LstStmt' * (EK';'*K';'^0) +
                 V'_LstStmtB' * (K';'^-1*K';'^0)
               )^-1
    , Block  = V'_Block'
    , BlockN = V'_Block'

    , _Stmt = V'AwaitT'   + V'AwaitExt'  + V'AwaitInt'
            + V'EmitT'    + V'EmitExtS'  + V'EmitInt'
            + V'_Dcl_c'   + V'_Dcl_ext'
            + V'_Dcl_int' + V'_Dcl_var'
            + V'Dcl_det'
            + V'_Set'     + V'CallStmt' -- must be after Set
            --+ EM'statement'
            --+ EM'statement'-- (missing `_´?)'
            + EM'statement (usually a missing `var´ or C prefix `_´)'

    , _StmtB = V'_Do'   + V'Async'  + V'Host'
             + V'ParOr' + V'ParAnd'
             + V'If'    + V'Loop'
             + V'Pause'

    , _LstStmt  = V'_Return' + V'Break' + V'AwaitN'
    , _LstStmtB = V'ParEver'

    , _SetBlock = ( V'_Do'     + V'Async' +
                    V'ParEver' + V'If'    + V'Loop' )

    , __ID      = V'ID_c' + V'ID_ext' + V'Var'
    , Dcl_det   = K'deterministic' * EV'__ID' * EK'with' *
                     EV'__ID' * (K',' * EV'__ID')^0

    , __Dcl_c = Cc'type' * V'ID_c' * K'='  * NUM
              + Cc'func' * V'ID_c' * '()' * Cc(false)
              + Cc'var'  * V'ID_c'        * Cc(false)
    , _Dcl_c = K'C' * (CK'pure'+CK'constant'+CK'nohold'+Cc(false))
             * EV'__Dcl_c' * (K',' * EV'__Dcl_c')^0

    , _Set  = V'Exp' * V'_Sets'
    , _Sets = (CK'=' + CK':=') * (
                Cc'SetAwait' * (V'AwaitT'+V'AwaitExt'+V'AwaitInt') +
                Cc'SetBlock' * V'_SetBlock' +
                Cc'SetExp'   * V'Exp' +
                EM'expression'
              )

    , CallStmt = m.Cmt(V'Exp',
                    function (s,i,...)
                        return (string.sub(s,i-1,i-1)==')'), ...
                    end)

    , _Do     = K'do' * V'BlockN' *
                    (K'finally'*V'BlockN' + Cc(false)) *
                EK'end'

    , Async   = K'async' * V'VarList' * V'_Do'
    , VarList = ( EK'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )^-1

    , _Return = K'return' * EV'Exp'

    , ParOr   = K'par/or' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'
    , ParAnd  = K'par/and' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'
    , ParEver = K'par' * EK'do' *
                    V'Block' * (EK'with' * V'Block')^1 *
                EK'end'

    , If      = K'if' * EV'Exp' * EK'then' *
                    V'Block' *
                (K'else/if' * EV'Exp' * EK'then' *
                    V'Block')^0 *
                (K'else' *
                    V'Block' + Cc(false)) *
                EK'end'

    , Loop    = K'loop' *
                    (V'ID_var'* (EK','*EV'Exp' + Cc(false)) +
                        Cc(false)*Cc(false)) *
                V'_Do'
    , Break   = K'break'

    , Exp     = V'_Exp'
    , _Exp    = V'_1'
    , _1      = V'_2'  * (CK'or'  * V'_2')^0
    , _2      = V'_3'  * (CK'and' * V'_3')^0
    , _3      = V'_4'  * ((CK'|'-'||') * V'_4')^0
    , _4      = V'_5'  * (CK'^' * V'_5')^0
    , _5      = V'_6'  * (CK'&' * V'_6')^0
    , _6      = V'_7'  * ((CK'!='+CK'==') * V'_7')^0
    , _7      = V'_8'  * ((CK'<='+CK'>='+(CK'<'-'<<')+(CK'>'-'>>')) * V'_8')^0
    , _8      = V'_9'  * ((CK'>>'+CK'<<') * V'_9')^0
    , _9      = V'_10' * ((CK'+'+(CK'-'-'->')) * V'_10')^0
    , _10     = V'_11' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * V'_11')^0
    , _11     = ( Cc(true) * ( CK'not' + CK'&' + CK'-' + CK'+' + CK'~' + CK'*'
                             + (K'<'*EV'ID_type'*K'>') )
                )^0 * V'_12'
    , _12     = V'_13' *
                    (
                        K'(' * Cc'call' * V'ExpList' * EK')' +
                        K'[' * Cc'idx'  * V'_Exp'    * EK']' +
                        (CK':' + CK'.')
                            * (CK(Alpha * (Alphanum+'?')^0) /
                                function (id)
                                    return (string.gsub(id,'%?','_'))
                                end)
                    )^0
    , _13     = V'_Prim'
    , _Prim   = V'_Parens' + V'Var'   + V'C'   + V'SIZEOF'
              + V'NULL'    + V'CONST' + V'STRING'
              + V'EmitExtE'

    , ExpList = ( V'_Exp'*(K','*EV'_Exp')^0 )^-1

    , _Parens  = K'(' * EV'_Exp' * EK')'

    , SIZEOF = K'sizeof' * EK'<' * EV'ID_type' * EK'>'
    , CONST = CK( #m.R'09' * (m.R'09'+m.S'xX'+m.R'AF'+m.R'af')^1 )
            + CK( "'" * (P(1)-"'")^0 * "'" )

    , NULL = CK'null'

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
                (NUM * K'us'  + Cc(0)) *
                (NUM * EM'<h,min,s,ms,us>')^-1
    , WCLOCKE = K'(' * V'Exp' * EK')' * C(
                    K'h' + K'min' + K's' + K'ms' + K'us'
                  + EM'<h,min,s,ms,us>'
              )

    , Pause    = K'pause/if' * EV'Var' * V'_Do'

    , AwaitExt = K'await' * EV'Ext'
    , AwaitInt = K'await' * EV'Var'
    , AwaitN   = K'await' * K'FOREVER'
    , AwaitT   = K'await' * (V'WCLOCKK'+V'WCLOCKE')

    , _EmitExt = K'emit' * EV'Ext' * (K'(' * V'Exp'^-1 * EK')')^-1
    , EmitExtS = V'_EmitExt'
    , EmitExtE = V'_EmitExt'

    , EmitT    = K'emit' * (V'WCLOCKK'+V'WCLOCKE')

    , EmitInt  = K'emit' * EV'Var' * (K'(' * V'Exp'^-1 * EK')')^-1

    , _Dcl_ext = (CK'input'+CK'output') * EV'ID_type' *
                    EV'ID_ext' * (K','*EV'ID_ext')^0

    , _Dcl_int  = CK'event' * EV'ID_type' * Cc(false) *
                    V'__Dcl_int' * (K','*V'__Dcl_int')^0
    , __Dcl_int = EV'ID_int' * (V'_Sets' + Cc(false)*Cc(false)*Cc(false))

    , _Dcl_var  = CK'var' * EV'ID_type' * (K'['*NUM*K']'+Cc(false)) *
                    V'__Dcl_var' * (K','*V'__Dcl_var')^0
    , __Dcl_var = EV'ID_var' * (V'_Sets' + Cc(false)*Cc(false)*Cc(false))

    , Ext      = V'ID_ext'
    , Var      = V'ID_var'
    , C        = V'ID_c'

    , ID_ext  = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , ID_var  = -KEYS * CK(m.R'az'*(Alphanum+'?')^0)
                    / function(id) return (string.gsub(id,'%?','_')) end
    , ID_int  = V'ID_var'
    , ID_c    = CK(  P'_' *Alphanum^0)
    , ID_type = (CK(TYPES)+V'ID_c') * C(K'*'^0) /
                  function (id, star)
                    return (string.gsub(id..star,' ',''))
                  end

    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

    , Host    = K'C' * (#EK'do')*'do' * m.S' \n\t'^0 *
                    ( C(V'_C') + C((P(1)-'end')^0) )
                *S* EK'end'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , _SPACES = (  m.S'\t\n\r @'
                + ('//' * (P(1)-'\n')^0 * P'\n'^-1)
                + V'_COMM'
                )^0

    , _COMM    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'_COMMCMP')^0 * V'_COMMCL'
                    / function () end
    , _COMMCL  = C(P'*'^1) * '/'
    , _COMMCMP = m.Cmt(V'_COMMCL' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)
}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    return 'ERR : line '.._I2L[LST_i]..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."´"..
              ' : '..ERR_msg
end

if _CEU then
    if not m.P(_GG):match(_STR) then
        DBG(err())
        os.exit(1)
    end
else
    assert(m.P(_GG):match(_STR), err())
end

end

    
do
_AST = {
    root = nil
}

local MT = {}
local STACK = nil
local FIN = 0     -- cur fin

function printTable(Table)
print('============== printTable ===============')
	for i, l in pairs(Table) do
		if type(l)=="table" then 
			for x, m in pairs(l) do print(i,x,": ",m, "\n"); end;
		else print(i,": ",l, "\n");
		end
	end
end


function _AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

function node (tag, min)
    min = min or 0
    return function (ln, ...)
        local node = setmetatable({ ... }, MT)
        if #node < min then
            return ...
        else
            node.ln  = ln
            node.tag = tag
            return node
        end
    end
end

function _AST.pred_tree (me)
    local tag = me.tag
    return tag=='SetBlock' or tag=='ParOr' or tag=='Loop'
end
function _AST.pred_true (me) return true end

function _AST.iter (pred, inc)
    if pred == nil then
        pred = _AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function _AST.copy (node, ln)
    local ret = setmetatable({}, MT)
    for k, v in pairs(node) do
        if _AST.isNode(v) then
            ret[k] = _AST.copy(v, ln)
            ret[k].ln = ln or ret[k].ln
        else
            ret[k] = v
        end
    end
    return ret
end

function _AST.dump (me, spc)
    spc = spc or 0
    local ks = ''
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
    DBG(string.rep(' ',spc) .. me.tag .. ' ('..ks..')')
    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
            _AST.dump(sub, spc+2)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

function _AST.visit (F)
    assert(_AST)
    STACK = {}
    _AST.root.depth = 0
    return visit_aux(_AST.root, F)
end

function EXP (n)
    return node('Exp')(n.ln,n)
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

function visit_aux (me, F)
--DBG(me.tag, me, F)
    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then me=(F.Node_pre(me) or me) end
    if pre then me=(pre(me) or me) end

    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
--DBG('> '.._AST.isNode(sub))
            sub.depth = me.depth + 1
            ASR(sub.depth < 127, sub, 'max depth of 127')
            if bef then bef(me, sub) end
            me[i] = visit_aux(sub, F)
            if aft then aft(me, sub) end
        end
    end

    if mid then me=(mid(me) or me) end
    STACK[#STACK] = nil
    if pos then me=(pos(me) or me) end

    if F.Node then me=(F.Node(me) or me) end
    return me
end

local C; C = {
    [1] = function (ln, spc, ...) -- spc=CK''
        local blk = node('Block')(ln)
        blk[#blk+1] = node('Dcl_var')(ln, 'var', 'int',  false, '$ret')
        for i=1, FIN do
            blk[#blk+1] = node('Dcl_int')(ln,true,'void',false,'$fin_'..i)
        end
        blk[#blk+1] = node('SetBlock')(ln,
                        EXP(node('Var')(ln, '$ret')),
                        ...)  -- ...=Block

        _AST.root = node('Root')(ln, blk)
        return _AST.root
    end,

    Block   = node('Block'),
    BlockN  = node('BlockN'),
    Host    = node('Host'),

    _Return = node('_Return'),

    Async   = node('Async'),
    VarList = function (ln, ...)
        local t = { ... }
        for i, var in ipairs(t) do
            t[i] = EXP(var)
        end
        return node('VarList')(ln, unpack(t))
    end,

    ParEver = node('ParEver'),
    ParOr   = node('ParOr'),
    ParAnd  = node('ParAnd'),

    _Do = function (ln, b1, b2)
        if not b2 then
            return node('Block')(ln, b1)
        end

        FIN = FIN + 1
        local fin = node('Finally')(ln, b2)
        fin.n = FIN

        local evt = '$fin_'..FIN
        local awt = node('AwaitInt')(ln, node('Var')(ln, evt), true)
        b1[#b1+1] = node('EmitInt')(ln, node('Var')(ln, evt))

        local blk = node('Block')(ln,
                node('ParAnd')(ln,
                    b1,
                    node('BlockN')(ln, awt, fin)))
        blk.fin = fin
        return blk
--[=[
        do
            <b1>
        finally
            <b2>
        end

        // becomes

        event void $1;
        do
            par/and do
                <b1>
                emit $1;
            with
                await $1;
                <b2>
            end
        end
]=]
    end,

    If = function (ln, ...)
        local t = { ... }
        local _else = t[#t]
        for i=#t-1, 1, -2 do
            local c, b = t[i-1], t[i]
            _else = node('If')(ln, c, b, _else)
        end
        return _else
    end,

    Break = node('Break'),
    Loop  = function (ln, _i, _j, blk)
        if not _i then
            return node('Loop')(ln, blk)
        end

        local i = function() return EXP(node('Var')(ln, _i)) end
        local dcl_i = node('Dcl_var')(ln, 'var', 'int', false, _i)
        dcl_i.read_only = true
        local set_i = node('SetExp')(ln, i(),
                                        EXP(node('CONST')(ln, '0')))
        local nxt_i = node('SetExp')(ln, i(),
                        EXP(node('Op2_+')(ln, '+', i(),
                                node('CONST')(ln,'1'))))

        if not _j then
            return node('Block')(ln, dcl_i, set_i,
                                    node('Loop')(ln,blk))
        end

        local j_name = '$j'..tostring(blk)
        local j = function() return EXP(node('Var')(ln, j_name)) end
        local dcl_j = node('Dcl_var')(ln, 'var', 'int', false, j_name)
        local set_j = node('SetExp')(ln, j(), _j)

        local cmp = EXP(node('Op2_>=')(ln, '>=', i(), j()))

        local loop = node('Loop')(ln,
            node('If')(ln, cmp,
                node('Break')(ln),
                node('BlockN')(ln, blk, nxt_i)))
        loop.isBounded = true
        loop[1].isBounded = true    -- remind that the If is "artificial"

        return node('Block')(ln,
                dcl_i, set_i,
                dcl_j, set_j,
                loop)
    end,

    Pause = node('Pause'),

    AwaitExt = node('AwaitExt'),
    AwaitInt = node('AwaitInt'),
    AwaitN   = node('AwaitN'),
    AwaitT   = node('AwaitT'),

    EmitExtE = node('EmitExtE'),
    EmitExtS = node('EmitExtS'),
    EmitT    = node('EmitT'),
    EmitInt  = node('EmitInt'),

    _Dcl_c = function (ln, mod, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
            ret[#ret+1] = node('Dcl_c')(ln, mod, t[i], t[i+1], t[i+2])
        end
        return unpack(ret)
    end,

    Dcl_det = node('Dcl_det'),

    _Dcl_var = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_var')(ln, pre, tp, dim, t[i])
            if t[i+1] then
                ret[#ret+1] = C._Set(ln,
                                EXP(node('Var')(ln,t[i])),  -- var
                                t[i+1],                     -- op
                                t[i+2],                     -- tag
                                t[i+3])                     -- exp
            end
        end
        return unpack(ret)
    end,

    -- TODO: unify with _Dcl_var
    _Dcl_int = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_int')(ln, pre, tp, dim, t[i])
            if t[i+1] then
                ret[#ret+1] = C._Set(ln,
                                EXP(node('Var')(ln,t[i])),  -- var
                                t[i+1],                     -- op
                                t[i+2],                     -- tag
                                t[i+3])                     -- exp
            end
        end
        return unpack(ret)
    end,

    _Set = function (ln, e1, op, tag, e2)
        return node(tag)(ln, e1, e2, op==':=')
    end,

    _Dcl_ext = function (ln, dir, tp, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t do
            ret[#ret+1] = node('Dcl_ext')(ln, dir, tp, t[i])
        end
        return unpack(ret)
    end,

    CallStmt = node('CallStmt'),

    Exp = node('Exp'),
    _Exp = function (ln, ...)
        local v1, v2, v3, v4 = ...
        if not v2 then          -- single value
            return v1
        elseif v1==true then    -- unary expression
            -- v1=true, v2=op, v3=exp
            local op = v2
            if not (op=='not' or op=='&' or op=='-'
                 or op=='+' or op=='~' or op=='*') then
                op = 'cast'
            end
            return node('Op1_'..op)(ln, v2,
                                    C._Exp(ln, select(3,...)))
        else                    -- binary expression
            -- v1=e1, v2=op, v3=e2, v4=?
            if v2 == ':' then
                return C._Exp(ln,
                    node('Op2_.')(ln, '.',
                                    node('Op1_*')(ln,'*',v1), v3),
                    select(4,...)
                )
            else
                return C._Exp(ln,
                    node('Op2_'..v2)(ln, v2, v1, v3),
                    select(4,...)
                )
            end
        end
    end,
    ExpList  = node('ExpList'),

    Var      = node('Var'),
    Ext      = node('Ext'),
    C        = node('C'),
    SIZEOF   = node('SIZEOF'),
    CONST    = node('CONST'),
    WCLOCKK  = node('WCLOCKK'),
    WCLOCKE  = node('WCLOCKE'),
    STRING   = node('STRING'),
    NULL     = node('NULL'),
}

local function i2l (v)
    return _I2L[v]
end

for rule, f in pairs(C) do
    _GG[rule] = (m.Cp()/i2l) * _GG[rule] / f
end

for i=1, 12 do
    local tag = '_'..i
    _GG[tag] = (m.Cp()/i2l) * _GG[tag] / C._Exp
end

_GG = m.P(_GG):match(_STR)

-------------------------------------------------------------------------------

function PSE_cndor (me)
    local cnd
    for pse in _AST.iter('Pause') do
        local int = unpack(pse)
        int = EXP(node('Var')(me.ln,int[1]))
        cnd = cnd and EXP(node('Op2_or')(me.ln, 'or', cnd, int))
            or int
    end
    return cnd
end

function PSE_paror (me)
    local par = node('ParOr')(me.ln)
    for pse in _AST.iter('Pause') do
        local int = unpack(pse)
        par[#par+1] = node('AwaitInt')(me.ln, node('Var')(me.ln,int[1]))
    end
    return par
end

F = {
    Block_pre = function (me)
        me.par = _AST.iter'Block'()
    end,

    SetBlock_pre = function (me)
        me.blk = _AST.iter'Block'()
    end,
    _Return = function (me)
        local set = _AST.iter'SetBlock'()
        local e2 = unpack(me)
        local var = node('Var')(me.ln,set[1][1][1])
        var.blk = set.blk
        var.ret = true

        local blk = node('BlockN')(me.ln)
        blk[#blk+1] = node('SetExp')(me.ln, EXP(var), e2, set[3])

        -- Finalizer
        for i=1, FIN do
            blk[#blk+1] = node('EmitInt')(blk.ln,
                            node('Var')(blk.ln, '$fin_'..i))
        end

        blk[#blk+1] = node('Return')(me.ln)
        return blk
    end,

    SetAwait = function (me)
        local _, awt = unpack(me)
        awt.ret = awt.ret or awt
    end,

    AwaitExt = 'AwaitInt',
    AwaitInt = function (me)
        if not _AST.iter('Pause')() or
           string.find(me[1][1], '$fin_') then
            return
        end
        local cnd = PSE_cndor(me)
        cnd = EXP(node('Op1_not')(me.ln, 'not', cnd))
        local n = node('Loop')(me.ln,
                    node('BlockN')(me.ln,
                        me,
                        node('If')(me.ln, cnd, node('Break')(me.ln))))
        n.ret = me
        return n
--[[
    loop do
        await X;
        if not (evt1 or .. or evtN) then
            break;
        end
    end
]]
    end,

    AwaitT = function (me)
        if not _AST.iter('Pause')() then
            return me
        end
        local ln = me.ln

        local DT = unpack(me)
        me[1] = node('WCLOCKE')(ln, EXP(node('Var')(ln,'$dt')), 'us')

        local REM = node('WCLOCKR')(ln)
        REM.awt = me

        local L1 = node('Loop')(ln,
                    node('BlockN')(ln,
                        PSE_paror(me),
                        node('If')(ln, PSE_cndor(me),
                            node('BlockN')(ln,
                                node('SetExp')(ln,
                                    EXP(node('Var')(ln,'$dt')),
                                    REM),
                                node('Break')(ln)))))

        local L2 = node('Loop')(ln,
                    node('BlockN')(ln,
                        PSE_paror(me),
                        node('If')(ln,
                            EXP(node('Op1_not')(ln,'not',PSE_cndor(me))),
                            node('Break')(ln))))

        local L0 = node('Loop')(ln,
                    node('BlockN')(ln,
                        node('ParOr')(ln,
                            node('BlockN')(ln, me, node('Break')(ln)),
                            L1),
                        L2))

        local blk = node('Block')(ln,
                        node('Dcl_var')(ln, false, 'u32',  false, '$dt'),
                        node('SetExp')(ln,
                            EXP(node('Var')(ln,'$dt')),
                            DT),
                        L0)
        blk.par = _AST.iter('Block')()
        blk.ret = me
        return blk
--[[
    u32 $dt = e1;

    -- LOOP 0
    loop do
        par/or do
            await ($dt);
            break;
        with
            -- LOOP 1
            loop do
                par/or do
                    await pse1;
                with
                    await pseN;
                end
                if pse1 or pseN then
                    $dt = TMR.togo;
                    break;
                end
            end
        end

        -- LOOP 2
        loop do
            par/or do
                await pse1;
            with
                await pseN;
            end
            if not(pse1 or pseN) then
                break;
            end
        end
    end
]]
    end,

    -- Finalizer
    ParOr = function (me)
        for i, sub in ipairs(me) do
            for i=1, FIN do
                sub[#sub+1] = node('EmitInt')(sub.ln,
                                node('Var')(sub.ln, '$fin_'..i))
            end
        end
    end,
    Break = function (me)
        local blk = node('BlockN')(me.ln)
        for i=1, FIN do
            blk[#blk+1] = node('EmitInt')(blk.ln,
                            node('Var')(blk.ln, '$fin_'..i))
        end
        blk[#blk+1] = me
        return blk
    end,
}

_AST.visit(F)

end

--    _AST.dump(_AST.root)
    
do

local function ceil (v)
    local w = _OPTS.tp_word
    while true do
        if v % w == 0 then
            return v
        else
            v = v + 1
        end
    end
end

_OPTS.tp_word    = assert(tonumber(_OPTS.tp_word),
    'missing `--tp-word´ parameter')
_OPTS.tp_pointer = assert(tonumber(_OPTS.tp_pointer),
    'missing `--tp-pointer´ parameter')
_OPTS.tp_off     = assert(tonumber(_OPTS.tp_off),
    'missing `--tp-off´ parameter')
_OPTS.tp_lbl     = assert(tonumber(_OPTS.tp_lbl),
    'missing `--tp-lbl´ parameter')

_ENV = {
    exts = {},
    c = {
        void = 0,

        u8=1, u16=2, u32=4,
        s8=1, s16=2, s32=4,

        int       = _OPTS.tp_word,
        pointer   = _OPTS.tp_pointer,
        tceu_noff = _OPTS.tp_off,
        tceu_nlbl = _OPTS.tp_lbl,
        tceu_wclock = ceil(4 + _OPTS.tp_lbl + 2       -- TODO: perda de memoria :: +2 to adjust micaz struct size
                          + (_OPTS.analysis_run and 4 or 0)),
    },
    calls = {},     -- { _printf=true, _myf=true, ... }

    n_asyncs  = 0,
    n_wclocks = 0,
    n_emits   = 0,
    awaits    = {},
	gate0     = 0; --afb
	
    dets  = {},
}

for k, v in pairs(_ENV.c) do
    _ENV.c[k] = { tag='type', id=k, len=v }
end

function newvar (me, blk, pre, tp, dim, id)
    for stmt in _AST.iter() do
        if stmt.tag == 'Async' then
            break
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                WRN(var.id~=id, me,
                    'declaration of "'..id..'" hides the one at line '..var.ln)
            end
        end
    end

    local tp_raw = _TP.raw(tp)
    local c = _ENV.c[tp_raw]
    local isEvt = (pre ~= 'var')

    ASR(c and c.tag=='type', me, 'undeclared type `'..tp_raw..'´')
    ASR(_TP.deref(tp) or (not c) or (tp=='void' and isEvt) or c.len>0, me,
        'cannot instantiate type "'..tp..'"')
    ASR((not dim) or dim>0, me, 'invalid array dimension')

    local var = {
        ln    = me.ln,
        id    = id,
        tp    = (dim and tp..'*') or tp,
        blk   = blk,
        pre   = pre,
        isEvt = isEvt,
        arr   = dim,
        n_awaits = 0,
    }
    blk.vars[#blk.vars+1] = var

    return var
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

F = {
    Block_pre = function (me)
        me.vars = {}
        local async = _AST.iter()()
        if async.tag == 'Async' then
            local vars, blk = unpack(async)
            if vars then
                for _, n in ipairs(vars) do
                    local var = n[1].var
                    ASR(not var.arr, vars, 'invalid argument')
                    n.new = newvar(vars, blk, false, var.tp, nil, var.id)
                end
            end
        end
    end,

    Dcl_ext = function (me)
        local dir, tp, id = unpack(me)
        ASR(not _ENV.exts[id], me, 'event "'..id..'" is already declared')
        ASR(tp=='void' or tp=='int' or _TP.deref(tp),
                me, 'invalid event type')

        me.ext = {
            ln    = me.ln,
            id    = id,
            n     = #_ENV.exts,
            tp    = tp,
            pre   = dir,
            isEvt = true,
        }
        _ENV.exts[id] = me.ext
        _ENV.exts[#_ENV.exts+1] = me.ext
    end,

    Dcl_int = 'Dcl_var',
    Dcl_var = function (me)
        local pre, tp, dim, id, exp = unpack(me)
        me.var = newvar(me, _AST.iter'Block'(), pre, tp, dim, id)
    end,

    Ext = function (me)
        local id = unpack(me)
        me.ext = ASR(_ENV.exts[id],
            me, 'event "'..id..'" is not declared')
    end,

    Var = function (me)
        local id = unpack(me)
        local blk = me.blk or _AST.iter('Block')()
        while blk do
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
                    me.var  = var
                    me.tp   = var.tp
                    me.lval = (not var.arr)
                    me.fst  = var
                    return
                end
            end
            blk = blk.par
        end
        ASR(false, me, 'variable/event "'..id..'" is not declared')
    end,

    Dcl_c = function (me)
        local mod, tag, id, len = unpack(me)
        _ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
    end,

    Dcl_det = function (me)                 -- TODO: verify in _ENV.c
        local id1 = det2id(me[1])
        local t1 = _ENV.dets[id1] or {}
        _ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])
            local t2 = _ENV.dets[id2] or {}
            _ENV.dets[id2] = t2
            t1[id2] = true
            t2[id1] = true
        end
    end,

    Pause = function (me)
        local exp, _ = unpack(me)
        ASR(exp.var.isEvt, me, 'event "'..exp.var.id..'" is not declared')
        ASR(_TP.isNumeric(exp.var.tp), me, 'event type must be numeric')
    end,

    AwaitExt = function (me)
        local e1,_ = unpack(me)
        local ext = e1.ext
        me.gte = (_ENV.awaits[ext] or 0)
        _ENV.awaits[ext] = (_ENV.awaits[ext] or 0) + 1
    end,

    AwaitInt = function (me)
        local exp,_ = unpack(me)
        local var = exp.var
        ASR(var and var.isEvt, me,
                'event "'..(var and var.id or '?')..'" is not declared')
        me.gte = var.n_awaits
        var.n_awaits = var.n_awaits + 1
    end,

    AwaitT = function (me)
        me.gte = _ENV.n_wclocks
        _ENV.n_wclocks = _ENV.n_wclocks + 1
    end,

    EmitInt = function (me)
        local e1, e2 = unpack(me)
        ASR(e1.var.isEvt, me, 'event "'..e1.var.id..'" is not declared')
        ASR(((not e2) or _TP.contains(e1.var.tp,e2.tp,true)),
                me, 'invalid emit')

        me.gte = _ENV.n_emits
        _ENV.n_emits = _ENV.n_emits + 2     -- (cnt/awk)
    end,

    EmitExtS = function (me)
        local e1, _ = unpack(me)
        if e1.ext.pre=='output' then
            F.EmitExtE(me)
        end
    end,
    EmitExtE = function (me)
        local e1, e2 = unpack(me)
        ASR(e1.ext.pre=='output', me, 'invalid input `emit´')
        me.tp = 'int'

        if e2 then
            ASR(_TP.contains(e1.ext.tp,e2.tp,true),
                    me, "non-matching types on `emit´")
        else
            ASR(e1.ext.tp=='void',
                    me, "missing parameters on `emit´")
        end
-- afb [
        if e2 then
            ASR(e2[1][1]~='idx',
                    me, "indexed var is not permited on `emit´")
        end
-- afb ]

    end,

    Async = function (me)
        me.gte = _ENV.n_asyncs
        _ENV.n_asyncs = _ENV.n_asyncs + 1
    end,

    -- gates for cleaning
    ParOr_pre = function (me)
        me.gtes = {
            asyncs  = { _ENV.n_asyncs,  nil },
            wclocks = { _ENV.n_wclocks, nil },
            emits   = { _ENV.n_emits,   nil },
        }

        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                me.gtes[ext] = { _ENV.awaits[ext] or 0, nil }
            end
        end

        for blk in _AST.iter'Block' do
            for _, var in ipairs(blk.vars) do
                if var.isEvt then
                    me.gtes[var] = { var.n_awaits, nil }
                end
            end
        end
    end,
    ParOr = function (me)
        me.gtes.asyncs[2]  = _ENV.n_asyncs
        me.gtes.wclocks[2] = _ENV.n_wclocks
        me.gtes.emits[2]   = _ENV.n_emits

        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                local t = me.gtes[ext]
                if t then
                    t[2] = _ENV.awaits[ext] or 0
                end
            end
        end

        for blk in _AST.iter'Block' do
            for _, var in ipairs(blk.vars) do
                if var.isEvt then
                    me.gtes[var][2] = var.n_awaits
                end
            end
        end
    end,
    Loop_pre     = 'ParOr_pre',
    Loop         = 'ParOr',
    SetBlock_pre = 'ParOr_pre',
    SetBlock     = 'ParOr',

    --------------------------------------------------------------------------

    SetExp = function (me)
        local e1, e2, no_fin = unpack(me)
        e1 = e1 or _AST.iter'SetBlock'()[1]
        ASR(e1.lval and _TP.contains(e1.tp,e2.tp,true),
                me, 'invalid attribution')

        if no_fin then
            return              -- no `finally´ required
        end

        if _TP.deref(e1.tp) then
            local blk1 = (e1.fst=='_' and _AST.root) or e1.fst.blk
            if e2.fst and e2.fst~='_' then
                local blk2 = e2.fst.blk
                ASR(blk2.fin or blk2.depth<=blk1.depth, me,
                    'block at line '..blk2.ln..' must contain `finally´')
                -- int a; pa=&a;    -- `a´ termination must consider `pa´
            else
                ASR(blk1.fin or e2[1].tag~='Op2_call' or e2[1].c.mod=='pure',
                    me, 'block at line '..blk1.ln..' must contain `finally´')
                -- int* pa = _f();   -- `pa´ termination must consider `_f´
            end
        end
    end,

    SetAwait = function (me)
        local e1, awt = unpack(me)
        ASR(e1.lval, me, 'invalid attribution1')
        if awt.ret.tag == 'AwaitT' then
            ASR(_TP.isNumeric(e1.tp,true), me, 'invalid attribution2')
        else    -- AwaitInt / AwaitExt
            local evt = awt.ret[1].var or awt.ret[1].ext
            ASR(_TP.contains(e1.tp,evt.tp,true), me, 'invalid attribution3')
        end
        me.fst = awt.fst
    end,

    CallStmt = function (me)
        local call = unpack(me)
        ASR(call[1].tag == 'Op2_call', me, 'invalid statement')
    end,

    --------------------------------------------------------------------------

    Exp = function (me)
        me.lval = me[1].lval
        me.tp   = me[1].tp
        me.fst  = me[1].fst
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        me.tp  = '_'
        me.fst = '_'
        if f.tag == 'C' then
            me.c = _ENV.c[ f[1] ]
            ASR(me.c.tag=='func', me,
                'C function "'..(f[1])..'" is not declared')
            me.fid = f[1]
        else
            me.fid = '$anon'
        end
        _ENV.calls[me.fid] = true
        ASR((not _OPTS.c_calls) or _OPTS.c_calls[me.fid],
            me, 'C calls are disabled')
        if not (me.c and (me.c.mod=='pure' or me.c.mod=='nohold')) then
            if me.org then
                error'oi'
            end
            for _, exp in ipairs(exps) do
                if _TP.deref(exp.tp) and exp.fst then
                    local blk = (exp.fst=='_' and _AST.root) or exp.fst.blk
                    ASR(blk.fin, me,
                        'block at line '..blk.ln..' must contain `finally´')
                    -- int* pa; _f(pa); -- `pa´ termination must consider `_f´
                end
            end
        end
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        local _arr = ASR(_TP.deref(arr.tp,true), me, 'cannot index a non array')
        ASR(_arr and _TP.isNumeric(idx.tp,true), me, 'invalid array index')
        me.tp   = _arr
        me.lval = true
        me.fst  = arr.fst
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.isNumeric(e1.tp,true) and _TP.isNumeric(e2.tp,true),
            me, 'invalid operands to binary "'..op..'"')
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.isNumeric(e1.tp,true),
                me, 'invalid operand to unary "'..op..'"')
    end,
    ['Op1_~']  = 'Op1_int',
    ['Op1_-']  = 'Op1_int',

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = 'int'
        ASR(_TP.max(e1.tp,e2.tp,true),
                me, 'invalid operands to binary "'..op..'"')
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        me.tp  = 'int'
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op2_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.tp   = _TP.deref(e1.tp, true)
        me.lval = true
        me.fst  = e1.fst
        ASR(me.tp, me, 'invalid operand to unary "*"')
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        ASR(e1.lval, me, 'invalid operand to unary "&"')
        me.tp   = e1.tp..'*'
        me.lval = false
        me.fst  = e1.fst
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        me.tp   = '_'
        me.lval = true
        me.fst  = e1.fst
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.tp   = tp
        me.lval = exp.lval
        me.fst  = exp.fst
     end,

    C = function (me)
        local id = unpack(me)
        local c = _ENV.c[id]
        ASR(c and (c.tag=='var' or c.tag=='func'), me,
            'C variable/function "'..id..'" is not declared')
        me.tp   = '_'
        me.lval = '_'
        me.fst  = '_'
    end,

    WCLOCKK = function (me)
        me.tp   = 'int'
        me.lval = false
        me.fst  = false
    end,
    WCLOCKE = 'WCLOCKK',
    WCLOCKR = 'WCLOCKK',

    SIZEOF = function (me)
        me.tp   = 'int'
        me.lval = false
    end,

    STRING = function (me)
        me.tp   = 'char*'
        me.lval = false
        me.fst  = false
    end,
    CONST = function (me)
        local v = unpack(me)
        me.tp   = _TP.getConstType(v)
        me.lval = false
        me.fst  = false
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
    end,
    NULL = function (me)
        me.tp   = 'void*'
        me.lval = false
        me.fst  = false
    end,
}

_AST.visit(F)

end

    
do
function MAX_all (me, t)
    t = t or me
    me.n_tracks = 1
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.n_tracks = MAX(me.n_tracks, sub.n_tracks)
        end
    end
end

function ADD_all (me, t)
    t = t or me
    me.n_tracks = 0
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.n_tracks = me.n_tracks + sub.n_tracks
        end
    end
end

_PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_asyncs  = false,
    has_emits   = false,
}

local NO_fin = {
    Loop=true, Finally=true, Break=true,
    Host=true, Return=true, Async=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
}

local NO_async = {
    ParEver=true, ParOr=true, ParAnd=true,
    EmitInt=true,
    Async=true,
    AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
}

F = {
    Node_pre = function (me)
        me.n_tracks = 1
    end,
    Node = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
        if NO_fin[me.tag] then
            ASR(not _AST.iter'Finally'(), me, 'not permitted inside `finally´')
        end
        if NO_async[me.tag] then
            ASR(not _AST.iter'Async'(), me,'not permitted inside `async´')
        end
    end,

    Root    = ADD_all,
    Block   = MAX_all,
    BlockN  = MAX_all,
    ParEver = ADD_all,
    ParAnd  = ADD_all,
    ParOr   = ADD_all,

    Dcl_ext = function (me)
        _PROPS.has_exts = true
    end,

    Async = function (me)
        _PROPS.has_asyncs = true
    end,

    If = function (me)
        local c, t, f = unpack(me)
        f = f or c
        MAX_all(me, {t,f})
    end,

    ParOr_pre = function (me)
        me.nd_join = true
    end,

    Loop_pre = function (me)
        F.ParOr_pre(me)
        me.brks = {}
    end,
    Break = function (me)
        local loop = _AST.iter'Loop'()
        ASR(loop, me, 'break without loop')
        loop.brks[me] = true

        local fin = _AST.iter'Finally'()
        ASR(not fin or fin.depth<loop.depth, me, 'not permitted inside `finally´')

        local async = _AST.iter'Async'()
        if async then
            local loop = _AST.iter'Loop'()
            ASR(loop.depth>async.depth, me, '`break´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        F.ParOr_pre(me)
        me.rets = {}
    end,
    Return = function (me)
        local blk = _AST.iter'SetBlock'()
        blk.rets[me] = true

        local async = _AST.iter'Async'()
        if async then
            local setblk = _AST.iter'SetBlock'()
            ASR(async.depth<=setblk.depth+1, me, '`return´ without block')
        end
    end,

    AwaitT = function (me)
        _PROPS.has_wclocks = true
    end,

    EmitInt = function (me)
        me.n_tracks = 2     -- cont / match
        _PROPS.has_emits = true
    end,

    EmitExtS = function (me)
        if _AST.iter'Async'() then
            ASR(me[1].ext.pre=='input',  me, 'not permitted inside `async´')
        else
            ASR(me[1].ext.pre=='output', me, 'not permitted outside `async´')
        end
    end,
    EmitExtE = function (me)
        F.EmitExtS(me)
    end,
    EmitT = function (me)
        ASR(_AST.iter'Async'(), me,'not permitted outside `async´')
    end,

    SetExp = function (me)
        local e1, e2 = unpack(me)
        local async = _AST.iter'Async'()
        if async and (not e1) then
            ASR( async.depth <= _AST.iter'SetBlock'().depth+1,
                    me, 'invalid access from async')
        end
    end,

    Var = function (me)
        local async = _AST.iter'Async'()
        if async then
            ASR(_AST.iter'VarList'() or         -- param list
                me.ret or                       -- var assigned on return
                async.depth < me.var.blk.depth, -- var is declared inside
                    me, 'invalid access from async')
        end
    end,
}

_AST.visit(F)

end

    
do
_MEM = {
    off  = 0,
    max  = 0,
    gtes = {
        exts = {},
    },
    vars = {},
}

function alloc (n)
    local cur = _MEM.off
    _MEM.off = _MEM.off + n
    _MEM.max = MAX(_MEM.max, _MEM.off)
    return cur
end


local t2n = {
     us = 10^0,
     ms = 10^3,
      s = 10^6,
    min = 60*10^6,
      h = 60*60*10^6,
}


local t2idx = {
     us = 0,
     ms = 1,
      s = 2,
    min = 3,
      h = 4,
}

_MEM.t2idx=t2idx

function accs_join (dst, src)
    if src.accs then
        for _,v in ipairs(src.accs) do
            dst.accs[#dst.accs+1] = v
        end
    end
end

local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

F = {
    Root_pre = function (me)
        _MEM.gtes.wclock0 = alloc(_ENV.n_wclocks * _ENV.c.tceu_wclock.len)
        _MEM.gtes.async0  = alloc(_ENV.n_asyncs  * _ENV.c.tceu_nlbl.len)
        _MEM.gtes.emit0   = alloc(_ENV.n_emits   * _ENV.c.tceu_nlbl.len)
        local int outcount=0;
        _ENV.gate0 = _MEM.off; --afb save gates0 offset value
        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                _MEM.gtes[ext.n] = alloc(1 +
                                    (_ENV.awaits[ext] or 0)
                                    *_ENV.c.tceu_nlbl.len)
            end
            if ext.pre == 'output' then
            	ext.seq = outcount;
            	outcount = outcount + 1;
            end
        end
        _MEM.gtes.loc0 = alloc(0)
    end,

    Block_pre = function (me)
        me.off = _MEM.off

        for _, var in ipairs(me.vars) do
            local len
            if var.arr then
				if _TP.deref(_TP.deref(var.tp)) then 
                    len = 2 * var.arr
                else
                	len = _ENV.c[_TP.deref(var.tp)].len * var.arr
                end
            elseif _TP.deref(var.tp) then
                len = _ENV.c.pointer.len
            else
                len = _ENV.c[var.tp].len
            end
            
            if _OPTS.analysis_run then
                var.off = 0
            else
                var.off = alloc(len)
            end
            -- afb build a var table in _MEM
            _MEM.vars[var.off]= var.id
            
            if var.isEvt then
                var.awt0 = alloc(1)
				-- afb build a var table in _MEM
		        _MEM.vars[var.awt0]= var.id..'_awt0'
                local temp=alloc(_ENV.c.tceu_nlbl.len*var.n_awaits)
				-- afb build a var table in _MEM
		        _MEM.vars[temp]= var.id..'_waits['..var.n_awaits..']'
            end

-- afb            var.val = '(*(('.._TP.c(var.tp)..'*)(CEU->mem+'..var.off..')))'
            var.val = ''..var.off..''
            if var.arr then
-- afb                var.val = '(('.._TP.c(var.tp)..')(&'..var.val..'))'
                var.val = ''..var.off..''
            end
        end

        me.max = _MEM.off
    end,
    Block = function (me)
        for blk in _AST.iter'Block' do
            blk.max = MAX(blk.max, _MEM.off)
        end
        _MEM.off = me.off
    end,

    ParEver_aft = function (me, sub)
        me.lst = sub.max
    end,
    ParEver_bef = function (me, sub)
        _MEM.off = me.lst or _MEM.off
    end,
    ParOr_aft  = 'ParEver_aft',
    ParOr_bef  = 'ParEver_bef',
    ParAnd_aft = 'ParEver_aft',
    ParAnd_bef = 'ParEver_bef',

    ParAnd_pre = function (me)
        me.off = alloc(#me)        -- TODO: bitmap?
		-- afb build a var table in _MEM
        _MEM.vars[me.off]= 'ParAnd_flag['..#me..']'
    end,
    ParAnd = 'Block',

    -- for analysis_run, ParEver behaves like ParAnd (n_reachs)
    ParEver_pre = function (me)
        if _OPTS.analysis_run then
            F.ParAnd_pre(me)
        end
    end,
    ParEver = function (me)
        if _OPTS.analysis_run then
            F.Block(me)
        end
    end,

    Var = function (me)
        me.val = me.var.val
        me.accs = { {me.var, (me.var.arr and 'no') or 'rd', me.var.tp, false,
                    'variable/event `'..me.var.id..'´ (line '..me.ln..')'} }
    end,
    AwaitInt = function (me)
        local e = unpack(me)
        e.accs[1][2] = 'aw'
        if string.sub(e.var.id,1,4) == '$fin' then
            e.accs[1][2] = 'no'
        end
        me.val = e.val
    end,
    EmitInt = function (me)
        local e1, e2 = unpack(me)
        e1.accs[1][2] = 'tr'
        if string.sub(e1.var.id,1,4) == '$fin' then
            e1.accs[1][2] = 'no'
        end
    end,

    --------------------------------------------------------------------------

    SetAwait = 'SetExp',
    SetExp = function (me)
        local e1, e2 = unpack(me)
        e1.accs[1][2] = 'wr'
    end,

    EmitExtS = function (me)
        local e1, _ = unpack(me)
        if e1.ext.pre == 'output' then
            F.EmitExtE(me)
        end
    end,
    EmitExtE = function (me)
        local e1, e2 = unpack(me)
        e1.acc = {e1.ext.id, 'cl', '_', false,
                    'event `'..e1.ext.id..'´ (line '..me.ln..')'}
        local len, val, valType
        if e2 then
            local tp = _TP.deref(e1.ext.tp, true)
            if tp then
                len = _ENV.c[_TP.deref(_TP.deref(e2.tp)) or _TP.deref(e2.tp) or e2.tp].len --'sizeof('.._TP.c(tp)..')'
                val = e2.val
                valType = ''
                if e2.accs and tp then
                    e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become "any"
                    local c = _ENV.c[me.fid]
                    e2.accs[1][2] = (c and c.mod=='pure' and 'rd') or 'wr'
                    e2.accs[1][3] = tp
                end
            else
                len = _ENV.c[_TP.deref(e2.tp) or e2.tp].len -- 'sizeof('.._TP.c(e1.ext.tp)..')'
--afb                val = 'ceu_ext_f('..e2.val..')'
                val = e2.val
                valType = e2.tp
            end
            -- afb : Resize array len
            if (type(e2.fst)=='table' and e2.fst.arr) then
            	len = len * e2.fst.arr
            end
        else
            len = 0
-- afb            val = 'NULL'
            val = '0'
            valType = _TP.getConstType(val)
        end
		
--        me.val = '\n'..[[
--     //> ceu_out_event(OUT_]]..e1.ext.id..','..len..','..val..[[)
--afb #if defined(ceu_out_event_]]..e1.ext.id..[[)
--afb     ceu_out_event_]]..e1.ext.id..'('..val..[[)
--afb #elif defined(ceu_out_event)
--afb     ceu_out_event(OUT_]]..e1.ext.id..','..len..','..val..[[)
--afb #else
--afb     0
--afb #endif
--afb ]]
    end,
    AwaitExt = function (me)
        local e1 = unpack(me)
        if _TP.deref(e1.ext.tp) then
            me.val = '(('.._TP.c(e1.ext.tp)..')CEU->ext_data)'
        else
            me.val = '*((int*)CEU->ext_data)'
        end
    end,
    AwaitT = function (me)
        me.val = 'CEU->wclk_late'
    end,

    Exp = function (me)
        me.val  = me[1].val
        me.accs = me[1].accs
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        me.accs = {}
        accs_join(me, f)
        f.accs[1][2] = 'cl'
        for i, exp in ipairs(exps) do
            ps[i] = exp.val
            accs_join(me, exp)
            local tp = _TP.deref(exp.tp, true)
            if exp.accs and tp then
                exp.accs[1][4] = (exp.accs[1][2] ~= 'no')   -- &x does not become "any"
                exp.accs[1][2] = (me.c and me.c.mod=='pure' and 'rd') or 'wr'
                exp.accs[1][3] = tp
            end
        end
        me.val = f.val..'('..table.concat(ps,',')..')'
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
-- afb        me.val = '('..arr.val..'['..idx.val..'])'
        me.val = arr.val --''..arr.val..' '..idx.tp..' '..idx.val..' '.. _TP.getConstType(me.fst.arr)..' '..me.fst.arr
        me.accs = {}
        accs_join(me, arr)
        accs_join(me, idx)
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        me.val = '('..e1.val..ceu2c(op)..e2.val..')'
        me.val = '('..e1.val..ceu2c(op)..e2.val..')'
        me.accs = e1.accs
        me.accs = {}
        accs_join(me, e1)
        accs_join(me, e2)

    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..e1.val..')'
        me.accs = e1.accs
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..e1.val..')'
        me.accs = e1.accs
        me.accs[1][3] = _TP.deref(me.accs[1][3], true)
        me.accs[1][4] = true
    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op)..e1.val..')'
        me.accs = e1.accs
        me.accs[1][2] = 'no'
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        me.val  = '('..e1.val..ceu2c(op)..id..')'
        me.accs = e1.accs
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.val = '(('.._TP.c(tp)..')'..exp.val..')'
        me.accs = exp.accs
    end,

    WCLOCKK = function (me)
        local h,min,s,ms,us = unpack(me)
        me.us  = us*t2n.us + ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h
        me.ms  = (us*t2n.us + ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h)/1000
--afb        me.val = me.us
        me.val = _TP.getConstType(me.us / 1000)..' '..me.us / 1000   -- Convert micro to milli
--afb        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
        ASR(me.ms>0 and me.ms<= (math.pow(2,32))-1, me, 'constant is out of range')
    end,

    WCLOCKE = function (me)
        local exp, unit = unpack(me)
        me.us   = nil
--afb        me.val  = exp.val .. '*' .. t2n[unit] .. 'L'
        me.val  = t2idx[unit]..' '..exp.tp..' '..exp.val
        me.accs = exp.accs
    end,

    WCLOCKR = function (me)
        me.val = 'PTR(tceu_wclock*,CEU_WCLOCK0)['..me.awt.gte..'].togo'
    end,

    C = function (me)
        me.val = string.sub(me[1], 2)
        me.accs = { {me[1], 'rd', '_', false,
                    'symbol `'..me[1]..'´ (line '..me.ln..')'} }
    end,
    SIZEOF = function (me)
        me.val = 'sizeof('.._TP.c(me[1])..')'
    end,
    STRING = function (me)
        me.val = me[1]
    end,
    CONST = function (me)
        me.val = me[1]
    end,
    NULL = function (me)
        me.val = '((void *)0)'
    end,
}

_AST.visit(F)

end

    
do
function OR_all (me, t)
    t = t or me
    me.awaits  = false
    me.returns = false
    me.blocks  = false
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.awaits  = me.awaits  or sub.awaits
            me.returns = me.returns or sub.returns
            me.blocks  = me.blocks or sub.blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.awaits  = true
    me.returns = true
    me.blocks  = true
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.awaits  = me.awaits  and sub.awaits
            me.returns = me.returns and sub.returns
            me.blocks  = me.blocks and sub.blocks
        end
    end
end

function SAME (me, sub)
    sub = sub or me[1]
    me.awaits  = sub.awaits
    me.returns = sub.returns
    me.blocks  = sub.blocks
end

F = {
    Node_pre = function (me)
        me.awaits  = false
        me.returns = false
        me.blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Block   = OR_all,
    BlockN  = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,

    Finally = SAME,

    If = function (me)
        local c, t, f = unpack(me)
        t = t or c
        f = f or c
        if me.isBounded then
            SAME(me, f)
        else
            AND_all(me, {t,f})
        end
    end,

    ParOr = AND_all,

    Break = function (me)
        me.blocks = true
    end,
    Loop = function (me)
        local body = unpack(me)
        SAME(me, body)
        ASR(_AST.iter'Async'() or me.isBounded or body.blocks,
                me,'tight loop')
        me.blocks = body.awaits or body.returns
    end,

    SetBlock = function (me)
        local _,blk = unpack(me)
        SAME(me, blk)
        me.returns = false
    end,
    Return = function (me)
        me.returns = true
        me.blocks  = true
    end,

    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.awaits = true
        me.blocks = true
    end,

    AwaitExt = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitInt = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitT = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitN = function (me)
        me.awaits = true
        me.blocks = true
    end,
}

_AST.visit(F)

end

    
do
_LABELS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code = '',
    gte2lbl = {},   --
}

function new (lbl)
    lbl.id = lbl[1] .. (lbl[2] and '' or '_' .. #_LABELS.list)
    lbl.id = string.gsub(lbl.id, '%$','_')

    _LABELS.list[lbl] = true
    lbl.n = #_LABELS.list                   -- starts from 0
    _LABELS.list[#_LABELS.list+1] = lbl
    lbl.par = {}                            -- { [lblK]=true }

    for n in _AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end
    return lbl
end

F = {
    Exp = function (me)
        if me.accs then
            for _, acc in ipairs(me.accs) do
                acc.lbl_ana = new{'Exp', acc=acc}
            end
        end
    end,

    Root_pre = function (me)
        new{'Inactive', true}
        new{'Init', true}
    end,

    Root = function (me)
        assert(#_LABELS.list < 2^(_ENV.c.tceu_nlbl.len*8))
        me.lbl_ana = new{'Exit'}

        -- enum of labels
        for i, lbl in ipairs(_LABELS.list) do
            _LABELS.code = _LABELS.code..'    '..lbl.id..' = '..lbl.n..',\n'
        end
    end,

    _Escape_pre = function (me)
        me.lbls_emt = { #_LABELS.list }
    end,
    _Escape = function (me)
        me.lbls_emt[2] = #_LABELS.list-1
    end,

    SetBlock_pre = function (me)
        F._Escape_pre(me)
        me.lbl_ana_no = new{'SetBlock_no', to_reach=false,
                            me=me, err='end of block'}
        me.lbl_out = new{'Set_out', tree=me.depth,
                        me=me, err='`return´ from block'}
        if me[1][1][1] ~= '$ret' then
            me.lbl_out.to_reach = true
        end
    end,
    SetBlock = '_Escape',

    _Par_pre = function (me)
        me.lbls_in  = {}
        for i, sub in ipairs(me) do
            me.lbls_in[i] = new{me.tag..'_sub_'..i}
            sub.lbls_all = {}
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParEver_chk'}
        me.lbl_ana_out = new{'ParEver_out'}
        me.lbl_ana_no  = new{'ParEver_no', to_reach=false,
                        me=me, err='end of `par´'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out', tree=me.depth, to_reach=true,
                        me=me, err='end of `par/or´'}
        F._Escape_pre(me)
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_ana_out = new{'ParAnd_out', to_reach=true,
                        me=me, err='end of `par/and´'}
    end,

    ParEver = function (me)
        for i=1, #me do
            local t1 = me[i].lbls_all
            for j=i+1, #me do
                local t2 = me[j].lbls_all
                for lbl1 in pairs(t1) do
                    for lbl2 in pairs(t2) do
                        lbl1.par[lbl2] = true
                        lbl2.par[lbl1] = true
                    end
                end
            end
        end
    end,
    ParAnd = 'ParEver',
    ParOr = function (me)
        F.ParEver(me)
        F._Escape(me)
    end,

    If = function (me)
        local c, t, f = unpack(me)
        me.lbl_t = new{'True'}
        me.lbl_f = f and new{'False'}
        me.lbl_e = new{'EndIf'}
    end,

    Async_pre = function (me)
        me.lbls_all = {}
    end,
    Async = function (me)
        for lbl in pairs(me.lbls_all) do
            lbl.to_reach = nil                          -- they are not simulated
        end
        me.lbl = new{'Async_'..me.gte, to_reach=true,   -- after `for´ above
                    me=me, err='`async´'}
    end,

    Loop_pre = function (me)
        me.lbl_ini = new{'Loop_ini'}
        me.lbl_ana_mid = new{'Loop_mid', to_reach=true,
                        me=me, err='`loop´ iteration'}
        me.lbl_out = new{'Loop_out', tree=me.depth }
        F._Escape_pre(me)
    end,
    Loop = '_Escape',

    EmitExtS = function (me)
        local e1 = unpack(me)
        if e1.ext.pre == 'output' then   -- e1 not Exp
            me.lbl_ana_emt = new{'Emit_'..e1.ext.id, acc=e1.acc}
        end
        me.lbl_cnt = new{'Async_cont'}
    end,
    EmitT = function (me)
        me.lbl_cnt = new{'Async_cont'}
    end,

    EmitInt = function (me)
        local int = unpack(me)
        me.lbl_ana_emt = new{'Emit_ana_emt_'..int.var.id, acc=int.accs[1]} -- int not Exp
        me.lbl_mch     = new{'Emit_mch_'..int.var.id}
        me.lbl_cnt     = new{'Emit_cnt_'..int.var.id}
        me.lbl_ana_cnt = new{'Emit_ana_cnt_'..int.var.id, to_reach=true,
                            me=me, err='continuation of `emit´'}

        -- TODO
        --if string.sub(int.var.id,1,4) == '$fin' then
            --me.lbl_cnt.to_reach = nil
        --end
    end,

    AwaitInt = function (me)
        local int = unpack(me)
        me.lbl_ana = new{'Await_ana_'..me[1][1], acc=int.accs[1]}
        me.lbl_awt = new{'Await_'..me[1][1]}
        me.lbl_awk = new{'Awake_'..me[1][1], to_reach=true,
                        me=me, err='awake of `await´'}
    end,
    AwaitT = function (me)
        if me[1].tag == 'WCLOCKE' then
            me.lbl = new{'Awake_'..me[1][1][1][1], to_reach=true,
                        me=me, err='awake of `await´'}
        else
            me.lbl = new{'Awake_'..me[1].us, to_reach=true,
                        me=me, err='awake of `await´'}
        end
    end,
    AwaitExt = function (me)
        me.lbl = new{'Awake_'..me[1][1], to_reach=true,
                    me=me, err='awake of `await´'}
        _LABELS.gte2lbl[me.gte] = me.lbl.n
    end,
}

_AST.visit(F)

end

    
do
_ANALYSIS = {
    needsTree = true,
    needsChk  = true,
    n_tracks  = _AST.root.n_tracks,
}

if _OPTS.analysis_use then
-----------------------

local _F = dofile(_OPTS.analysis_file)

_ANALYSIS.needsTree  = _PROPS.has_emits or _F.needsChk
_ANALYSIS.needsChk   = _F.needsChk
_ANALYSIS.n_tracks   = _F.n_tracks
_ANALYSIS.n_reachs   = 0
_ANALYSIS.n_unreachs = 0
_ANALYSIS.isForever  = not _F.isReach[_AST.root.lbl_ana.n]
_ANALYSIS.nd_acc     = 0

local N_LABELS = #_LABELS.list

function isConc (l1, l2)
    return _F.isConc[l1.n*N_LABELS+l2.n]
end

-- "needsTree": i/j are concurrent, and have different tree depths
if not _ANALYSIS.needsTree then
    for i=1, N_LABELS do
        local l1 = _LABELS.list[i]
        for j=i+1, N_LABELS do
            local l2 = _LABELS.list[j]
            if isConc(l1,l2) then
                if l1.tree ~= l2.tree then
                    _ANALYSIS.needsTree = true
                    break
                end
            end
        end
        if _ANALYSIS.needsTree then
            break
        end
    end
end

-- "n_reachs" / "n_unreachs"
for _,lbl in ipairs(_LABELS.list) do
    if lbl.to_reach==false and _F.isReach[lbl.n] then
        _ANALYSIS.n_reachs = _ANALYSIS.n_reachs + 1
        WRN(false, lbl.me, lbl.err..' : should not be reachable')
    end
    if lbl.to_reach==true and (not _F.isReach[lbl.n]) then
        _ANALYSIS.n_unreachs = _ANALYSIS.n_unreachs + 1
--DBG(lbl.id)
        WRN(false, lbl.me, lbl.err..' : should be reachable')
    end
end

local ND = {
    cl  = { cl=true, tr=true,  wr=true,  rd=true,  aw=true  },
    tr  = { cl=true, tr=true,  wr=true,  rd=true,  aw=true  },
    wr  = { cl=true, tr=true,  wr=true,  rd=true,  aw=false },
    rd  = { cl=true, tr=true,  wr=true,  rd=false, aw=false },
    aw  = { cl=true, tr=true,  wr=false, rd=false, aw=false },
    no  = {},   -- never ND ('ref')
}

-- "nd_acc": i/j are concurrent, and have incomp. acc
for i=1, N_LABELS do
    local l1 = _LABELS.list[i]
    for j=i+1, N_LABELS do
        local l2 = _LABELS.list[j]
        if l1.acc and l2.acc then
        if l1.par[l2] and isConc(l1,l2) then
            local id1, md1, tp1, any1, str1 = unpack(l1.acc)
            local id2, md2, tp2, any2, str2 = unpack(l2.acc)
--DBG('===')
--DBG(l1.acc, id1, md1, tp1, any1, str1)
--DBG(l2.acc, id2, md2, tp2, any2, str2)
            local nd  = (id1==id2) or (md1=='cl' and md2=='cl') or
                        (any1 and _TP.contains(tp1,tp2)) or
                        (any2 and _TP.contains(tp2,tp1))
            local c1 = _ENV.c[id1]
            c1 = c1 and (c1.mod=='pure' or c1.mod=='constant')
            local c2 = _ENV.c[id2]
            c2 = c2 and (c2.mod=='pure' or c2.mod=='constant')
            local det = (_ENV.dets[id1] and _ENV.dets[id1][id2])
                      or c1 or c2
--DBG(id1, id2, l1.id, l2.id)
            if nd and (not det) and ND[md1][md2] then
                DBG('WRN : nondeterminism : '..str1..' vs '..str2)
                _ANALYSIS.nd_acc = _ANALYSIS.nd_acc + 1
            end
        end
        end
    end
end

-----------------------
end

end

    
do

opcode={
	op_nop=0,
	op_end=1,
	op_return=2,
	op_sub=3,
	op_add=4,
	op_mod=5,
	op_mult=6,
	op_div=7,
	op_bor=8,
	op_band=9,
	op_lshft=10,
	op_rshft=11,
	op_bxor=12,
	op_eq=13,
	op_neq=14,
	op_gte=15,
	op_lte=16,
	op_gt=17,
	op_lt=18,
	op_lor=19,
	op_land=20,
	op_bnot=21,
	op_lnot=22,
	op_neg=23,
	op_cast=24,
	op_push_c=28,
	op_push_vs=32,
	op_push_vu=36,
	op_pushx_vs=40,
	op_pushx_vu=44,
	op_push_ps=48,
	op_push_pu=52,
	op_pushx_ps=56,
	op_pushx_pu=60,
	op_pusharr_v=68,
	op_pop_s=72,
	op_pop_u=76,
	op_popx_s=80,
	op_popx_u=84,
	op_poparr_v=92,
	op_setarr_vc=96,
	op_setarr_vv=100,
	op_memclr=104,
	op_getextdt_p=108,
	op_getextdt_v=112,
	op_chkret=120,
	op_exec=124,
	op_ifelse=128,
	op_outevt_c=132,
	op_outevt_v=136,
	op_outevtx_c=140,
	op_outevtx_v=144,
	op_outevt_z=148,
	op_tkclr=152,
	op_trg=156,
	op_set_c=160,
	op_set_v=176,
	op_clken_c=192,
	op_clken_v=208,
	op_tkins_max=224,
	op_tkins_z=240,
}

typelen={
u8=0,s8=0, -- 1 byte
U8=0,S8=0, -- 1 byte
u16=1,s16=1, -- 2 bytes
U16=1,S16=1, -- 2 bytes
u32=2,s32=2, -- 4 bytes
U32=2,S32=2, -- 4 bytes
int=2, -- 4 bytes
void=0,
}

sig={
u8='u',s8='s', -- 1 byte
U8='u',S8='s', -- 1 byte
u16='u',s16='s', -- 2 bytes
U16='u',S16='s', -- 2 bytes
u32='u',s32='s', -- 4 bytes
U32='u',S32='s', -- 4 bytes
int='s', -- 4 bytes
void='u',
}
sign={
u8=0,s8=1, -- 1 byte
U8=0,S8=1, -- 1 byte
u16=0,s16=1, -- 2 bytes
U16=0,S16=1, -- 2 bytes
u32=0,s32=1, -- 4 bytes
U32=0,S32=1, -- 4 bytes
int=1, -- 4 bytes
void=0,
}

vartype={
u8=0,s8=4, -- 1 byte
U8=0,S8=4, -- 1 byte
u16=1,s16=5, -- 2 bytes
U16=1,S16=5, -- 2 bytes
u32=2,s32=6, -- 4 bytes
U32=2,S32=6, -- 4 bytes
int=6, -- 4 bytes
}

function OPCODE (me,line,codeA,codeB,n_stack)
	n_stack = n_stack or 0;
	code = code or '--'
	local idx=1
	LINE(me,line,0)
    local offset = table.getn(me.opcode)
	for token in string.gmatch(line, "[^%s]+") do
		me.opcode[offset+idx]=token
		me.n_stack[offset+idx]=n_stack
		n_stack = 0
		idx=idx+1
	end
    spc2 = 30 - string.len(codeA)
    if (spc2 < 0) then spc2 = 2 end
    spc2 = string.rep(' ', spc2)
	me.code2[offset+1] = (codeA or '')..spc2..'| '..(codeB or '') 
end

function BYTECODE(me,codeB,mnemonic,...)
	_OPCODES[mnemonic](me,codeB,arg)
end



 _OPCODES = {

-- Generic opcode functions

 	-- arg={lbl.n}
	lbl = function (me,codeB,arg)
		local bytecode = string.format('L%02x',arg[1])
		local codeA = bytecode
		OPCODE(me,bytecode,codeA,codeB)
	end,

 	-- arg={}
	op1_any = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_'..arg[1]]))
		local codeA = arg[1]
		OPCODE(me,bytecode,codeA,codeB)
	end,

 	-- arg={}
	op2_any = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_'..arg[1]]))
		local codeA = arg[1]
		OPCODE(me,bytecode,codeA,codeB,-1)
	end,

-- Specific opcode functions
 	-- arg={}
	op_nop= function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_nop']))
		local codeA = 'nop'
		OPCODE(me,bytecode,codeA,codeB)
	end, 
	
 	-- arg={}
	op_end = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_end']))
		local codeA = 'end'
		OPCODE(me,bytecode,codeA,codeB)
	end,

 	-- arg={}
	op_return= function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_return']))
		local codeA = 'return'
		OPCODE(me,bytecode,codeA,codeB)
	end, 
	
	-- arg={type}
	op_cast= function (me,codeB,arg)   		
		local bytecode = string.format('%02x',(opcode['op_cast']))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(vartype[arg[1]]*(2^4)))
		local codeA = 'cast '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)
	end, 

	-- arg={ConstValue}
	op_push_c= function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_push_c'])+_TP.getConstLen(arg[1]))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[1]))
		local codeA = 'push_c '..arg[1]
		OPCODE(me,bytecode,codeA,codeB,1)
	end,

	-- arg={type,addr}
	op_push_v= function (me,codeB,arg)
		local bytecode=''
		local codeA = ''
		if (_TP.getConstLen(arg[2]) == 0) then
			bytecode = string.format('%02x',(opcode['op_pushx_v'..(sig[arg[1]] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2]))
			codeA = 'pushx_v'..(sig[arg[1]] or 'u')..' '..arg[1]..' '..arg[2]
		else
			bytecode = string.format('%02x',(opcode['op_push_v'..(sig[arg[1]] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2],2))
			codeA = 'push_v'..(sig[arg[1]] or 'u')..' '..arg[1]..' '..arg[2]
		end
		OPCODE(me,bytecode,codeA,codeB,1)
	end,
	 
	-- arg={type,&addr}
	op_push_p= function (me,codeB,arg) 
		local bytecode=''
		local codeA = ''
		if (_TP.getConstLen(arg[2]) == 0) then
			bytecode = string.format('%02x',(opcode['op_pushx_p'..(sig[_TP.deref(arg[1])] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2]))
			codeA = 'pushx_p'..(sig[_TP.deref(arg[1])] or 'u')..' '..arg[1]..' '..arg[2]
		else
			bytecode = string.format('%02x',(opcode['op_push_p'..(sig[_TP.deref(arg[1])] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2],2))
			codeA = 'push_p'..(sig[_TP.deref(arg[1])] or 'u')..' '..arg[1]..' '..arg[2]
		end
		OPCODE(me,bytecode,codeA,codeB,1)
	end, 
	
	-- arg={var_type,Idx_type,Idx_addr,ArrSize,ArrAddr}
	op_pusharr_v= function (me,codeB,arg)
		local bytecode = string.format('%02x %02x',
			(opcode['op_pusharr_v'])+(typelen[arg[1]] or '0' ),
			((sign[arg[1]] or 0)*(2^7) + _TP.getConstLen(arg[4])*(2^6) + typelen[arg[2]]*(2^4) + _TP.getConstLen(arg[3])*(2^2)) + _TP.getConstLen(arg[4])*(2^0))
		bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[5]),_TP.getConstBytes(arg[3]),_TP.getConstBytes(arg[4]))
		local codeA = 'pusharr_v '..arg[1]..' '..arg[5]..' '..arg[2]..' '..arg[3]..' '..arg[4]
		OPCODE(me,bytecode,codeA,codeB,1)
	end, 

	-- arg={type,addr}
	op_pop= function (me,codeB,arg) 
		local bytecode=''
		local codeA = ''
		if (_TP.getConstLen(arg[2]) == 0) then
			bytecode = string.format('%02x',(opcode['op_popx_'..(sig[arg[1]] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2]))
			codeA = 'popx_'..(sig[arg[1]] or 'u')..' '..arg[1]..' '..arg[2]
		else
			bytecode = string.format('%02x',(opcode['op_pop_'..(sig[arg[1]] or 'u')])+(typelen[arg[1]] or '0' ))
			bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2],2))
			codeA = 'pop_'..(sig[arg[1]] or 'u')..' '..arg[1]..' '..arg[2]
		end
		OPCODE(me,bytecode,codeA,codeB,-1)
	end,
	 
 
	-- arg={var_type,idx_type,idx_addr,ArrSize,ArrAddr}
	op_poparr_v= function (me,codeB,arg) 
		local bytecode = string.format('%02x %02x',
			(opcode['op_poparr_v'])+(typelen[arg[1]] or '0' ),
			(_TP.getConstLen(arg[5])*(2^6) + typelen[arg[2]]*(2^4) + _TP.getConstLen(arg[3])*(2^2) + _TP.getConstLen(arg[4])*(2^0)))
		bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[5]),_TP.getConstBytes(arg[3]),_TP.getConstBytes(arg[4]))
		local codeA = 'poparr_v '..arg[1]..' '..arg[5]..' '..arg[2]..' '..arg[3]..' '..arg[4]
		OPCODE(me,bytecode,codeA,codeB,-1)	
	end, 

	-- arg={arr_type,arr_addr,idx_type,idx_addr,idx_max,const_val}
	op_setarr_vc= function (me,codeB,arg) 
		local bytecode = string.format('%02x %02x',(opcode['op_setarr_vc'])+typelen[arg[1]],
								_TP.getConstLen(arg[2])*2^7+_TP.getConstLen(arg[4])*2^6 + typelen[arg[3]]*2^4 + _TP.getConstLen(arg[5])*2^3 + _TP.getConstLen(arg[6]))
		bytecode = string.format('%s %s %s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[4]),_TP.getConstBytes(arg[5]),_TP.getConstBytes(arg[6]))
		local codeA = 'setarr_vc '..arg[1]..' '..arg[2]..' '..arg[3]..' '..arg[4]..' '..arg[5]
		OPCODE(me,bytecode,codeA,codeB)
	end, 
	
	-- arg={arr_type,arr_addr,idx_type,idx_addr,idx_max,var_type,var_addr}
	op_setarr_vv= function (me,codeB,arg) 
		local bytecode = string.format('%02x %02x',(opcode['op_setarr_vv'])+typelen[arg[1]],
								_TP.getConstLen(arg[2])*2^7+_TP.getConstLen(arg[4])*2^6 + typelen[arg[3]]*2^4 + _TP.getConstLen(arg[5])*2^3 + _TP.getConstLen(arg[7])*2^2 + typelen[arg[6]])
		bytecode = string.format('%s %s %s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[4]),_TP.getConstBytes(arg[5]),_TP.getConstBytes(arg[7]))
		local codeA = 'setarr_vv '..arg[1]..' '..arg[2]..' '..arg[3]..' '..arg[4]..' '..arg[5]..' '..arg[6]..' '..arg[7]
		OPCODE(me,bytecode,codeA,codeB)
	end, 

 	-- arg={len,addr}
	op_memclr = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_memclr']) + _TP.getConstLen(arg[2])*2 + _TP.getConstLen(arg[1]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[1]))
		local codeA = 'memclr '..arg[2]..' '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)
	end,
	
	-- arg={addr,len}
	op_getextdt_p= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_getextdt_p']) + _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]))
		local codeA = 'getextdt_p '..arg[1]..' '..arg[2]
		OPCODE(me,bytecode,codeA,codeB)	
	end, 
	
	-- arg={addr,len}
	op_getextdt_v= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_getextdt_v']) + _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]))
		local codeA = 'getextdt_v '..arg[1]..' '..arg[2]
		OPCODE(me,bytecode,codeA,codeB)		
	end, 

	-- arg={addr}
	op_chkret= function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_chkret'])+(_TP.getConstLen(arg[1])))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[1]))
		local codeA = 'chkret '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)
	end,
	
 	-- arg={lbl.n}
	op_exec = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_exec'])+(_TP.getConstLen(arg[1])))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[1]))
		local codeA = 'exec '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)
	end,
	
 	-- arg={lbl.n,lbl.n}
	op_ifelse= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_ifelse']) + _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]))
		local codeA = 'ifelse '..arg[1]..' '..arg[2]
		OPCODE(me,bytecode,codeA,codeB)			
	end, 
	
	-- arg={evt,data_len,const_val}
	op_outevt_c = function (me,codeB,arg)
		local bytecode=''
		local codeA = ''
		if (_TP.getConstLen(arg[1]) == 0 and _TP.getConstLen(arg[2]) == 0) then
			bytecode = string.format('%02x',(opcode['op_outevtx_c']) +  _TP.getConstLen(arg[3]))
			bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3]))		
			codeA = 'outevtx_c '..arg[1]..' '..arg[2]..' '..arg[3]
		else
			bytecode = string.format('%02x %02x',(opcode['op_outevt_c']) +  _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]),_TP.getConstLen(arg[3])*2^6)
			bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3]))		
			codeA = 'outevt_c '..arg[1]..' '..arg[2]..' '..arg[3]
		end
		OPCODE(me,bytecode,codeA,codeB)			
	end, 

	-- arg={evt,data_len,var_type,var_addr}
	op_outevt_v= function (me,codeB,arg) 
		local bytecode=''
		local codeA = ''
		if (_TP.getConstLen(arg[1]) == 0 and _TP.getConstLen(arg[2]) == 0 and _TP.getConstLen(arg[4]) == 0) then
			bytecode = string.format('%02x',(opcode['op_outevtx_v']) +  (typelen[arg[3]] or 0))
			bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[4]))		
			codeA = 'outevtx_v '..arg[1]..' '..arg[2]..' '..arg[3]..' '..arg[4]
		else
			bytecode = string.format('%02x %02x',(opcode['op_outevt_v']) +  _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]),
							(typelen[arg[3]] or 0)*2^6 + _TP.getConstLen(arg[4])*2^4)
			bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[4]))		
			codeA = 'outevt_v '..arg[1]..' '..arg[2]..' '..arg[3]..' '..arg[4]
		end
		OPCODE(me,bytecode,codeA,codeB)			
	end,
	 
	-- arg={evt}
	op_outevt_z = function (me,codeB,arg)
		local bytecode = string.format('%02x',(opcode['op_outevt_z']) +  _TP.getConstLen(arg[1])*2)
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[1]))		
		local codeA = 'outevt_z '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)			
	end, 

 	-- arg={lbl.n,lbl.n}
	op_tkclr= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_tkclr']) + _TP.getConstLen(arg[1])*2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]))
		local codeA = 'tkclr '..arg[1]..' '..arg[2]
		OPCODE(me,bytecode,codeA,codeB)			
	end, 

 	-- arg={lbl.n}
	op_trg= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_trg'])+(_TP.getConstLen(arg[1])))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[1]))
		local codeA = 'trg '..arg[1]
		OPCODE(me,bytecode,codeA,codeB)	
	end, 
	
	-- arg={var_type,var_addr,const_val}
	op_set_c= function (me,codeB,arg) 
		local p2_len
		local p2_1lenx = 0
		p2_len = 2^typelen[arg[1]]
		if (2^_TP.getConstLen(arg[3]) <= 2^typelen[arg[1]]/2) then p2_1lenx=1 p2_len=p2_len/2 end
		local bytecode = string.format('%02x',(opcode['op_set_c']) +  typelen[arg[1]]*2^2 + _TP.getConstLen(arg[2])*2 + p2_1lenx)
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3],p2_len))		
		local codeA = 'set_c '..arg[1]..' '..arg[2]..' '..arg[3]
		OPCODE(me,bytecode,codeA,codeB)	
	end, 

	-- arg={var_type,var1_addr,var1_addr}	
	op_set_v= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_set_v']) +  typelen[arg[1]]*2^2 + _TP.getConstLen(arg[2])*2 + _TP.getConstLen(arg[3]))
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3]))		
		local codeA = 'set_v '..arg[1]..' '..arg[2]..' '..arg[3]
		OPCODE(me,bytecode,codeA,codeB)		
	end, 

	-- arg={gate,const_time,label}
	op_clken_c= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_clken_c']) +  _TP.getConstLen(arg[1])*2^3 + _TP.getConstLen(arg[3])*2^2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3]))		
		local codeA = 'clken_c '..arg[1]..' '..arg[2]..' '..arg[3]
		OPCODE(me,bytecode,codeA,codeB)		
	end, 

	-- arg={gate,unit, var_type, var_addr,label}
	op_clken_v= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_clken_v']) +  _TP.getConstLen(arg[1])*2^3 + _TP.getConstLen(arg[5])*2^2 + typelen[arg[3]])
		bytecode = string.format('%s %s %s %s %s',bytecode,_TP.getConstBytes(arg[1]),_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[4],2),_TP.getConstBytes(arg[5]))
		local codeA = 'clken_v '..arg[1]..' '..arg[2]..' '..arg[3]..' '..arg[4]..' '..arg[5]
		OPCODE(me,bytecode,codeA,codeB)			
	end,
 
	-- arg={stack,label)
	op_tkins_max= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_tkins_max']) +  arg[1]*2^2 + _TP.getConstLen(arg[2]))
		bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(arg[2]))		
		local codeA = 'tkins_max '..arg[1]..' '..arg[2]
		OPCODE(me,bytecode,codeA,codeB)			
	end, 

	-- arg={chk,tree,label)
	op_tkins_z= function (me,codeB,arg) 
		local bytecode = string.format('%02x',(opcode['op_tkins_z']) +  _TP.getConstLen(arg[2])*2^3 + _TP.getConstLen(arg[3])*2^2 + arg[1])
		bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(arg[2]),_TP.getConstBytes(arg[3]))		
		local codeA = 'tkins_z '..arg[1]..' '..arg[2]..' '..arg[3]
		OPCODE(me,bytecode,codeA,codeB)				
	end, 

}



end

    
do

_CODE = {
    labels = { 'Inactive', 'Init' },
    host   = '',
}



function CONC_ALL (me)
    for _, sub in ipairs(me) do
--DBG('@ ',(sub.tag or '-'))
        if _AST.isNode(sub) then
--DBG('- '.._AST.isNode(sub))
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
    CONC_OP(me,sub)
end

function CONC_OP (me, sub)
    sub = sub or me[1]
    local offset = table.getn(me.opcode)
    for idxb,value in ipairs(sub.opcode) do
    	me.opcode[offset+idxb] = value
    	me.code2[offset+idxb] = sub.code2[idxb]
    	me.n_stack[offset+idxb] = sub.n_stack[idxb]
    end
end

function ATTR (me, n1, n2)
    if not _OPTS.analysis_run then
        LINE(me,'//> '..n1.val..' = '..n2.val..';')
        LINE(me,n2.code..' // TODO ? pop_'..n1.tp..n1.code..';')
    end
end

function EXP (me, e)
    if _OPTS.analysis_run and e.accs then
        for _, acc in ipairs(e.accs) do
            SWITCH(me, acc.lbl_ana)
            CASE(me, acc.lbl_ana)
        end
    end
end

function CASE (me, lbl)
    --LINE(me, '//> case '..lbl.id..':', 0)
    codeB = LINE(me, lbl.id..':', 0)
    BYTECODE(me,codeB,'lbl',lbl.n)
end

function LINE (me, line, spc,comment)
    spc = spc or 4
    spc = string.rep(' ', spc)
    spc2 = 30 - string.len(line) - string.len(spc)
    if (spc2 < 0) then spc2 = 2 end
    spc2 = string.rep(' ', spc2)
    me.code = me.code .. spc .. line .. spc2 .. (comment or '') .. '\n'
	return line
end

function HALT (me)
    --LINE(me, '//> break;')
    codeB = LINE(me, 'end')
    BYTECODE(me,codeB,'op_end')
end

function SWITCH (me, lbl)
--    LINE(me, [[
--//> _lbl_ = ]]..lbl.id..[[;
--//> goto _SWITCH_;
--]])
    codeB = LINE(me,'goto '.._TP.getConstType(lbl.n)..' '..lbl.n, nil,'// goto '..lbl.id)
    BYTECODE(me,codeB,'op_exec',lbl.n)
end

function COMM (me, comm)
    LINE(me, '// /* '..comm..' */', 0)
end

function BLOCK_GATES (me)
    -- TODO: test if out is reachable, test if has inner parallel
    -- in both cases, no need to run anything

    CASE(me, me.lbl_out)
--    COMM(me, 'close gates')

    -- do not resume inner ASYNCS
    local n = me.gtes.asyncs[2] - me.gtes.asyncs[1]
    if n > 0 then
--        LINE(me, '//> memset(PTR(char*,CEU_ASYNC0) + '
--                    ..me.gtes.asyncs[1]..'*sizeof(tceu_nlbl), 0, '
--                    ..n..'*sizeof(tceu_nlbl));')
        codeB = LINE(me, 'clear asyncs gates from '..me.gtes.asyncs[1]..' to '..me.gtes.asyncs[2],nil,'// close gates') 
        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len, CEU_ASYNC0 +me.gtes.asyncs[1]*_ENV.c.tceu_nlbl.len)
    end

    -- do not resume inner WCLOCKS
    local n = me.gtes.wclocks[2] - me.gtes.wclocks[1]
    if n > 0 then
--        LINE(me, '//> memset(PTR(char*,CEU_WCLOCK0) + '
--                    ..me.gtes.wclocks[1]..'*sizeof(tceu_wclock), 0, '
--                    ..n..'*sizeof(tceu_wclock));')
        codeB = LINE(me, 'clear WClocks gates from '..me.gtes.wclocks[1]..' to '..me.gtes.wclocks[2],nil,'// close gates') 
        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_wclock.len, _MEM.gtes.wclock0 + me.gtes.wclocks[1]*_ENV.c.tceu_wclock.len)
    end

    -- stop awaiting inner EXTS
    for _, ext in ipairs(_ENV.exts) do
        local t = me.gtes[ext]
        if t then
            local n = t[2] - t[1]
            if n > 0 then
--                LINE(me, '//> memset(PTR_EXT(IN_'..ext.id..','..t[1]..'), 0, '
--                    ..n..'*sizeof(tceu_nlbl));')
		        codeB = LINE(me, 'clear EXT gates for '..ext.id,nil,'// stop awaiting inner externals') 
		        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len, _MEM.gtes[ext.n]+1)
            end
        end
    end

    -- stop awaiting inner internal events
    for blk in _AST.iter'Block' do
        for _, var in ipairs(blk.vars) do
            if me.gtes[var] then
                local t = me.gtes[var]
                local n = t[2] - t[1]
                if n > 0 then
--                    LINE(me, '//> memset(CEU->mem+'..var.awt0..'+1+'
--                            ..t[1]..'*sizeof(tceu_nlbl), 0, '
--                            ..n..'*sizeof(tceu_nlbl));')
			        codeB = LINE(me, 'clear Internal gates for '..var.id,nil,'// stop awaiting inner intenals') 
					BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len, var.awt0 + 1 + t[1] * _ENV.c.tceu_nlbl.len)
                end
            end
        end
    end

    -- do not resume inner EMITS continuations (await/emit)
    -- TODO: check if needed
    if _PROPS.has_emits then
--        LINE(me, '//> ceu_track_clr('..me.lbls_emt[1]..','..me.lbls_emt[2]..');')
        codeB = LINE(me, 'clear tracks from label '..me.lbls_emt[1]..' to label '..me.lbls_emt[2],nil,'// do not resume inner EMITS continuations (await/emit)') 
		BYTECODE(me,codeB,'op_tkclr',me.lbls_emt[1],me.lbls_emt[2])
    end
end

function PAUSE (me, N, PTR)
    if me.more then
        LINE(me, [[
{ int i;
for (i=0; i<]]..N..[[; i++) {
    if (]]..PTR..'['..i..']'..[[ >= Init) {
        ]]..PTR..'['..i..']'..[[ = Init-1;
    } else {
        ]]..PTR..'['..i..']'..[[--;
    }
} }
]])
    else
        LINE(me, [[
{ int i;
for (i=0; i<]]..N..[[; i++) {
    if (]]..PTR..'['..i..']'..[[ >= Init) {
        ]]..PTR..'['..i..']'..[[ = Init-1;
    } else {
        ]]..PTR..'['..i..']'..[[--;
    }
} }
]])
    end
end

function Op1_any(me,mnemonic)
        local op, e1 = unpack(me)
		CONC(me,e1)
       	codeB = LINE(me,mnemonic,nil,'// stack0 = '..mnemonic..'(stack0)')
       	BYTECODE(me,codeB,'op1_any',mnemonic)
end

function Op2_any(me,mnemonic)
    local op, e1, e2 = unpack(me)
	CONC(me,me[3])
	CONC(me,me[2])
	codeB = LINE(me,mnemonic,nil,'// stack0 = stack0 '..mnemonic..' stack1')
   	BYTECODE(me,codeB,'op2_any',mnemonic)
end

function INC_STACK()
	_AST.root.n_stack=_AST.root.n_stack+1;
	_AST.root.max_stack = math.max(_AST.root.max_stack,_AST.root.n_stack)
print('inc stack=',_AST.root.max_stack,_AST.root.n_stack)
end
function DEC_STACK()
	_AST.root.n_stack=_AST.root.n_stack-1;
end
function CLR_STACK()
	_AST.root.n_stack=0;
end

F = {
    Node_pre = function (me)
        me.code = ''
        me.code2 = {}
        me.opcode={}
        me.n_stack={}
    end,

    Root = function (me)
--        LINE(me, '//> memset(CEU->mem, 0, '.._MEM.gtes.loc0..');')
--		LINE(me, 'main:',0,'// program main entry ')
		codeB = LINE(me, 'init_1:',0,'// program main entry ')
		local bytecode = string.format('L%04x',1)
		OPCODE(me,bytecode,codeB)
        codeB = LINE(me, 'clear all gates',nil,'// Clear the gates ') 
		BYTECODE(me,codeB,'op_memclr', _MEM.gtes.loc0, 0)
        for _,ext in ipairs(_ENV.exts) do
            if ((ext.pre == 'input') and ((_ENV.awaits[ext] or 0) >0)) then  -- save code to write 0
--                LINE(me, '//> *PTR(u8*,IN_'..ext.id..') = '
--                            ..(_ENV.awaits[ext] or 0)..';')
                codeB = LINE(me, 'config gate '..ext.id..' with '..(_ENV.awaits[ext] or 0)..' await(s)',nil,
                		'// Config gate')
				BYTECODE(me,codeB,'op_set_c','u8',_MEM.gtes[ext.n],(_ENV.awaits[ext] or 0))
            end
        end

        CONC_ALL(me)

        if _OPTS.analysis_run then
            SWITCH(me, me.lbl_ana)
            CASE(me, me.lbl_ana)
        end

        if not (_OPTS.analysis_use and _ANALYSIS.isForever) then
            local ret = _AST.root[1].vars[1]    -- $ret
--afb            LINE(me, 'if (ret) *ret = '..ret.val..';')
            codeB = LINE(me, 'return',nil,'// return 1; ')
            BYTECODE(me,codeB,'op_return')
        end
        HALT(me)
    end,

    Host = function (me)
        _CODE.host = _CODE.host .. me[1] .. '\n'
    end,

    SetExp = function (me)
        local e1, e2 = unpack(me)
--DBG('.......... <|'..e1.val..'|'..e2.val..'|> ')
--DBG('.......... <|'..e1.code..'|'..e2.code..'|> ')
--        COMM(me, 'SET: '..tostring(e1[1]))    -- Var or C
        EXP(me, e2)
        EXP(me, e1)
        --ATTR(me, e1, e2)
		--COMM(me,'e2-tag:'..e2[1].tag)
        x1={} x1.tp = e1.tp x1.val = e1.val
        if (_TP.deref(e1.tp)) then x1.tp='u16' end
        if (e2[1].tag=='CONST' or e2[1].tag=='Var') then
        	x2={} x2.tp = e2.tp x2.val = e2.val
        	if (_TP.deref(e2.tp)) then x2.tp=_TP.getConstType(e2.fst.off) x2.val=e2.fst.off end
        	
        	if (e1.fst.arr) then
		        idx={} idx.tp = e1[1][3].tp idx.tag = e1[1][3].tag idx.val = e1[1][3].val idx.max = e1.fst.arr
				if (e2[1].tag=='CONST') then
					if (idx.tag == 'CONST') then
--afb					codeB = LINE(me,'setarr_cc '..x1.tp..' '..x1.val..' '..x2.tp..' '..x2.val,nil,'// SetExp:: '.. e1.fst.id ..' '..e1[1][3].val ..'='.. e2[1][1] ..' | set array <type> <base addr> <idx> <arr size> <value>')
--						BYTECODE(me,codeB,'op_setarr_cc',x1.tp,x1.val,idx.val,idx.max,x2.val)
						-- it uses 'set_c' for constant index
						codeB = LINE(me,''..e1.fst.id..'['..idx.val..'] = '..x2.val,nil,'// set array[idx] with constant')        
						BYTECODE(me,codeB,'op_set_c',x1.tp,x1.val+(idx.val*_ENV.c[x1.tp].len),x2.val)
					else
--						codeB = LINE(me,'setarr_vc '..x1.tp..' '..x1.val..' '..x2.tp..' '..x2.val,nil,'// SetExp:: '.. e1.fst.id ..' ['..e1[1][3].val ..']='.. e2[1][1] ..' | set array <type> <base addr> <idx> <arr size> <value>')
						codeB = LINE(me,''..e1.fst.id..'['..e1[1][3][1]..'] = '..x2.val,nil,'// set array[var] with constant')        
						BYTECODE(me,codeB,'op_setarr_vc',x1.tp,x1.val,idx.tp,idx.val,idx.max,x2.val)
					end
				else
					if (e1[1][3].tag == 'CONST') then
--afb					codeB = LINE(me,'setarr_cv '..x1.tp..' '..x1.val..' '..x2.tp..' '..x2.val,nil,'// SetExp:: '.. e1.fst.id ..' '..e1[1][3].val ..'='.. e2[1][1] ..' | set array <type> <base addr> <idx> <arr size> <value>')
--						BYTECODE(me,codeB,'op_setarr_cv',x1.tp,x1.val,idx.val,idx.max,x2.tp,x2.val)
						-- it uses 'set_v' for constant index
						codeB = LINE(me,''..e1.fst.id..'['..idx.val..'] = '..e2[1][1],nil,'// set array[idx] with var')        
						BYTECODE(me,codeB,'op_set_v',x1.tp,x1.val+(idx.val*_ENV.c[x1.tp].len),x2.val)
					else
						codeB = LINE(me,''..e1.fst.id..'['..e1[1][3][1]..'] = '..e2[1][1],nil,'// set array[var] with var')        
						BYTECODE(me,codeB,'op_setarr_vv',x1.tp,x1.val,idx.tp,idx.val,idx.max,x2.tp,x2.val)
					end
				end
			else
				if (e2[1].tag=='CONST') then
					if (typelen[x1.tp] >= typelen[x2.tp]) then
						codeB = LINE(me,e1.fst.id ..' = '.. e2[1][1],nil,'// SetExp:: set var=const' )        
						BYTECODE(me,codeB,'op_set_c',x1.tp,x1.val,x2.val)
					else
						CONC(me,e2)
						codeB = LINE(me,'pop '..e1.fst.id,nil,'// SetExp:: pop to var')
						BYTECODE(me,codeB,'op_pop',x1.tp,x1.val)	
					end
				else
					if (typelen[x1.tp] == typelen[x2.tp]) then
						codeB = LINE(me,e1.fst.id ..'='.. e2[1][1],nil,'// SetExp:: set var=var')        
						BYTECODE(me,codeB,'op_set_v',x1.tp,x1.val,x2.val)
					else
						CONC(me,e2)
						codeB = LINE(me,'pop '..e1.fst.id,nil,'// SetExp:: pop to var')					
						BYTECODE(me,codeB,'op_pop',x1.tp,x1.val)	
					end
				end
			end
        else
        	if (e1.fst.arr) then
				CONC(me,me[2])
		        idx={} idx.tp = e1[1][3].tp idx.tag = e1[1][3].tag idx.val = e1[1][3].val idx.max = e1.fst.arr
				if (idx.tag=='CONST') then
--afb				codeB = LINE(me,'poparr_c '..x1.tp..' '..x1.val..' '..idx.tp..' '..idx.val..' '..idx.max,nil,'// SetExp:: '..e1.fst.id..'[?] | pop array <type> <base addr> <idx> <array size>')
--					BYTECODE(me,codeB,'op_poparr_c',x1.tp,idx.val,idx.max,x1.val)
					-- it uses 'pop' for constant index
					codeB = LINE(me,'pop '..e1.fst.id..'['..idx.val..']',nil,'// pop to var[idx]')
					BYTECODE(me,codeB,'op_pop',x1.tp,x1.val+(idx.val*_ENV.c[x1.tp].len))	
				else
					codeB = LINE(me,'pop '..e1.fst.id..'[ '..e1[1][3][1]..']',nil,'// pop to var[var]')
					BYTECODE(me,codeB,'op_poparr_v',x1.tp,idx.tp,idx.val,idx.max,x1.val)
				end
			else
				CONC(me,me[2])
				if (_TP.deref(e1.tp)) then
					codeB = LINE(me,'pop *'..e1.fst.id,nil,'// SetExp:: pop to pointer')
					BYTECODE(me,codeB,'op_pop','u16',x1.val)	
				else
					codeB = LINE(me,'pop '..e1.fst.id,nil,'// SetExp:: pop to var')
					BYTECODE(me,codeB,'op_pop',x1.tp,x1.val)	
				end
			end
		end
    end,

    SetAwait = function (me)
        local e1, e2 = unpack(me)
        CONC(me, e2)
        --ATTR(me, e1, e2.ret)
        if _TP.deref(e1.tp) then
        codeB = LINE(me,'get Ext Data *'..e1[1][1]..' '..(_ENV.c[_TP.deref(e1.tp)].len),nil,'// getExtDtp <localVar pointer> <len>')
		BYTECODE(me,codeB,'op_getextdt_p',e1.val,_ENV.c[_TP.deref(e1.tp)].len)
        else
        codeB = LINE(me,'get Ext Data '..e1[1][1]..' '.._ENV.c[e1.tp].len,nil,'// getExtDt <localVarAddr> <len>')
		BYTECODE(me,codeB,'op_getextdt_v',e1.val,_ENV.c[e1.tp].len)
        end

--afb
--        LINE(me,'memcpy '.. e1.val ..' '..e2.ret.val..' '.. _ENV.c[_TP.deref(e1.tp)].len)	    
	        
        EXP(me, e1)     -- after awaking
    end,

    SetBlock = function (me)
        local _,blk = unpack(me)
        CONC(me, blk)
        if _OPTS.analysis_run then
            SWITCH(me, me.lbl_ana_no)
            CASE(me, me.lbl_ana_no)
        end
        HALT(me)        -- must escape with `return´
        BLOCK_GATES(me)
    end,
    Return = function (me)
        local top = _AST.iter'SetBlock'()
--        LINE(me, '//> ceu_track_ins(CEU->stack,' ..top.lbl_out.tree..', 1,'
--                    ..top.lbl_out.id..');')
        codeB = LINE(me, 'insert track '.. top.lbl_out.id ,nil,'// Return to '..top.lbl_out.id)
		BYTECODE(me,codeB,'op_tkins_z',1,top.lbl_out.tree,top.lbl_out.n)
        HALT(me)
    end,

    Block = function (me)
        for _, var in ipairs(me.vars) do
            if var.isEvt then
--                LINE(me, '//> *PTR(u8*,'..var.awt0..') = '..var.n_awaits..';')  -- #gtes
                codeB = LINE(me, 'event '..var.id..' = '..var.n_awaits..' gates',nil,'// set event ')
				BYTECODE(me,codeB,'op_set_c','u8',var.awt0,var.n_awaits)
--                LINE(me, '//> memset(CEU->mem+'..var.awt0..'+1, 0, '   -- gtes[i]=0
--                        ..(var.n_awaits*_ENV.c.tceu_nlbl.len)..');')
				codeB = LINE(me, 'clear '.. var.id ..' '..var.n_awaits..' wait(s) ',nil,'// clear event waits') 
				BYTECODE(me,codeB,'op_memclr', var.n_awaits*_ENV.c.tceu_nlbl.len, var.awt0+1)
            end
        end
        CONC_ALL(me)
    end,

    BlockN  = CONC_ALL,
    Finally = CONC,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        for i, sub in ipairs(me) do
--            LINE(me, '//> ceu_track_ins(CEU->stack, CEU_TREE_MAX, 0, '
--                        ..me.lbls_in[i].id ..');')
	        codeB = LINE(me, 'insert track '.. me.lbls_in[i].id ,nil,'// insert track (Par)')
			BYTECODE(me,codeB,'op_tkins_max',0,me.lbls_in[i].n)
        end
        HALT(me)
    end,


    ParEver = function (me)
        -- behave as ParAnd, but halt on termination (TODO: +ROM)
        if _OPTS.analysis_run then
            F.ParAnd(me)
            SWITCH(me, me.lbl_ana_no)
            CASE(me, me.lbl_ana_no)
            HALT(me)
            return
        end

        F._Par(me)
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
            HALT(me)
        end
    end,

    ParOr = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
--            COMM(me, 'PAROR JOIN')
--            LINE(me, '//> ceu_track_ins(CEU->stack,' .. 255 ..', 1,'
--                        ..me.lbl_out.id..');')
	        codeB = LINE(me, 'insert track '.. me.lbl_out.id,nil,'// Insert track (ParOr)')
			BYTECODE(me,codeB,'op_tkins_max',0,me.lbl_out.n)
            HALT(me)
        end
        BLOCK_GATES(me)
    end,

    ParAnd = function (me)
        -- close AND gates
--        LINE(me, '//> memset(PTR(char*,'..me.off..'), 0, '..#me..');')
		codeB = LINE(me, 'clear gates from addr '.. me.off ..' to addr '..me.off+#me-1,nil,'// close gates (ParAnd)') 
		BYTECODE(me,codeB,'op_memclr', #me, me.off)

        F._Par(me)

        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
--            LINE(me, '//> *PTR(u8*,'..(me.off+i-1)..') = 1; // open and')  -- open gate
            codeB = LINE(me, 'open gate '..i,nil,'// open gate (ParAnd)') 
			BYTECODE(me,codeB,'op_set_c','u8',(me.off+i-1),1)

            SWITCH(me, me.lbl_tst)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
--afb             LINE(me, 'if (! *PTR(u8*,'..(me.off+i-1)..'))')
			codeB = LINE(me,'if (gate '..(i-1)..' == 0) PC=PC+1',nil,'')
			BYTECODE(me,codeB,'op_chkret', (me.off+i-1))
            HALT(me)
        end

        if _OPTS.analysis_run then
            SWITCH(me, me.lbl_ana_out)
            CASE(me, me.lbl_ana_out)
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)
        if _OPTS.analysis_run then
--afb            EXP(me, c)
--afb            local id = (me.lbl_f and me.lbl_f.id) or me.lbl_e.id
--afb            LINE(me, [[
--afb CEU_ANA_PRE(1);
--afb ceu_track_ins(CEU->stack, CEU_TREE_MAX, 0, ]]..id..[[);
--afb CEU_ANA_POS();
--afb ]])
--afb            SWITCH(me, me.lbl_t);
        else
--afb            LINE(me, [[if (]]..c.val..[[) {]])
--afb            SWITCH(me, me.lbl_t)
--afb
--afb            LINE(me, [[} else {]])
--afb            if me.lbl_f then
--afb                SWITCH(me, me.lbl_f)
--afb            else
--afb                SWITCH(me, me.lbl_e)
--afb            end
--afb            LINE(me, [[}]])

--			LINE(me,'exp_u8 '..c.val)
			CONC(me,c)
			if me.lbl_f then
				codeB = LINE(me, 'ifelse '..me.lbl_t.id..' '..me.lbl_f.id,nil,'// ifelse ')
				BYTECODE(me,codeB,'op_ifelse',me.lbl_t.n,me.lbl_f.n)
			else
				codeB = LINE(me, 'ifelse '..me.lbl_t.id..' '..me.lbl_e.id,nil,'// ifelse')			
				BYTECODE(me,codeB,'op_ifelse',me.lbl_t.n,me.lbl_e.n)
			end
        end

        CASE(me, me.lbl_t)
        CONC(me, t, 4)
        SWITCH(me, me.lbl_e)

        if me.lbl_f then
            CASE(me, me.lbl_f)
            CONC(me, f, 4)
            SWITCH(me, me.lbl_e)
        end
        CASE(me, me.lbl_e)
    end,

    Async_pos = function (me)
    	ASR(false,me,'"Async" is not implemented')
--[[
        local vars,blk = unpack(me)
        for _, n in ipairs(vars) do
            ATTR(me, n.new, n[1].var)
            EXP(me, n)
        end
        LINE(me, 'ceu_async_enable('..me.gte..', '..me.lbl.id..');')
        HALT(me)
        CASE(me, me.lbl)
        if _OPTS.analysis_run then
            -- skip `blk´ on analysis
            local set = _AST.iter()()       -- requires `Async_pos´
            if set.tag == 'SetBlock' then
                SWITCH(me, set.lbl_out)
            end
        else
            CONC(me, blk)
        end
--]]
    end,

    Loop = function (me)
        local body = unpack(me)

--        COMM(me, 'Loop ($0):')
        CASE(me, me.lbl_ini)
        CONC(me, body)

        if _OPTS.analysis_run then         -- verifies the loop "loops"
            SWITCH(me, me.lbl_ana_mid)
            CASE(me, me.lbl_ana_mid)
        end

        local async = _AST.iter'Async'()
        if async then
            LINE(me, [[
#ifdef ceu_out_pending
if (ceu_out_pending()) {
#else
{
#endif
    ceu_async_enable(]]..async.gte..', '..me.lbl_ini.id..[[);
    break;
}
]])
        end

        -- a single iter is enough on analysis a tight loop
        if (not _OPTS.analysis_run) or me.blocks then
            SWITCH(me, me.lbl_ini)
        end

        BLOCK_GATES(me)
    end,

    Break = function (me)
        local top = _AST.iter'Loop'()
--        LINE(me, '//> ceu_track_ins(CEU->stack,' ..top.lbl_out.tree..', 1,'
--                    ..top.lbl_out.id..');')
        codeB = LINE(me, 'insert track '.. top.lbl_out.id,nil,'// Break:: ')
		BYTECODE(me,codeB,'op_tkins_z',1,top.lbl_out.tree,top.lbl_out.n)
        HALT(me)
    end,

    Pause = function (me)
        local exp, blk = unpack(me)
        CONC(me,blk)
    end,

    CallStmt = function (me)
        local call = unpack(me)
        EXP(me, call)
        if not _OPTS.analysis_run then
            LINE(me, call.val..';')
        end
    end,

    EmitExtS = function (me)
        local e1, e2 = unpack(me)
        local ext = e1.ext
        if ext.pre == 'output' then  -- e1 not Exp
--printTable(e2[1])
			if (e2) then 
				ASR((e2[1].tag == 'CONST' or e2[1].tag == 'Var'),me,'cannot use expressions in "emit <event>(value);". ')
			end
            if _OPTS.analysis_run then
                if e2 then
                    EXP(me, e2)
                end
                SWITCH(me, me.lbl_ana_emt)
                CASE(me, me.lbl_ana_emt)
            else
--afb                LINE(me, me.val..';')
				if (e2) then
				-- get event type data len
					local par_len,par_tp
					par_tp = _TP.deref(_TP.deref(e2[1].tp) or '') or _TP.deref(e2[1].tp) or e2[1].tp
					if (_ENV.c[par_tp]) then par_len = _ENV.c[par_tp].len else par_len=0  end
					if(e2[1].tag=='CONST') then
						codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' const='..e2[1].val,nil,'// EmitExtS:: const ')
						BYTECODE(me,codeB,'op_outevt_c',e1.ext.seq,par_len,e2[1].val)
					else
						codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' var='..e2[1][1],nil,'// EmitExtS:: var')
						BYTECODE(me,codeB,'op_outevt_v',e1.ext.seq,par_len,e2[1].tp,e2[1].val)
					end
				else
					codeB = LINE(me,'emit '..e1.ext.id ,nil,'// EmitExtS:: void ')
					BYTECODE(me,codeB,'op_outevt_z',e1.ext.seq)
				end
            end
            return 
        end

        assert(ext.pre == 'input')
        local async = _AST.iter'Async'()
        LINE(me, 'ceu_async_enable('..async.gte..', '..me.lbl_cnt.id..');')
        if e2 and (not _OPTS.analysis_run) then
            if _TP.deref(ext.tp) then
                LINE(me, 'return ceu_go_event(ret, IN_'..ext.id
                        ..', (void*)'..e2.val..');')
            else
                LINE(me, 'return ceu_go_event(ret, IN_'..ext.id
                        ..', (void*)ceu_ext_f('..e2.val..'));')
            end

        else
            LINE(me, 'return ceu_go_event(ret, IN_'..ext.id ..', NULL);')
        end
        CASE(me, me.lbl_cnt)
    end,

    EmitT = function (me)
    	ASR(false,me,'"EmitT" is not implemented.')

--        local exp = unpack(me)
--        local async = _AST.iter'Async'()
--        EXP(me, exp)
--        LINE(me, [[
--ceu_async_enable(]]..async.gte..', '..me.lbl_cnt.id..[[);
--#ifdef CEU_WCLOCKS
--{ s32 nxt;
--  int s = ceu_go_wclock(ret,]]..exp.val..[[, &nxt);
--  while (!s && nxt<=0)
--      s = ceu_go_wclock(ret, 0, &nxt);
--  return s;
--}
--#else
--return 0;
--#endif
--]])
 --       CASE(me, me.lbl_cnt)
    end,

    EmitInt = function (me)
        local int, exp = unpack(me)
--        COMM(me, 'emit '..int.var.id)

        -- attribution
        if exp then
--afb  		ATTR(me, int, exp)
			if (exp[1].tag == "CONST") then
				if (typelen[int.tp] >= typelen[exp.tp]) then
		       		codeB = LINE(me,'emit '..int.var.id..'('..exp.val..')',nil,'// EmitInt:: Const')
					BYTECODE(me,codeB,'op_set_c',int.tp,int.val,exp.val)
				else
					CONC(me,exp)
					codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')					
					BYTECODE(me,codeB,'op_pop',int.tp,int.val)	
				end
			else
				if (typelen[int.tp] == typelen[exp.tp]) then
		       		codeB = LINE(me,'emit '..int.var.id..'('..exp[1][1]..')',nil,'// EmitInt:: Var')
					BYTECODE(me,codeB,'op_set_v',int.tp,int.val,exp.val)
				else
					CONC(me,exp)
					codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')					
					BYTECODE(me,codeB,'op_pop',int.tp,int.val)	
				end
			end
        end

        -- emit vs await
        if _OPTS.analysis_run then -- int not Exp
            if exp then
                EXP(me, exp)
            end
            SWITCH(me, me.lbl_ana_emt)
            CASE(me, me.lbl_ana_emt)
        end

        -- defer match: reaction must have a higher stack depth
--        LINE(me, '//> ceu_track_ins(CEU->stack+2, CEU_TREE_MAX, 0,'
--                    ..me.lbl_mch.id..');')
	    codeB = LINE(me, 'insert track '.. me.lbl_mch.id,nil,'// EmitInt:: defer match')
		BYTECODE(me,codeB,'op_tkins_max',2,me.lbl_mch.n)
        -- defer continuation: all trails must react before I resume
--        LINE(me, '//> ceu_track_ins(CEU->stack+1, CEU_TREE_MAX, 0,'
--                    ..me.lbl_cnt.id..');')
	    codeB = LINE(me, 'insert track '.. me.lbl_cnt.id,nil,'// EmitInt:: defer continuation')
		BYTECODE(me,codeB,'op_tkins_max',1,me.lbl_cnt.n)
        HALT(me)

        -- emit
        CASE(me, me.lbl_mch)
--        LINE(me, '//> ceu_trigger('..int.var.awt0..');')
        codeB = LINE(me, 'trigger '..int.var.id,nil,'// EmitInt:: trigger')
		BYTECODE(me,codeB,'op_trg',int.var.awt0)
		
        HALT(me)

        -- continuation
        CASE(me, me.lbl_cnt)
        SWITCH(me, me.lbl_ana_cnt)
        CASE(me, me.lbl_ana_cnt)
    end,

    AwaitInt = function (me)
        local int, zero = unpack(me)
    --    COMM(me, 'emit '..int.var.id)

        -- emit vs await
        if _OPTS.analysis_run then -- int not Exp
            SWITCH(me, me.lbl_ana)
            CASE(me, me.lbl_ana)
        end

        -- defer await: can only react once (0=defer_to_end_of_reaction)
        if not zero then
--            LINE(me, '//> ceu_track_ins(0, CEU_TREE_MAX, 0,'
--                        ..me.lbl_awt.id..');')
		    codeB = LINE(me, 'insert track '.. me.lbl_awt.id,nil,'// AwaitInt:: defer await')
			BYTECODE(me,codeB,'op_tkins_max',0,me.lbl_awt.n)
            HALT(me)
        end

        -- await
        CASE(me, me.lbl_awt)
--        LINE(me, '//> *PTR(tceu_nlbl*,'
--                    ..(int.var.awt0+1+me.gte*_ENV.c.tceu_nlbl.len)
--                    ..') = '..me.lbl_awk.id..';')
        codeB = LINE(me, 'await '..me.lbl_awk.id,nil,'// AwaitInt:: wait')
		BYTECODE(me,codeB,'op_set_c','u16',(int.var.awt0+1+me.gte*_ENV.c.tceu_nlbl.len),me.lbl_awk.n)

        HALT(me)

        -- awake
        CASE(me, me.lbl_awk)
    end,

    AwaitN = function (me)
--        COMM(me, 'Never')
        HALT(me)
    end,
    AwaitT = function (me)
        local exp = unpack(me)
        CONC(me, exp)
        local val = exp.val
        if _OPTS.analysis_run and
            (exp.tag=='WCLOCKE' or exp.tag=='WCLOCKR') then
            val = 'CEU_WCLOCK_ANY'
        end
--        LINE(me, '//> ceu_wclock_enable('..me.gte..', '..val
--                    ..', '..me.lbl.id..');')
--        LINE(me, 'clken '.._TP.getConstType(me.gte)..' '..me.gte..' '.._TP.getConstType(val)..' '..val..' '.._TP.getConstType(me.lbl.n)..' '..me.lbl.n,nil,'// AwaitT '..me.lbl.id)


		if (exp.tag=='WCLOCKK') then
        	codeB = LINE(me, 'clock enable '..me.lbl.id..' '..exp.ms..'msec',nil,'// AwaitT ')
			BYTECODE(me,codeB,'op_clken_c',me.gte,exp.ms,me.lbl.n)
		else
			if (exp[1][1].tag=='Var') then
	        	codeB = LINE(me, 'clock enable '..me.lbl.id..' '..exp[1].val..exp[2],nil,'// AwaitT ')
				BYTECODE(me,codeB,'op_clken_v',me.gte,_MEM.t2idx[exp[2]],exp[1].tp,exp[1].val,me.lbl.n)
			else
				ASR(false,me,'cannot use expressions in "await". ')
			end
		end
        HALT(me)
        CASE(me, me.lbl)
    end,
    AwaitExt = function (me)
        local e1,_ = unpack(me)
--        LINE(me, '//> *PTR_EXT(IN_'..e1.ext.id..','..me.gte..') = '..me.lbl.id..';')
        codeB = LINE(me, 'await '..e1.ext.id..'['..me.gte..']',nil,'// AwaitExt:: ')
		BYTECODE(me,codeB,'op_set_c','u16',(_MEM.gtes[e1.ext.n]+1+(me.gte*2)),me.lbl.n)

        HALT(me) 
        CASE(me, me.lbl)
    end,
    Op2_call = function (me)
        local _, f, exps = unpack(me)
        ASR(false,me,'"call" is not implemented! ')

    end,
    ['Op2_-'] = function (me) Op2_any(me,'sub') end,  
    ['Op2_+'] = function (me) Op2_any(me,'add') end,  
    ['Op2_%']   = function (me) Op2_any(me,'mod') end,
    ['Op2_*']   = function (me) Op2_any(me,'mult') end,
    ['Op2_/']   = function (me) Op2_any(me,'div') end,
    ['Op2_|']   = function (me) Op2_any(me,'bor') end,
    ['Op2_&']   = function (me) Op2_any(me,'band') end,
    ['Op2_<<']  = function (me) Op2_any(me,'lshft') end,
    ['Op2_>>']  = function (me) Op2_any(me,'rsfth') end,
    ['Op2_^']   = function (me) Op2_any(me,'bxor') end,
    ['Op2_==']  = function (me) Op2_any(me,'eq') end,
    ['Op2_!=']  = function (me) Op2_any(me,'neq') end,
    ['Op2_>=']  = function (me) Op2_any(me,'gte') end,
    ['Op2_<=']  = function (me) Op2_any(me,'lte') end,
    ['Op2_>']   = function (me) Op2_any(me,'gt') end,
    ['Op2_<']   = function (me) Op2_any(me,'lt') end,
    ['Op2_or']  = function (me) Op2_any(me,'lor') end,
    ['Op2_and'] = function (me) Op2_any(me,'land') end,
    
    ['Op1_~']   = function (me) Op1_any(me,'bnot') end,
    ['Op1_-']   = function (me) Op1_any(me,'neg') end, 
    ['Op1_not']  = function (me) Op1_any(me,'lnot') end,
    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
		ASR(not _TP.deref(_TP.deref(e1.tp)),me,'"**Var" is not implemented! ')
       	codeB = LINE(me,'push *'..e1[1],nil,'// Op1_*(push pointer content):: ')
       	BYTECODE(me,codeB,'op_push_p',e1.tp,e1.val)
    end,
    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        ASR(false,me,'"." is not implemented! ')
        me.val  = '('..e1.val..ceu2c(op)..id..')'
    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
		if (e1.tag == 'Var' or e1.tag == 'Op2_idx') then
       		codeB = LINE(me,'push &'..me.fst.id,nil,'// Op1_&(push var/array address):: ')
			BYTECODE(me,codeB,'op_push_c',me.fst.off)
		end
		-- "Work around" to get '&' of array[var]
		if (e1.tag == 'Op2_idx') then
			CONC(me,e1[3])
	    	codeB = LINE(me,'push idx max '..me.fst.arr,nil,'// push array max idx')
			BYTECODE(me,codeB,'op_push_c',me.fst.arr)
			codeB = LINE(me,'mod: limmit idx')
   			BYTECODE(me,codeB,'op2_any','mod')
	    	codeB = LINE(me,'push var len '..e1.tp,nil,'// push array var len')
			BYTECODE(me,codeB,'op_push_c',_ENV.c[e1.tp].len)
			codeB = LINE(me,'mult: varlen * idx')
   			BYTECODE(me,codeB,'op2_any','mult')
			codeB = LINE(me,'add: array base addr + len position')
   			BYTECODE(me,codeB,'op2_any','add')
		end
	end,
    Op1_cast = function (me)
        local tp, exp = unpack(me)
   		CONC(me,exp)
   		codeB = LINE(me,'cast '..tp,nil,'// cast <type> ')
   		BYTECODE(me,codeB,'op_cast',tp)
    end,

    ['CONST'] = function (me)
--    	LINE(me,'push '..me.tp..' '.. me[1]..'   // CONST| '..me[1])
--    	codeB = LINE(me,'push_c '.._TP.getConstLen(me[1])..' '..me[1],nil,'// push '.. me.tp ..' '.. me[1]..' :: CONST| '..me[1])
    	codeB = LINE(me,'push '..me[1],nil,'// push Const ')
		BYTECODE(me,codeB,'op_push_c',me[1])
    end,  
    ['Var'] = function (me)
		ASR(typelen[me.var.tp] or _TP.deref(me.var.tp),me,'must use custom type only as pointer.')
    	codeB = LINE(me,'push '..me.var.id..':'..me.var.tp,nil,'// push Var ')
		BYTECODE(me,codeB,'op_push_v',me.var.tp,me.var.val)
    end,
    Exp = function (me)
    	if (me[1].code=="") then me[1].code='TODO' end
    	CONC(me,me[1]);
    end,
    Op2_idx = function (me)
    	local _, arr, idx = unpack(me)
    	ASR(((_ENV.c[me.tp] and _ENV.c[me.tp].len) or 2)  <=4,me,'arrays expressions cannot have type len > 4')
		ASR((idx.tag == 'CONST' or idx.tag=='Var'),me,'array index cannot be an expression! ')
		if (idx.tag == 'CONST') then
			ASR(tonumber(idx.val) < tonumber(me.fst.arr),me,'index >= array size')
--afb	       	codeB = LINE(me,'push '..me.fst.id ..'['..idx[1] ..']',nil,'//  push array')
--			BYTECODE(me,codeB,'op_pusharr_c',me.tp,idx.val,me.fst.arr,arr.val)
	       	codeB = LINE(me,'push '..me.fst.id ..'['..idx[1] ..']',nil,'//  push array')
			BYTECODE(me,codeB,'op_push_v',me.tp,arr.val+(idx.val*_ENV.c[_TP.deref(me.tp) or me.tp].len))
		end
        if (idx.tag=='Var') then
	       	codeB = LINE(me,'push '..me.fst.id ..'['..idx[1] ..']',nil,'// push array')
			BYTECODE(me,codeB,'op_pusharr_v',me.tp,idx.tp,idx.val,me.fst.arr,arr.val)
		end
    end   
}
_AST.visit(F)

end

end

local tps = { [1]='u8', [2]='u16', [4]='u32' }

local ALL = {
    n_tracks = _ANALYSIS.n_tracks,
    n_mem = _MEM.max,
    tceu_noff = tps[_ENV.c.tceu_noff.len],
    tceu_nlbl = tps[MAX(_ENV.c.tceu_nlbl.len,_ENV.c.tceu_noff.len)],
}

assert(_MEM.max < 2^(_ENV.c.tceu_noff.len*8))

-- TEMPLATE
local tpl
do
    tpl = [===[#define N_MEM       (=== N_MEM ===)
#define N_TRACKS    (=== N_TRACKS ===)
#define CEU_WCLOCK0 (=== CEU_WCLOCK0 ===)
#define CEU_ASYNC0  (=== CEU_ASYNC0 ===)


=== CODE ===
]===]

    local sub = function (str, from, to)
        local i,e = string.find(str, from)
        return string.sub(str, 1, i-1) .. to .. string.sub(str, e+1)
    end

    tpl = sub(tpl, '=== N_TRACKS ===',  ALL.n_tracks)
    tpl = sub(tpl, '=== N_MEM ===',     ALL.n_mem)

    --afb tpl = sub(tpl, '=== HOST ===',      (_OPTS.analysis_run and '') or _CODE.host)
    tpl = sub(tpl, '=== CODE ===',      _AST.root.code)

    -- lbl >= off (EMITS)
    --afb tpl = sub(tpl, '=== TCEU_OFF ===',  ALL.tceu_noff)
    --afb tpl = sub(tpl, '=== TCEU_LBL ===',  ALL.tceu_nlbl)

    -- GTES
    tpl = sub(tpl, '=== CEU_WCLOCK0 ===', _MEM.gtes.wclock0)
    tpl = sub(tpl, '=== CEU_ASYNC0 ===',  _MEM.gtes.async0)

    -- LABELS
    --afb tpl = sub(tpl, '=== N_LABELS ===', #_LABELS.list)
    --afb tpl = sub(tpl, '=== LABELS ===',   _LABELS.code)

    -- DEFINITIONS: constants & defines
    do
        -- EVENTS
        local str = ''
        local t = {}
        local outs = 0
        local ins  = {}
        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                str = str..'#define IN_'..ext.id..' '.._MEM.gtes[ext.n]..'\n'
                ins[#ins+1] = _MEM.gtes[ext.n]
            else
                str = str..'#define OUT_'..ext.id..' '..ext.seq..'\n'
                outs = outs + 1
            end
        end
        str = str..'#define OUT_n '..outs..'\n'
        if _OPTS.analysis_run then
            str = str..'#define IN_n '..#ins..'\n'
            str = str .. 'int IN_vec[] = { '..table.concat(ins,',')..' };\n'
        end

        -- FUNCTIONS called
        for id in pairs(_ENV.calls) do
            if id ~= '$anon' then
                str = str..'#define FUNC'..id..'\n'
            end
        end

        -- DEFINES
        if _PROPS.has_exts then
            str = str .. '#define CEU_EXTS\n'
            ALL.exts = true
        end
        if _PROPS.has_wclocks then
            str = str .. '#define CEU_WCLOCKS '.._ENV.n_wclocks..'\n'
            ALL.wclocks = true
        end
        if _PROPS.has_asyncs then
            str = str .. '#define CEU_ASYNCS '.._ENV.n_asyncs..'\n'
            ALL.asyncs = true
        end
        if _PROPS.has_emits then
            str = str .. '#define CEU_STACK\n'
            ALL.emits = true
        end
        if _ANALYSIS.needsTree then
            str = str .. '#define CEU_TREE\n'
            ALL.tree = true
        end
        if _ANALYSIS.needsChk then
            str = str .. '#define CEU_TREE_CHECK\n'
            ALL.chk = true
        end

        if _OPTS.defs_file then
            --local f = io.open(_OPTS.defs_file,'w')
            --f:write(str)
            --f:close()
            --afb tpl = sub(tpl, '=== DEFS ===','#include "'.. _OPTS.defs_file ..'"')
        else
            --afb tpl = sub(tpl, '=== DEFS ===', str)
        end
    end
end

-- outputs compilation parameters
local t = {}
for k,v in pairs(ALL) do
    if v == true then
        t[#t+1] = k
    else
        t[#t+1] = k..'='..v
    end
end
table.sort(t)
--DBG('[ '..table.concat(t,' | ')..' ]')
--[[
]]

-- OUTPUT
local out
if _OPTS.output == '-' then
--    out = io.stdout
else
--    out = assert(io.open(_OPTS.output,'w'))
end
--out:write(tpl)

-- Print OPCODES
_AST.root.op_addr={}

codeAddr = ((ALL.n_tracks+1)*4) + ALL.n_mem

pos = codeAddr
nLbl=0
for x,op in ipairs(_AST.root.opcode) do
	_AST.root.op_addr[x]=pos
	if (string.sub(op,1,1) ~= 'L') then 
		pos = pos + 1
	else
		nLbl=nLbl+1
	end	
end
endCode = pos;

-- build Label x Addr Table
_AST.root.labeltable={}
for x,op in ipairs(_AST.root.opcode) do
	if (string.sub(op,1,1) == 'L') then 
		_AST.root.labeltable[tonumber('0x'..string.sub(op,2,5))]=_AST.root.op_addr[x];
	end	
end

pos=endCode
idx=table.getn(_AST.root.opcode)+1

-- Code for LblTable11 :: label(1byte) x Addr(1byte)
LblTable11_addr=pos;
for lbl,addr in pairs(_AST.root.labeltable) do
	if (lbl<=0xff and addr<=0xff) then
		_AST.root.opcode[idx]=string.format('%02x',lbl)		
		_AST.root.opcode[idx+1]=string.format('%02x',addr)		
		_AST.root.code2[idx]='L'..lbl..'(0x'..string.format('%02x',lbl)..') => '..addr..' (0x'..string.format('%02x',addr)..')'		
		_AST.root.code2[idx+1]=''
		_AST.root.op_addr[idx]=pos
		_AST.root.op_addr[idx+1]=pos+1
		idx=idx+2; 
		pos=pos+2;
	end
end
-- Code for LblTable12 :: label(1byte) x Addr(2byte)
LblTable12_addr=pos;
for lbl,addr in pairs(_AST.root.labeltable) do
	if (lbl<=0xff and addr>0xff) then
		_AST.root.opcode[idx]=string.format('%02x',lbl)		
		_AST.root.opcode[idx+2]=string.format('%02x',(addr%0x100))		
		_AST.root.opcode[idx+1]=string.format('%02x',math.floor(addr/0x100))		
		_AST.root.code2[idx]='L'..lbl..'(0x'..string.format('%02x',lbl)..') => '..addr..' (0x'..string.format('%04x',addr)..')'		
		_AST.root.code2[idx+1]=''
		_AST.root.code2[idx+2]=''
		_AST.root.op_addr[idx]=pos
		_AST.root.op_addr[idx+1]=pos+1
		_AST.root.op_addr[idx+2]=pos+2
		idx=idx+3; 
		pos=pos+3;
	end
end
-- Code for LblTable21 :: label(2byte) x Addr(1byte)
LblTable21_addr=pos;
for lbl,addr in pairs(_AST.root.labeltable) do
	if (lbl>0xff and addr<=0xff) then
		_AST.root.opcode[idx+1]=string.format('%02x',lbl%0x100)		
		_AST.root.opcode[idx]=string.format('%02x',math.floor(lbl/0x100))		
		_AST.root.opcode[idx+2]=string.format('%02x',addr)		
		_AST.root.code2[idx]='L'..lbl..'(0x'..string.format('%04x',lbl)..') => '..addr..' (0x'..string.format('%02x',addr)..')'		
		_AST.root.code2[idx+1]=''
		_AST.root.code2[idx+2]=''
		_AST.root.op_addr[idx]=pos
		_AST.root.op_addr[idx+1]=pos+1
		_AST.root.op_addr[idx+2]=pos+2
		idx=idx+3; 
		pos=pos+3;
	end
end
-- Code for LblTable22 :: label(2byte) x Addr(2byte)
LblTable22_addr=pos;
for lbl,addr in pairs(_AST.root.labeltable) do
	if (lbl>0xff and addr>0xff) then
		_AST.root.opcode[idx+1]=string.format('%02x',lbl%0x100)		
		_AST.root.opcode[idx]=string.format('%02x',math.floor(lbl/0x100))		
		_AST.root.opcode[idx+3]=string.format('%02x',(addr%0x100))		
		_AST.root.opcode[idx+2]=string.format('%02x',math.floor(addr/0x100))		
		_AST.root.code2[idx]='L'..lbl..'(0x'..string.format('%04x',lbl)..') => '..addr..' (0x'..string.format('%04x',addr)..')'		
		_AST.root.code2[idx+1]=''
		_AST.root.code2[idx+2]=''
		_AST.root.code2[idx+3]=''
		_AST.root.op_addr[idx]=pos
		_AST.root.op_addr[idx+1]=pos+1
		_AST.root.op_addr[idx+2]=pos+2
		_AST.root.op_addr[idx+3]=pos+3
		idx=idx+4; 
		pos=pos+4;
	end
end
LblTableEnd_addr=pos;


-- ====  Environment parameters  ====
-- codeAddr,LblTable11_addr,LblTable12_addr,LblTable21_addr,LblTable22_addr,LblTableEnd_addr,n_tracks,n_wavlocks,wclock0,gate0
asmText = codeAddr..' '..LblTable11_addr..' '..LblTable12_addr..' '..LblTable21_addr..' '..LblTable22_addr..' '..LblTableEnd_addr
asmText = asmText ..' '..ALL.n_tracks..' '.._ENV.n_wclocks..' '.._MEM.gtes.wclock0..' '.._ENV.gate0..'\n'
-- === Tracks ===
xAddr=0
for x=1,ALL.n_tracks+1,1 do
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. 0 ..' '..'track:'.. x-1 ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. 0 ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. 0 ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. 0 ..'\n'; xAddr=xAddr+1;
end
xMemAddr=(ALL.n_tracks+1)*4;
-- === WClocks ===
for x=1,_ENV.n_wclocks,1 do
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..' '..'wClock:'.. x-1 ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
end
-- === Gates ===
for _,ext in ipairs(_ENV.exts) do
  if (ext.pre == 'input') then  -- save code to write 0
    asmText = asmText ..'00 | '..string.format('%04d',xAddr)..' '..string.format('%04d',xAddr-xMemAddr)..' '.. ext.id  ..' '..'gate(s) = '.. (_ENV.awaits[ext] or 0) ..'\n'; xAddr=xAddr+1;
    for x= 0, (_ENV.awaits[ext] or 0)-1,1 do 
	  asmText = asmText .. '00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
	  asmText = asmText .. '00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
	end
  end
end
-- === Vars ===
for x=xAddr,codeAddr-1,1 do
	  asmText = asmText .. '00 | '..string.format('%04d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr)..' '..(_MEM.vars[xAddr-xMemAddr] or '')..'\n'; xAddr=xAddr+1;
end
-- === Opcodes ===
nlines=0;
lastBytes=0
_AST.root.x_stack = 0;
_AST.root.max_stack = 0;
for x,op in pairs(_AST.root.opcode) do
	if (string.sub(op,1,1) ~= 'L') then 
		_AST.root.x_stack = _AST.root.x_stack + (_AST.root.n_stack[x] or 0);
		_AST.root.max_stack = math.max(_AST.root.max_stack,_AST.root.x_stack);
		asmText = asmText ..trim(op)..' | '..string.format('%04d',_AST.root.op_addr[x])..' '..op..' '..(_AST.root.code2[x] or '')..'\n'
		nlines=nlines+1;
		lastBytes=_AST.root.op_addr[x];
	else
		_AST.root.x_stack = 0;
	end	
end

print('Code size = '.. (nlines) ..' bytes.') 
print('Stack size = '.._AST.root.max_stack..' ('.._AST.root.max_stack*4 ..' bytes).') 
print('Using '.. lastBytes+_AST.root.max_stack*4 ..' bytes of VM memory')
print('Total of '.. math.ceil((endCode-codeAddr)/24)..' message(s)')

if (lastBytes+_AST.root.max_stack*4 > (60*24)) then
	print('WARNING: Program may be too long for VM memory. Please check target VM memory capacity!')
end
-- OUTPUT_ASM

local out2
if _OPTS.output2 == '-' then
    out2 = io.stdout
else
	out2_fname = string.match(params[1], "(.*)%.terra")..'.vmx'
    out2 = assert(io.open(out2_fname,'w'))
end
out2:write(asmText)

