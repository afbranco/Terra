#!/usr/bin/env lua

--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_CEU = true

_OPTS = {
    input     = nil,
    output    = '_ceu_code.cterra',
    output2   = '_ceu_opcode.vmx',

    opt       = true,
    join      = true,
    warn      = true,
    wstrong   = true,
    wweak     = false,
    includePath="",

}

_OPTS_NPARAMS = {
    input     = nil,
    output    = 1,

    opt       = 0,
    join      = 0,
    warn      = 0,
    wstrong   = 0,
    wweak     = 0,
}

function trim (s)
  return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

local params = {...}
local i = 1
--print("terrac::params:",#params)
while i <= #params
do
    local p = params[i]

--print("terrac::param:",params[i])
    if p:sub(1,2) == '-I' then
        _OPTS.includePath = _OPTS.includePath .. " ".. p

    elseif p == '-' then
        _OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if _OPTS[opt]==nil then
          _OPTS.input = nil
          break
        end
        if _OPTS_NPARAMS[opt] == 0 then
            _OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            _OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            --i = i + 1
        end

    else
        _OPTS.input = p
    end
    i = i + 1
end

--os.exit(0)

if not _OPTS.input then
    io.stderr:write([[

    ./terrac <filename>          # Terra input file, or `-´ for stdin
        --output <filename>      # vmx output file (input.vmx)
        --join    (--no-join)    # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --opt     (--no-opt)     # activate code optimization (opt)
        --warn    (--no-warn)    # activate warnings (warn)
        --wstrong (--no-wstrong) # warning strong nondeterminism (wstrong)
        --wweak   (--no-wweak)   # warning weak nondeterminism (no-wweak)
        -Ipath                   # Path for include files (.defs)
]])
    os.exit(1)
end
if not string.match(_OPTS.input, "(.*)%.terra") then 
  io.stderr:write([[
  Invalid input file name. It needs a `.terra´ sufix.
  
]])
  os.exit(1)
end

local test_file = io.open(_OPTS.input)
if  test_file then
   io.close(test_file)
else
  io.stderr:write([[
  File `]].. _OPTS.input .. [[´ not found.
  
]])
  os.exit(1)
end


local cpp_file = 'precomp.terra'
-- Pre-processor phase
--    local cpp = assert(io.popen('cpp -C '.._OPTS.input..' ' ..cpp_file, 'w'))
    local cpp = assert(io.popen('cpp -C '.._OPTS.input..' ' ..cpp_file .. _OPTS.includePath, 'w'))
    cpp:close()

local test_file = io.open(cpp_file)
if  test_file then
   io.close(test_file)
else
  io.stderr:write([[
  Preprocessor error!
  
]])
  os.exit(1)
end


-- INPUT
local inp
--inp = io.stdin
--inp = assert(io.open(cpp_file))
--_STR = inp:read'*a'
_STR=""

-- Remove '#' lines generated from cpp
for line in io.lines(cpp_file) do
--  print(string.sub(line,1,1))
  if string.sub(line,1,1) ~= '#' then
    _STR = _STR..line..'\n'
  end
end
os.remove(cpp_file)

-- PARSE
do
    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_WRN = {
    n_wrns = 0;       --afb Count warning messages
}
_TP = {}

local types = {
    void=true,
    ulong=true, long=true,
    ushort=true, short=true,
    ubyte=true,  byte=true,
    float=true,
}

function _TP.isBasicType(tp)
  return types[tp]
end
-- TODO: enforce passing parameter `c´ to isNumeric/deref/contains/max ?

function _TP.raw (tp)
    return (string.match(tp, '^([_%w]*)%**'))
end

function _TP.c (tp)
    return (string.gsub(tp, '^_', ''))
end

function _TP.len (tp)
    return (_ENV.c[tp] and _ENV.c[tp].len) or 0
end

function _TP.isNumeric (tp, c)
    return tp~='void' and types[tp] or (c and _TP.ext(tp))
end

function _TP.deref (tp, c)
--print("tp::deref:",tp)--,string.match(tp, '(.-)%*$'))
    return string.match(tp, '(.-)%*$') or (c and _TP.ext(tp))
end

function _TP.ext (tp)
    return (string.sub(tp,1,1) == '_') and
            (not string.match(tp, '(.-)%*$')) and tp
end


function _TP.getAuxTag(tp1,arr1)
    local aux={}
    aux.tp = tp1
    aux.ntp = tp1
    aux.arr = arr1
    aux.lvl=0
    aux.len=0
    aux.bType=nil
    aux.auxtag=nil
    while _TP.deref(aux.ntp) do aux.ntp = _TP.deref(aux.ntp); aux.lvl = aux.lvl+1 end
    aux.bType = _TP.isBasicType(aux.ntp)
--    aux.len = (aux.arr and aux.arr*_ENV.c[aux.ntp].len) or (_TP.isBasicType(aux.ntp) and ((aux.lvl==0 and _ENV.c[aux.ntp].len) or 2)) or _ENV.c[aux.ntp].len 
    aux.len = (aux.arr and aux.arr*_ENV.c[aux.ntp].len) or ((_ENV.packets[aux.ntp] and _ENV.packets[aux.ntp].len) or _ENV.c[aux.ntp].len) 

    aux.auxtag = 
          ((    aux.ntp == 'void'                       ) and 'void'    ) or
          ((not aux.bType and aux.lvl==1                ) and 'pointer' ) or
          ((not aux.bType and aux.lvl==0                ) and 'data'    ) or
          ((    aux.bType and aux.lvl==0                ) and 'var'     ) or
          ((    aux.bType and aux.lvl==1 and not aux.arr) and 'pointer' ) or
          ((    aux.bType and aux.lvl==1 and     aux.arr) and 'data'    ) or
          ((    aux.bType and aux.lvl==2 and not aux.arr) and 'pointer2') or
          ((    aux.bType and aux.lvl==2 and     aux.arr) and 'pointer2') or 'other'

--print("tp::getAuxTag:",aux.auxtag,aux.tp,aux.ntp,aux.lvl,aux.arr,aux.len)
return aux
end

function _TP.tpCompat(tp1,tp2,arr1,arr2)
    -- error == true -> incompatible types
    -- cast == true -> need cast
    local error = true 
    local cast = false
    local z1 = _TP.getAuxTag(tp1,arr1)
    local z2 = _TP.getAuxTag(tp2,arr2)
--print("tp::tpCompat:",tp1,tp2,arr1,arr2,z1.auxtag,z2.auxtag,z1.tp,z2.tp,z1.len,z2.len)

-- *************************
-- * Type Compatibility
-- *************************

--  type            -> auxtag;    tp;   size
-----------------------------------------------------
-- reg*             -> pointer;   ushort;   reg len
-- reg              -> data;      reg;      reg len
-- tpBasic          -> var;       tp;       tp len
-- tpBasic* + ~arr  -> pointer;   ushort;   arr*tp
-- tpBasic* +  arr  -> data;      arr*tp;   arr*tp
-- tpBasic** + ~arr -> pointer;   ushort;   arr*tp
-- tpBasic** +  arr -> pointer;   ushort;   arr*tp
-- void             -> void;      void;     0
-----------------------------------------------------

-- *** Valid operations ***
-- auxtag1  = auxtag2;  arr/data;   size limit;     cast
-------------------------------------------------------------
--R pointer  = pointer;  addr copy;  len1 <= len2;   len1 < len2
--R pointer  = data;     addr copy;  len1 <= len2;   len1 < len2
-- data     = data;     data copy;  min(len1,len2); len1 <> len2
-- var      = var;      data copy;  min(len1,len2); len1 < len2
-- ???      = void;     default 'invalid'
-------------------------------------------------------------

    if
        (z1.auxtag == 'var'      and z2.auxtag == 'var'    )                    
    then
        error = false
        cast = ((tp1~=tp2 and (tp1=='float' or tp2=='float'))) or
               ((tp1~='float' and tp2~='float') and (z1.len < z2.len))
    elseif
        (z1.auxtag == 'pointer'     and z2.auxtag == 'pointer'   ) and ((z1.len == z2.len and tp1~='float' and tp2~='float') or (tp1=='float' and tp2=='float'))                   
    then
        error = false
        cast = false
    elseif
        (z1.auxtag == 'data'     and z2.auxtag == 'data'   ) and (z1.tp == z2.tp)                   
    then
        error = false
        cast = false
    else
        error = true
        cast = false
    end
    return error, cast, z1.ntp, z2.ntp, z1.len, z2.len
end

function _TP.contains (tp1, tp2, c)
    local _tp1, _tp2 = _TP.deref(tp1), _TP.deref(tp2)
--print("tp::contains:",tp1, tp2,_tp1, _tp2, _TP.len(tp1), _TP.len(tp2),_TP.ext(tp1) , _TP.ext(tp2))
    if (not(_tp1) and tp1 == tp2) then
        return true
--    elseif _TP.isNumeric(tp1) and _TP.isNumeric(tp2) then
--        return true
    elseif (not(_tp1) and _TP.len(tp1) >= _TP.len(tp2)) then   -- afb
        return true                                         -- afb
--    elseif c and (_TP.ext(tp1) or _TP.ext(tp2)) then
--        return true
    elseif _tp1 and _tp2 then
        return tp1=='void*' or tp2=='void*' or _TP.contains(_tp1, _tp2, c)
    end
--print("tp::contains2:")
    return false
end

function _TP.max (tp1, tp2, c)
    if (tp1=='float' or tp2=='float') then return 'float'; end
    if _TP.contains(tp1, tp2, c) then
        return tp1
    elseif _TP.contains(tp2, tp1, c) then
        return tp2
    else
        return nil
    end
end

function _TP.getCastType(tp)
  return ((tp=='ubyte' or tp=='ushort' or tp=='ulong') and 'ulong') or ((tp=='byte' or tp=='short' or tp=='long') and 'long') or 'float'  
end

function _TP.getConstType(val,me,no_wrn)
  if ((string.find(val,'e') or string.find(val,'E') or string.find(val,'%.')) and tonumber(val)) and not(string.find(val,'x') or string.find(val,'X'))then
    local nval = tonumber(val)
    if (nval < -3.4E+38) or (nval > 3.4E+38)  then
      WRN(no_wrn,me,'Float constant out of range, got: "'.. val ..'", value must range (+/-) 3.4E+38')
    end    
    return 'float'
  else
    local nval = tonumber(val) or string.byte(val,2)
--print("tp::getConstTypeI:",val,nval)
  	if (nval <= 0xff) then return 'ubyte' end
    if (nval <= 0xffff) then return 'ushort' end
    if (nval <= 0xffffffff) then return 'ulong' end
    WRN(no_wrn,me,'Integer constant too large, got: "'.. val ..'", max value must be (2^32)-1')
  	return 'ulong'
  end
end

function _TP.getConstLen(val)
--print("tp::getConstLen:",val)
  local nval = tonumber(val) or string.byte(val,2)
  if (nval <= 0xff) then return 0 end
  if (nval <= 0xffff) then return 1 end
  if (nval <= 0xffffff) then return 2 end
  return 3
end

function _TP.getConstBytes(val,len)
  len = len or 0;
  nx=1
  local nval = tonumber(val) or string.byte(val,2)
  local bytes = string.format('%02x ',nval % 256)
  while (math.floor(nval/256) > 0 or len>1)  and nx < 4 do
    nx = nx+1;
    len = len - 1;
    nval = math.floor(nval/256)
    -- big-endian byte order
    bytes = string.format('%02x %s ',nval % 256,bytes)
  end
  return trim(bytes)
end

function _TP.getConstLenLbl(val)
--print("tp::getConstLenLbl:",val)
  local nval = tonumber(val) or string.byte(val,2)
  if (nval <= 0xff) then return 1 end
  if (nval <= 0xffff) then return 1 end
  if (nval <= 0xffffff) then return 2 end
  return 3
end
function _TP.getConstBytesLbl(val,len)
  len = 2;
  nx=1
  local nval = tonumber(val) or string.byte(val,2)
  local bytes = string.format('.%02x ',nval % 256)
  while (math.floor(nval/256) > 0 or len>1)  and nx < 4 do
    nx = nx+1;
    len = len - 1;
    nval = math.floor(nval/256)
    -- big-endian byte order
    bytes = string.format('.%02x %s ',nval % 256,bytes)
  end
  return trim(bytes)
end

--------------------------------------
-- Convert float to hex / hex to float
-- Tanks to François Perrad
-- lua-MessagePack : <http://fperrad.github.io/lua-MessagePack/>

function _TP.float2hex (n)
    if n == 0.0 then return 0.0 end

    local sign = 0
    if n < 0.0 then
        sign = 0x80
        n = -n
    end

    local mant, expo = math.frexp(n)
    local hext = {}

    if mant ~= mant then
        hext[#hext+1] = string.char(0xFF, 0x88, 0x00, 0x00)

    elseif mant == math.huge or expo > 0x80 then
        if sign == 0 then
            hext[#hext+1] = string.char(0x7F, 0x80, 0x00, 0x00)
        else
            hext[#hext+1] = string.char(0xFF, 0x80, 0x00, 0x00)
        end

    elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
        hext[#hext+1] = string.char(sign, 0x00, 0x00, 0x00)

    else
        expo = expo + 0x7E
        mant = (mant * 2.0 - 1.0) * math.ldexp(0.5, 24)
        hext[#hext+1] = string.char(sign + math.floor(expo / 0x2),
                                    (expo % 0x2) * 0x80 + math.floor(mant / 0x10000),
                                    math.floor(mant / 0x100) % 0x100,
                                    mant % 0x100)
    end

    return tonumber(string.gsub(table.concat(hext),"(.)",
                                function (c) return string.format("%02X%s",string.byte(c),"") end), 16)
end


function _TP.hex2float (c)
    if c == 0 then return 0.0 end
    local c = string.gsub(string.format("%X", c),"(..)",function (x) return string.char(tonumber(x, 16)) end)
    local b1,b2,b3,b4 = string.byte(c, 1, 4)
    local sign = b1 > 0x7F
    local expo = (b1 % 0x80) * 0x2 + math.floor(b2 / 0x80)
    local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

    if sign then
        sign = -1
    else
        sign = 1
    end

    local n

    if mant == 0 and expo == 0 then
        n = sign * 0.0
    elseif expo == 0xFF then
        if mant == 0 then
            n = sign * math.huge
        else
            n = 0.0/0.0
        end
    else
        n = sign * math.ldexp(1.0 + mant / 0x800000, expo - 0x7F)
    end

    return n
end
--- =========================================


--------------------------------------
-- Copyright 2009: hans@hpelbers.org
-- This is freeware
 
function print_r (t, name, indent, maxLevel)
  local tableList = {}
  maxLevel = maxLevel or 1000
  function table_r (t, name, indent, full, maxLevel)
    local id = not full and name
        or type(name)~="number" and tostring(name) or '['..name..']'
    local tag = indent .. id .. ' = '
    local out = {}    -- result
    if type(t) == "table" then
      if tableList[t] ~= nil then table.insert(out, tag .. '{} -- ' .. tableList[t] .. ' (self reference)')
      else
        tableList[t]= full and (full .. '.' .. id) or id
        if next(t) then -- Table not empty
          table.insert(out, tag .. '{')
          maxLevel = maxLevel - 1
          for key,value in pairs(t) do
            if maxLevel > 0 then
              table.insert(out,table_r(value,key,indent .. '|  ',tableList[t],maxLevel))
            end
          end
          table.insert(out,indent .. '}')
        else table.insert(out,tag .. '{}') end
      end
    else
      local val = type(t)~="number" and type(t)~="boolean" and '"'..tostring(t)..'"' or tostring(t)
      table.insert(out, tag .. val)
    end
    return table.concat(out, '\n')
  end
  return table_r(t,name or 'Value',indent or '', nil,maxLevel)
end
--- =========================================
end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

--m = require 'lpeg_0_10_2_1-lpeg'
m = require 'lpeg'

print(m.version())

m.setmaxstack(1000)

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, me, msg)
    local ln = (me and ((type(me)=='number' and me) or me.ln) or 0)
    if not cond  and _OPTS.warn then
      if me then
        DBG('WRN : line '..ln..' : '..msg)
      else
        DBG('WRN : '..msg)
      end
        _WRN.n_wrns = _WRN.n_wrns + 1;
    end
    return cond
end
function ASR (cond, me, msg)
    local ln = (type(me)=='number' and me) or me.ln
    if _CEU then
        if not cond then
            DBG('ERR : line '..ln..' : '..msg)
            os.exit(1)
        end
        return cond
    else
        return assert(cond, 'ERR : line '..ln..' : '..msg)
    end
end

_I2L = {}

local CNT = 1
local open = m.Cmt('/*{-{*/',
    function ()
        if _OPTS.join then
            CNT = CNT - 1
        end
    end )
local close = m.Cmt('/*}-}*/',
    function ()
        if _OPTS.join then
            CNT = CNT + 1
        end
    end )

local LINE = 1
local line = m.Cmt('\n',
    function (s,i)
        for i=#_I2L, i do
            _I2L[i] = LINE
        end
        if CNT > 0 then
            LINE = LINE + 1
        end
    end )

local patt = (line + open + close + 1)^0
patt:match(_STR..'\n')

end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_PARSER = {
}

local P, C, V, Cc, Ct = m.P, m.C, m.V, m.Cc, m.Ct

local S = V'_SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return #P(1) * m.Cmt(patt*key, f) * S
end
local CK = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return C(m.Cmt(patt*key, f))*S
end
local EK = function (tk, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    return K(P(tk)*key) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."´"
            end
            return false
        end) * P(false)
end

local KEY = function (str)
    return K(str,true)
end
local EKEY = function (str)
    return EK(str,true)
end
local CKEY = function (str)
    return CK(str,true)
end

local _V2NAME = {
    Exp = 'expression',
    _Exp = 'expression',
    _Stmt = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    ID_c  = 'identifier',
    ID_var  = 'a not reserved identifier beginning with lower-case',
    ID_int  = 'identifier',
    ID_ext  = 'identifier all upper-case',
    ID_type = 'type',
    ID_btype = ' a valid basic type',
    ID_tvoid = ' a valid basic type/pointer or a register type',
    ID_arg_type = 'type',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    _Dcl_func = 'declaration',
    __ID = 'identifier',

    ID_version  = 'version identifier <num.num.num> ',
    CfgBlk = 'Config block declaration',
    ID_field_type = 'a valid non pointer basic type or payload[n]',
    _Dcl_struct = 'declaration',
--    ID_evt  = 'identifier',
    Op_var = 'variable',

}
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end)
end

local EM = function (msg)
--    return m.Cmt(P'',
    return m.Cmt(P'_',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. msg
                return false
            end
        end)
end

TYPES = -- P'void' +
       P'ubyte' + 'ushort' + 'ulong'
      + 'byte' + 'short' + 'long'
      + 'float'

PK_TYPES = -- P'void' +
       P'ubyte' + 'ushort' + 'ulong'
      + 'byte' + 'short' + 'long'
      + 'float'
      + 'payload'

KEYS = P'and'     
     + 'async'    
     + 'await'    + 'break'    
     + 'safe'     + 'unsafe'   + 'do'       + 'else'
     + 'else/if'  + 'emit'     + 'end'      + 'event'   
     + 'finally'  + 'FOREVER'  + 'if'       + 'input'    + 'loop'
     + 'nohold'   + 'not'      + 'null'     + 'or'       + 'output'
     + 'par'      + 'par/and'  + 'par/or'                + 'pure'
     + 'return'   + 'sizeof'   + 'then'     + 'var'      + 'with'
     + 'function' + 'config'   + 'regtype'  + 'inc'      + 'dec'
     + 'pktype'
     + PK_TYPES

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber
PNUM = -K'-'*CK(m.R'09'^1) / tonumber + EM'a positive integer number'

_GG = { 
      [1] = CK'' * V'Prog' * P(-1)-- + EM'expected EOF')

      , Prog = (CK'' * EV'CfgBlk' * EV'Block' * P(-1)) + EM'config block + program'

------
    , CfgBlk = KEY'config' * V'CfgParams' * EKEY'do' * V'CfgStmts' * EKEY'end'
    , CfgStmts = ((V'_CfgStmt' * (EK';'*K';'^0) + EM'`;´') +
                  (V'_CfgStmtB' * (K';'^-1*K';'^0) + EM'`;´' ) )^0
    , _CfgStmt =  V'_Dcl_ext' + V'_Dcl_func' + V'Dcl_det'  
            --+ EM'config statement (usually a missing `input/output/function/regtype/packet´)'
                  

    , _CfgStmtB = V'_Dcl_regt' + V'_Dcl_packet'
            --+ EM'config statement (usually a missing `regtype varName with varDefs end´)'

    ,_Dcl_func = ((CKEY'function' * (CKEY'pure'+CKEY'nohold'+Cc(false)) * (CKEY(TYPES) + EM'a basic type' )) 
                  * ((V'ID_c' + EM'a valid function identifier') * K'(' * V'Arg_list' * K')') ) * PNUM

    
    , Arg_list = ( V'ID_arg_type' * (EK',' * EV'ID_type')^0  )^-1
    
    , _Dcl_packet = KEY'packet' * EV'ID_var' * EKEY'with' * ((V'_Dcl_field' + V'_Dcl_payfield') * (EK';'*K';'^0))^0 * EKEY'end'
    
------
    , _Block =  ( V'_Stmt' * ((EK';'*K';'^0) + EM'`;´') +
                 V'_StmtB' * ((K';'^-1*K';'^0) + EM'`;´') 
               )^0  
             * ( V'_LstStmt' * ((EK';'*K';'^0) + EM'`;´')  +
                 V'_LstStmtB' * ((K';'^-1*K';'^0) + EM'`;´') 
               )^-1  

    , Block  = V'_Block'
    , BlockN = V'_Block'

    , _Stmt = V'AwaitT'   + V'AwaitExt'  + V'AwaitInt'
            + V'EmitT'    + V'EmitExtS'  + V'EmitInt'
            + V'_Dcl_int' + V'_Dcl_var'
--afb            + V'Dcl_det'  
            + V'_Set'     --+ V'CallStmt' -- must be after Set
            + V'Op_var' 
            + V'Call'
            + EM'statement (not last statement as `return´ or `break´) ' 

    , _StmtB = V'_Do'   
             + V'Async'  
--             + V'Host'
             + V'ParOr' + V'ParAnd' + V'ParEver'
             + V'If'    + V'Loop'
--             + V'Pause'
             + V'_Dcl_regt'
             + V'_Dcl_pktype'

    , _LstStmt  = V'_Return' + V'Break' + V'AwaitN'
    , _LstStmtB = V'ParEver'

    , _SetBlock = ( V'_Do'     
                    + V'Async' 
                    + V'ParEver' + V'If'    + V'Loop' )

    , __ID      = V'ID_c' + V'ID_ext' + V'Var'
--    , Dcl_det   = KEY'safe' * EV'__ID' * EKEY'with' * EV'__ID' * (K',' * EV'__ID')^0
    , Dcl_det   = KEY'unsafe' * EV'__ID' * EKEY'with' * EV'__ID' * (K',' * EV'__ID')^0

    , _Set  = V'LExp' * V'_Sets'
    , _Sets = (CK'=' + CK':=') * (
                Cc'SetAwait' * (V'AwaitT'+V'AwaitExt'+V'AwaitInt') +
                Cc'SetBlock' * V'_SetBlock' +
                Cc'SetExp'   * V'Exp' +
                EM'expression'
              )

--    , CallStmt = m.Cmt(V'Exp',
--                    function (s,i,...)
--                        return (string.sub(s,i-1,i-1)==')'), ...
--                    end)

    , _Do     = KEY'do' * V'BlockN' *
                    (KEY'finally'*V'BlockN' + Cc(false)) *
                EKEY'end'

    , Async   = K'async' * V'VarList' * V'_Do'
    , VarList = ( EK'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )^-1

    , _Return = K'return' * EV'Exp'

    , ParOr   = KEY'par/or' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , ParAnd  = KEY'par/and' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , ParEver = KEY'par' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'

    , If      = KEY'if' * EV'Exp' * EKEY'then' *
                    V'Block' *
                (KEY'else/if' * EV'Exp' * EKEY'then' *
                    V'Block')^0 *
                (KEY'else' *
                    V'Block' + Cc(false)) *
                EKEY'end'

    , Loop    = KEY'loop' *
                    (V'ID_var'* (EK','*EV'Exp' + Cc(false)) +
                        Cc(false)*Cc(false)) *
                V'_Do'
    , Break   = K'break'

    , LExp     = V'_Exp'
    , Exp     = V'_Exp'
    , _Exp    = V'_1'
    , _1      = V'_2'  * (CK'or'  * V'_2')^0
    , _2      = V'_3'  * (CK'and' * V'_3')^0
    , _3      = V'_4'  * ((CK'|'-'||') * V'_4')^0
    , _4      = V'_5'  * (CK'^' * V'_5')^0
    , _5      = V'_6'  * (CK'&' * V'_6')^0
    , _6      = V'_7'  * ((CK'!='+CK'==') * V'_7')^0
    , _7      = V'_8'  * ((CK'<='+CK'>='+(CK'<'-'<<')+(CK'>'-'>>')) * V'_8')^0
    , _8      = V'_9'  * ((CK'>>'+CK'<<') * V'_9')^0
    , _9      = V'_10' * ((CK'+'+(CK'-'-'->')) * V'_10')^0
    , _10     = V'_11' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * V'_11')^0
    , _11     = ( Cc(true) * ( CK'not' + CK'&' + CK'-' + CK'~' -- + CK'*' -- + CK'+' 
                             + (K'<'*EV'ID_btype'*K'>') )
                )^0 * V'_12'
    , _12     = V'_13' *
                    (
--                        K'(' * Cc'call' * V'ExpList' * EK')' +
                        K'[' * Cc'idx'  * V'_Exp'    * EK']' 
                       + (CK'.' )
                            * (CK(Alpha * (Alphanum+'?')^0) /
                                function (id)
                                    return (string.gsub(id,'%?','_'))
                                end)
                    )^0
    , _13     = V'_Prim'
    , _Prim   = V'_Parens' + V'Func'
              + V'Var'   
--              + V'C'   
              + V'SIZEOF'
              + V'NULL'    + V'CONST' --+ V'STRING'
              --+ V'EmitExtE'

    , ExpList = ( V'_Exp'*(K','*EV'_Exp')^0 )^-1

    , _Parens  = K'(' * EV'_Exp' * EK')'

    , Op_var = (CKEY'inc' + CKEY'dec') * EV'_Exp' 

    , SIZEOF = KEY'sizeof' * EK'<' * EV'ID_typenp' * EK'>'

    , CONST = 
             CK( P('0') * (P('x')+P('X')) * (m.R'09'+m.R'AF'+m.R'af')^1 )
            + CK( (#m.R'09' * (m.R'09')^1 *  ( P('.') *  (#m.R'09' * (m.R'09')^1)^-1 )^-1   )   * (  (P('e')+P('E'))* (P('+')+P('-'))^-1 * #m.R'09' * (m.R'09')^1)^-1  )
            + CK( "'" * (P(1)-"'") * "'" )


    , NULL = CK'null'

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
--                (NUM * K'us'  + Cc(0)) *
--                (NUM * EM'<h,min,s,ms,us>')^-1
                (NUM * EM'<h,min,s,ms>')^-1
    , WCLOCKE = K'(' * V'Exp' * EK')' * C(
                    K'h' + K'min' + K's' + K'ms' --+ K'us'
--                  + EM'<h,min,s,ms,us>'
                  + EM'<h,min,s,ms>'
              )

--    , Pause    = KEY'pause/if' * EV'Var' * V'_Do'

    , AwaitExt = KEY'await' * EV'Ext' * ( (K'(' * V'Exp'^-1 * EK')') + Cc(false))
    , AwaitInt = KEY'await' * EV'Var'
    , AwaitN   = KEY'await' * KEY'FOREVER'
    , AwaitT   = KEY'await' * (V'WCLOCKK'+V'WCLOCKE')

    , _EmitExt = KEY'emit' * EV'Ext' * (K'(' * V'Exp'^-1 * EK')')^-1
    , EmitExtS = V'_EmitExt'
    , EmitExtE = V'_EmitExt'

    , EmitT    = KEY'emit' * (V'WCLOCKK'+V'WCLOCKE')

    , EmitInt  = KEY'emit' * EV'Var' * (K'(' * V'Exp'^-1 * EK')')^-1
    
    , Call = V'Func'

--    , _Dcl_ext = (CKEY'input'+CKEY'output') * (EV'ID_type' + EV'ID_tvoid') * EV'ID_ext' * PNUM
    , _Dcl_ext =  (CKEY'output' * (CKEY'pure'+CKEY'nohold'+Cc(false)) * (CKEY'void' + EM'always `void´') * EV'ID_ext' * (EV'ID_type'  + EV'ID_tvoid') * PNUM) +
                  (CKEY'input'  * Cc(false) * (EV'ID_typenp' + EV'ID_tvoid') * EV'ID_ext' * (CKEY'ubyte' + CKEY'void' + EM'`ubyte´ or `void´ type') * PNUM)

    , _Dcl_int  = CKEY'event' * (CKEY(TYPES) + EM'a basic type') * Cc(false) *
                    V'__Dcl_int' * (K','*V'__Dcl_int')^0
--    , _Dcl_int  = CKEY'event' * EV'ID_type' * Cc(false) *
--                    V'__Dcl_int' * (K','*V'__Dcl_int')^0
    , __Dcl_int = EV'ID_int' * (V'_Sets' + Cc(false)*Cc(false)*Cc(false))

--    , _Dcl_var  = CKEY'var' * EV'ID_type' * (K'['*NUM*K']'+Cc(false)) *
--                    V'__Dcl_var' * (K','*V'__Dcl_var')^0
    , _Dcl_var  = CKEY'var' * ( (EV'ID_btype' * (K'['*NUM*K']')) + (EV'ID_typenp' * Cc(false))  ) *
                    V'__Dcl_var' * (K','*V'__Dcl_var')^0
    , __Dcl_var = EV'ID_var' * (V'_Sets' + Cc(false)*Cc(false)*Cc(false))

    , _Dcl_field  = CKEY'var' * EV'ID_field_type' 
                    *  (K'['*PNUM*K']' + Cc(false))
                    *    (V'ID_var' + EM'a valid identifier')  
                    * (K','*V'ID_var')^0
                        
    , _Dcl_payfield  = CKEY'var' * EV'ID_pay_type' 
                    *  K'['*PNUM*K']'
                    *    (V'ID_var' + EM'a valid identifier')  
                        
    , _Dcl_regt   = KEY'regtype' * EV'ID_var' * EKEY'with' * (V'_Dcl_field' * (EK';'*K';'^0))^1 * EKEY'end'
    , _Dcl_pktype = KEY'pktype' * EV'ID_var' * EKEY'from'  * EV'ID_var' * EKEY'with' * (V'_Dcl_field' * (EK';'*K';'^0))^1 * EKEY'end'
    
--    , Func     = V'ID_var' * K'(' * Cc'call' * V'ExpList' * EK')'
    , Func     = V'ID_var' * K'(' * V'ExpList' * EK')'
    , Ext      = V'ID_ext'
    , Var      = V'ID_var'
--    , C        = V'ID_c'


    , CfgParams = V'VM_Name' * K(',')* V'ID_version' * K(',') * V'Params'
    , VM_Name = (K'name' * K(':') * CK((Alphanum)^1)) + EM'"name: xxxx"'
    , ID_version  = K'code'*K(':')*PNUM*K'.'*PNUM*K'.'*PNUM + EM'config NUM.NUM.NUM SIZE do ... end'
    , Params = K'{' * (V'ID_c' * K(':') * PNUM) * ((K',') * V'ID_c' *K(':') * PNUM)^0 * (K',')^-1 * K'}' 

    , ID_ext  = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
 
    , ID_var  = -KEYS * -K'void'* CK(m.R'az'*(Alphanum+'?')^0)
                    / function(id) return (string.gsub(id,'%?','_')) end
    , ID_int  = V'ID_var'
    , ID_c    = V'ID_var' --CK(  P'_' *Alphanum^0)

    , ID_type = (CKEY(TYPES)+V'ID_c') * C(K'*'^0) /
                  function (id, star)
                    return (string.gsub(id..star,' ',''))
                  end
    , ID_typenp = (CKEY(TYPES)+V'ID_c') /
                  function (id)
                    return (string.gsub(id,' ',''))
                  end
    
    , ID_btype = CKEY(TYPES) /
                  function (id)
                    return (string.gsub(id,' ',''))
                  end

    , ID_tvoid = (CKEY('void')) /
                  function (id)
                    return (string.gsub(id,' ',''))
                  end
    , ID_field_type = -K'void' * CKEY(TYPES)
    , ID_pay_type = -K'void' * CKEY(PK_TYPES)
    , ID_arg_type = ((CKEY(TYPES) * C(K'*'^0))  + V'ID_c') /
                  function (id, star)
                    return (string.gsub(id..(star or ''),' ',''))
                  end
    
--    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

--    , Host    = K'C' * (#EK'do')*'do' * m.S' \n\t'^0 *
--                    ( C(V'_C') + C((P(1)-'end')^0) )
--                *S* EK'end'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
--    , _C      = m.Cg(V'_CSEP','mark') *
--                    (P(1)-V'_CEND')^0 *
--                V'_CEND'
--    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
--    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
--                    function (s,i,a,b) return a == b end)

    , _SPACES = (  m.S'\t\n\r @'
                + ('//' * (P(1)-'\n')^0 * P'\n'^-1)
                + V'_COMM'
                )^0

    , _COMM    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'_COMMCMP')^0 * V'_COMMCL'
                    / function () end
    , _COMMCL  = C(P'*'^1) * '/'
    , _COMMCMP = m.Cmt(V'_COMMCL' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)
}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    return 'ERR : line '.._I2L[LST_i]..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."´"..
              ' : '..ERR_msg
end

if _CEU then
    if not m.P(_GG):match(_STR) then
        DBG(err())
        os.exit(1)
    end
else
    assert(m.P(_GG):match(_STR), err())
end

end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_AST = {
    root = nil
}

local MT = {}
local STACK = nil
local FIN = 0     -- cur fin

function _AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

function _AST.isChild (n1, n2)
    return n1 == n2
        or n2.__par and _AST.isChild(n1, n2.__par)
end

function node (tag, min)
    min = min or 0
    return function (ln, ...)
        local node = setmetatable({ ... }, MT)
        if #node < min then
            return ...
        else
            node.ln  = ln
            node.tag = tag
            return node
        end
    end
end

function _AST.pred_tree (me)
    local tag = me.tag
    return tag=='SetBlock' or tag=='ParOr' or tag=='Loop'
end
function _AST.pred_true (me) return true end

function _AST.iter (pred, inc)
    if pred == nil then
        pred = _AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function _AST.copy (node, ln)
    local ret = setmetatable({}, MT)
    for k, v in pairs(node) do
        if _AST.isNode(v) then
            ret[k] = _AST.copy(v, ln)
            ret[k].ln = ln or ret[k].ln
        else
            ret[k] = v
        end
    end
    return ret
end

function _AST.dump (me, spc)
    spc = spc or 0
    local ks = ''
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
    DBG(string.rep(' ',spc) .. me.tag .. ' ('..ks..')')
    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
            _AST.dump(sub, spc+2)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

function _AST.visit (F)
    assert(_AST)
    STACK = {}
    _AST.root.depth = 0
    return visit_aux(_AST.root, F)
end

function EXP (n)
    return node('Exp')(n.ln,n)
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

function visit_aux (me, F)
--DBG(me.tag, me, F)
    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then me=(F.Node_pre(me) or me) end
    if pre then me=(pre(me) or me) end

    me.__par = STACK[#STACK]
    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if _AST.isNode(sub) then
--DBG('> '.._AST.isNode(sub))
            sub.depth = me.depth + 1
            ASR(sub.depth < 127, sub, 'max depth of 127')
            if bef then bef(me, sub) end
            me[i] = visit_aux(sub, F)
            if aft then aft(me, sub) end
        end
    end

    if mid then me=(mid(me) or me) end
    STACK[#STACK] = nil
    if pos then me=(pos(me) or me) end

    if F.Node then me=(F.Node(me) or me) end
    return me
end

local C; C = {
    [1] = function (ln, spc, ...) -- spc=CK''
        local blk = node('Block')(ln)
        blk[#blk+1] = node('Dcl_var')(ln, 'var', 'ubyte',  false, '$ret')
        for i=1, FIN do
            blk[#blk+1] = node('Dcl_int')(ln,true,'ubyte',false,'$fin_'..i)
        end

        blk[#blk+1] = node('SetBlock')(ln,
                        EXP(node('Var')(ln, '$ret')),
                        ...)  -- ...=Block

        _AST.root = node('Root')(ln, blk)
        return _AST.root
    end,

    CfgParams = node('CfgParams'),
    Prog    = node('Block'),
    CfgBlk  = node('CfgBlk'),
    Block   = node('Block'),
    BlockN  = node('BlockN'),
--    Host    = node('Host'),

    _Return = node('_Return'),

    Async   = node('Async'),
    VarList = function (ln, ...)
        local t = { ... }
        for i, var in ipairs(t) do
            t[i] = EXP(var)
        end
        return node('VarList')(ln, unpack(t))
    end,

    ParEver = node('ParEver'),
    ParOr   = node('ParOr'),
    ParAnd  = node('ParAnd'),

    _Do = function (ln, b1, b2)
        if not b2 then
            return node('Block')(ln, b1)
        end

        FIN = FIN + 1
        local fin = node('Finally')(ln, b2)
        fin.n = FIN

        local evt = '$fin_'..FIN
        local awt = node('AwaitInt')(ln, node('Var')(ln, evt), true)
        b1[#b1+1] = node('EmitInt')(ln, node('Var')(ln, evt))

        local blk = node('Block')(ln,
                node('ParAnd')(ln,
                    b1,
                    node('BlockN')(ln, awt, fin)))
        blk.fin = fin
        return blk
    end,

    If = function (ln, ...)
        local t = { ... }
        local _else = t[#t]
        for i=#t-1, 1, -2 do
            local c, b = t[i-1], t[i]
            _else = node('If')(ln, c, b, _else)
        end
        return _else
    end,

    Break = node('Break'),
    
    Loop  = function (ln, _i, _j, blk)
        if not _i then
            return node('Loop')(ln, blk)
        end

        -- Define loop counter type
--print("ast::Loop: _j", _j[1].tag,_j[1][1])
--print(print_r(_AST,"ast::Loop: _AST"))
--print(print_r(_j,"ast::Loop: _j"))
        if _j and _j[1].tag=='CONST' then -- Var type is not defined yet here
          ctype = _TP.getConstType(_j[1][1],ln,true)
        elseif _j and _j[1].tag=='Var' then
--print("ast::Loop: _j", _j[1].tag,_j[1][1])
          ctype = 'ulong'        
        else
          ctype = 'ulong'
        end

        local i = function() return EXP(node('Var')(ln, _i)) end
        local dcl_i = node('Dcl_var')(ln, 'var', ctype, false, _i)
        dcl_i.read_only = true

        local set_i = node('SetExp')(ln, i(),
                                        EXP(node('CONST')(ln, '0')))

--        local nxt_i = node('SetExp')(ln, i(),
--                        EXP(node('Op2_+')(ln, '+', i(),
--                                node('CONST')(ln,'1'))))

        local nxt_i = node('Op_var')(ln, 'inc', node('Var')(ln, _i))


        if not _j then
            return node('Block')(ln, dcl_i, set_i,
                                    node('Loop')(ln,node('BlockN')(ln, blk, nxt_i)))
        end

        local j_name = '__'.._i..'_'.. string.sub(tostring(blk),8)
        local j = function() return EXP(node('Var')(ln, j_name)) end
        local dcl_j = node('Dcl_var')(ln, 'var', ctype, false, j_name)
        local set_j = node('SetExp')(ln, j(), _j)

        local cmp = EXP(node('Op2_>=')(ln, '>=', i(), j()))

        local loop = node('Loop')(ln,
            node('If')(ln, cmp,
                node('Break')(ln),
                node('BlockN')(ln, blk, nxt_i)))
        loop.isBounded = true
        loop[1].isBounded = true    -- remind that the If is "artificial"
        loop.isFor = true
        loop[1][1].isFor = true

        return node('Block')(ln,
                dcl_i, set_i,
                dcl_j, set_j,
                loop)
    end,

--    Pause = node('Pause'),

    AwaitExt = node('AwaitExt'),
    AwaitInt = node('AwaitInt'),
    AwaitN   = node('AwaitN'),
    AwaitT   = node('AwaitT'),

    EmitExtE = node('EmitExtE'),
    EmitExtS = node('EmitExtS'),
    EmitT    = node('EmitT'),
    EmitInt  = node('EmitInt'),

--    _Dcl_c = function (ln, mod, ...)
--        local ret = {}
--        local t = { ... }
--        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
--            ret[#ret+1] = node('Dcl_c')(ln, mod, t[i], t[i+1], t[i+2])
--        end
--        return unpack(ret)
--    end,

    Dcl_det = node('Dcl_det'),

    _Dcl_var = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_var')(ln, pre, tp, dim, t[i])
            if t[i+1] then
                ret[#ret+1] = C._Set(ln,
                                EXP(node('Var')(ln,t[i])),  -- var
                                t[i+1],                     -- op
                                t[i+2],                     -- tag
                                t[i+3])                     -- exp
            end
        end
        return unpack(ret)
    end,

    _Dcl_regt   = function(...)
--print('ast::_Dcl_regt',...)
      return node('Dcl_regt')(...)
    end,

    _Dcl_packet   = function(...)
--print('ast::_Dcl_packet',...)
      return node('Dcl_packet')(...)
    end,

    _Dcl_pktype   = function(...)
--print('ast::_Dcl_regsubt',...)
      return node('Dcl_pktype')(...)
    end,

    _Dcl_field = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 1 do
            ret[#ret+1] = node('Dcl_field')(ln, pre, tp, dim, t[i])
--print('ast::_Dcl_field:',i..'/'..#t,ln, pre, tp, dim,t[i],t[i+1])
        end
        return unpack(ret)
    end,

    _Dcl_payfield = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 1 do
            ret[#ret+1] = node('Dcl_field')(ln, pre, tp, dim, t[i])
--print('ast::_Dcl_field:',i..'/'..#t,ln, pre, tp, dim,t[i],t[i+1])
        end
        return unpack(ret)
    end,
        
    -- TODO: unify with _Dcl_var
    _Dcl_int = function (ln, pre, tp, dim, ...)
        local ret = {}
        local t = { ... }
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_int')(ln, pre, tp, dim, t[i])
            if t[i+1] then
                ret[#ret+1] = C._Set(ln,
                                EXP(node('Var')(ln,t[i])),  -- var
                                t[i+1],                     -- op
                                t[i+2],                     -- tag
                                t[i+3])                     -- exp
            end
        end
        return unpack(ret)
    end,

    _Set = function (ln, e1, op, tag, e2)
        return node(tag)(ln, e1, e2, op==':=')
    end,

    _Dcl_ext = function (ln, dir, mod, retTp, name, argTp, id)
            return node('Dcl_ext')(ln, dir, mod, retTp, name, argTp, id)
    end,

    _Dcl_func = function (ln, op, mod, tp,id,...)
--print("ast::_Dcl_func:",ln,op,mod, tp,id)
        local args = {}
        local t = { ... }
        for i=1, #t-1 do
          args[i]=t[i]
        end
        return node('Dcl_func')(ln, op, mod, tp,id, args,t[#t])
    end,

--    CallStmt = node('CallStmt'),

    LExp = node('LExp'),
    Exp = node('Exp'),
    _Exp = function (ln, ...)
        local v1, v2, v3, v4 = ...
        if not v2 then          -- ******************** single value
            return v1
        elseif v1==true then    -- ******************** unary expression
--print("ast::_Exp1:", v2)
            -- v1=true, v2=op, v3=exp
            local op = v2
            if not (op=='not' or op=='&' or op=='-'
                 or op=='+' or op=='~' or op=='*') then
                op = 'cast'
            end
--print("ast::Exp: op=",op)
            return node('Op1_'..op)(ln, v2,C._Exp(ln, select(3,...)))
        else                    -- ******************** binary expression
--print("ast::_Exp2:  obj-", v1.tag, v2, v3.tag)
--print("ast::_Exp2: type-", v1[2], v2, v3[2])
--print("ast::_Exp2:  val-", v1[1], v2, v3[1])
            -- v1=e1, v2=op, v3=e2, v4=?
            if v1.tag=='CONST' and v3.tag=='CONST' then
              local boolT = {}; boolT[true]=1; boolT[false]=0;
              if (v2=='+' or v2=='-' or v2=='/' or v2=='*' or v2 == '%') then
                if (v2=='/' or v2=='%') and (v3[1]*1)==0 then
                  ASR(false,v3,'division by zero.')
                else
                  loadstring('newConst = '..v1[1]..' '..v2..' '..v3[1])()
                end
                return C._Exp(ln,
                        node('CONST')(ln, newConst),select(4,...)
                  )
              elseif (v2=='==' or v2=='!=' or v2=='>' or v2=='<' or v2 == '>=' or v2 == '<=') then
                local relat_op = string.gsub(v2,'!','~')
                loadstring('relat_result = '..v1[1]..' '.. relat_op ..' '..v3[1])()
                return C._Exp(ln,
                        node('CONST')(ln, boolT[relat_result]),select(4,...)
                  )
              elseif (v2=='<<') then
                  if (v1[2]=='float' or v3[2]=='float') then ASR(false,v3,'Invalid float operation.'); end
                  loadstring('newConst = '.. v1[1].. ' * math.pow( 2,'..v3[1] ..')')()
                  local newConst2 = tonumber(string.format("0x%08x",newConst))
--print("ast::_Exp: `<<´:",string.format("0x%08x",newConst),tonumber(string.format("0x%08x",newConst)))
                  return C._Exp(ln,
                          node('CONST')(ln, newConst2),
                          select(4,...)
                    )
              elseif (v2=='>>') then
                  if (v1[2]=='float' or v3[2]=='float') then ASR(false,v3,'Invalid float operation.'); end
                  loadstring('newConst = '.. v1[1].. ' / math.pow( 2,'..v3[1] ..')')()
                  return C._Exp(ln,
                          node('CONST')(ln, newConst),
                          select(4,...)
                    )
              elseif (v2=='and') then
                  if (v1[2]=='float' or v3[2]=='float') then ASR(false,v3,'Invalid float operation.'); end
                  newConst = boolT[tonumber(v1[1])~=0 and tonumber(v3[1])~=0]  
--print("ast::_Exp: `and´:",tonumber(v1[1]),tonumber(v3[1]),tonumber(v1[1])~=0 and tonumber(v3[1])~=0,newConst)
                  return C._Exp(ln,
                          node('CONST')(ln, math.floor(newConst)),
                          select(4,...)
                    )
              elseif (v2=='or') then
                  if (v1[2]=='float' or v3[2]=='float') then ASR(false,v3,'Invalid float operation.'); end
                  newConst = boolT[tonumber(v1[1])~=0 or tonumber(v3[1])~=0]  
--print("ast::_Exp: `or´:",tonumber(v1[1]),tonumber(v3[1]),tonumber(v1[1])~=0 or tonumber(v3[1])~=0,newConst)
                  return C._Exp(ln,
                          node('CONST')(ln, math.floor(newConst)),
                          select(4,...)
                    )
              else
                  return C._Exp(ln,
                      node('Op2_'..v2)(ln, v2, v1, v3),
                      select(4,...)
                  )
              end
            else
                return C._Exp(ln,
                    node('Op2_'..v2)(ln, v2, v1, v3),
                    select(4,...)
                )
            end
        end
    end,

    ExpList  = node('ExpList'),
    Op_var   = node('Op_var'),

    Func     = node('Func'),   

    Call     = function(ln,func)
      local fname,args = unpack(func)
--print("ast::Call:",func[1],func[2])    
        return node('Call')(ln,EXP(node('Var')(ln,'$ret')),node('Func')(ln,fname,args))
    end,   
    
    Var      = node('Var'),
    Ext      = node('Ext'),
--    C        = node('C'),
    SIZEOF   = node('SIZEOF'),

--    CONST    = node('CONST'),
    CONST    = function(ln,constVal)
--print("ast::CONST:",constVal)
      local constTp=_TP.getConstType(constVal,nil,true)
      return node('CONST')(ln,constVal,constTp)
    end,


    WCLOCKK  = node('WCLOCKK'),
    WCLOCKE  = node('WCLOCKE'),
--    STRING   = node('STRING'),
    NULL     = node('NULL'),
}

local function i2l (v)
    return _I2L[v]
end

for rule, f in pairs(C) do
    _GG[rule] = (m.Cp()/i2l) * _GG[rule] / f
end

for i=1, 12 do
    local tag = '_'..i
    _GG[tag] = (m.Cp()/i2l) * _GG[tag] / C._Exp
end

_GG = m.P(_GG):match(_STR)

-------------------------------------------------------------------------------

function PSE_cndor (me)
    local cnd
    for pse in _AST.iter('Pause') do
        local int = unpack(pse)
        int = EXP(node('Var')(me.ln,int[1]))
        cnd = cnd and EXP(node('Op2_or')(me.ln, 'or', cnd, int))
            or int
    end
    return cnd
end

function PSE_paror (me)
    local par = node('ParOr')(me.ln)
    for pse in _AST.iter('Pause') do
        local int = unpack(pse)
        par[#par+1] = node('AwaitInt')(me.ln, node('Var')(me.ln,int[1]))
    end
    return par
end

F = {
    Block_pre = function (me)
        me.par = _AST.iter'Block'()
    end,

    SetBlock_pre = function (me)
        me.blk = _AST.iter'Block'()
    end,
    _Return = function (me)
        local set = _AST.iter'SetBlock'()
        local e2 = unpack(me)
        local var = node('Var')(me.ln,set[1][1][1])
        var.blk = set.blk
        var.ret = true

        local blk = node('BlockN')(me.ln)
        blk[#blk+1] = node('SetExp')(me.ln, EXP(var), e2, set[3])

        -- Finalizer
        for i=1, FIN do
            blk[#blk+1] = node('EmitInt')(blk.ln,
                            node('Var')(blk.ln, '$fin_'..i))
        end

        blk[#blk+1] = node('Return')(me.ln)
        return blk
    end,

    SetAwait = function (me)
        local _, awt = unpack(me)
        awt.ret = awt.ret or awt
    end,

    AwaitExt = 'AwaitInt',
    AwaitInt = function (me)
        if not _AST.iter('Pause')() or
           string.find(me[1][1], '$fin_') then
            return
        end
        local cnd = PSE_cndor(me)
        cnd = EXP(node('Op1_not')(me.ln, 'not', cnd))
        local n = node('Loop')(me.ln,
                    node('BlockN')(me.ln,
                        me,
                        node('If')(me.ln, cnd, node('Break')(me.ln))))
        n.ret = me
        return n
--[[
    loop do
        await X;
        if not (evt1 or .. or evtN) then
            break;
        end
    end
]]
    end,

    AwaitT = function (me)
        if not _AST.iter('Pause')() then
            return me
        end
        local ln = me.ln

        local DT = unpack(me)
        me[1] = node('WCLOCKE')(ln, EXP(node('Var')(ln,'$dt')), 'us')

        local REM = node('WCLOCKR')(ln)
        REM.awt = me

        local L1 = node('Loop')(ln,
                    node('BlockN')(ln,
                        PSE_paror(me),
                        node('If')(ln, PSE_cndor(me),
                            node('BlockN')(ln,
                                node('SetExp')(ln,
                                    EXP(node('Var')(ln,'$dt')),
                                    REM),
                                node('Break')(ln)))))

        local L2 = node('Loop')(ln,
                    node('BlockN')(ln,
                        PSE_paror(me),
                        node('If')(ln,
                            EXP(node('Op1_not')(ln,'not',PSE_cndor(me))),
                            node('Break')(ln))))

        local L0 = node('Loop')(ln,
                    node('BlockN')(ln,
                        node('ParOr')(ln,
                            node('BlockN')(ln, me, node('Break')(ln)),
                            L1),
                        L2))

        local blk = node('Block')(ln,
                        node('Dcl_var')(ln, false, 'u32',  false, '$dt'),
                        node('SetExp')(ln,
                            EXP(node('Var')(ln,'$dt')),
                            DT),
                        L0)
        blk.par = _AST.iter('Block')()
        blk.ret = me
        return blk
--[[
    u32 $dt = e1;

    -- LOOP 0
    loop do
        par/or do
            await ($dt);
            break;
        with
            -- LOOP 1
            loop do
                par/or do
                    await pse1;
                with
                    await pseN;
                end
                if pse1 or pseN then
                    $dt = TMR.togo;
                    break;
                end
            end
        end

        -- LOOP 2
        loop do
            par/or do
                await pse1;
            with
                await pseN;
            end
            if not(pse1 or pseN) then
                break;
            end
        end
    end
]]
    end,

    -- Finalizer
    ParOr = function (me)
        for i, sub in ipairs(me) do
            for i=1, FIN do
                sub[#sub+1] = node('EmitInt')(sub.ln,
                                node('Var')(sub.ln, '$fin_'..i))
            end
        end
    end,
    Break = function (me)
        local blk = node('BlockN')(me.ln)
        for i=1, FIN do
            blk[#blk+1] = node('EmitInt')(blk.ln,
                            node('Var')(blk.ln, '$fin_'..i))
        end
        blk[#blk+1] = me
        return blk
    end,

}

_AST.visit(F)

end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

local function ceil (v)
    local w = 2 --_OPTS.tp_word
    while true do
        if v % w == 0 then
            return v
        else
            v = v + 1
        end
    end
end


_ENV = {
    exts = {}, -- List of External Events
    ints = {}, -- List of Internal Events: {id=id,ln=ln}
    c = {
        void = 0,

        ubyte=1, ushort=2, ulong=4,
        byte=1, short=2, long=4,
        float=4,
        payload=1,

        pointer   = 2, --_OPTS.tp_pointer,
        tceu_noff = 2, --_OPTS.tp_off,
        tceu_nlbl = 2, --_OPTS.tp_lbl,
--        tceu_wclock = ceil(4 + _OPTS.tp_lbl + 2       -- TODO: perda de memoria :: +2 to adjust micaz struct size
--                          + (_OPTS.analysis_run and 4 or 0)),
        tceu_wclock = ceil(4 + 2 + 2),       -- TODO: perda de memoria :: +2 to adjust micaz struct size
                          
    },
    calls = {},     -- { _printf=true, _myf=true, ... }

    packets = {},
    n_asyncs  = 0,
    n_wclocks = 0,
    n_emits   = 0,
    awaits    = {},
    gate0     = 0; --afb
    n_ins     = 0; --afb
    n_outs     = 0; --afb
    n_ins_active = 0; --afb	
    vm_version = '0';
    extOut_nArgs={},
    func_nArgs={},
    dets  = {},
}

for k, v in pairs(_ENV.c) do
    _ENV.c[k] = { tag='type', id=k, len=v }
end

function newvar (me, blk, pre, tp, dim, id, read_only)

    -- Cheks if name is used by internal event
    for k,evt in ipairs(_ENV.ints) do
--print("env::newvar():",k,evt.id,evt.ln)
      ASR(not(evt.id==id), me,'event "'..id..'" was previously declared at line '..evt.ln)
    end
    -- Cheks for context definitions
    for stmt in _AST.iter() do
        if stmt.tag == 'Async' then
            break
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                ASR(not(var.id==id and blk==stmt ), me,'var "'..id..'" was defined for same context at line '..var.ln)
                WRN(var.id~=id, me,'declaration of "'..id..'" hides the one at line '..var.ln)
            end
        end
    end

    local tp_raw = _TP.raw(tp)
    local c = _ENV.c[tp_raw]
    local isEvt = (pre ~= 'var')
--print("env::newvar:",id,"pre=",pre,"isEvt=",isEvt)

    ASR(c and c.tag=='type', me, 'undeclared type `'..tp_raw..'´')
    ASR(_TP.deref(tp) or (not c) or (tp=='void' and isEvt) or c.len>0, me,
        'cannot instantiate type "'..tp..'"')
    ASR((not dim) or dim>0, me, 'invalid array dimension')

    if isEvt then
      _ENV.ints[id] = {id=id,ln=me.ln}
      _ENV.ints[#_ENV.ints+1] = {id=id,ln=me.ln}
    end

    local nvar = {}
    if not(_TP.deref(tp)) and c.fields then
      local z1 = _TP.getAuxTag(tp,dim)
      local var = {
          ln    = me.ln,
          id    = id,
          tp    = (dim and tp..'*') or tp,
          blk   = blk,
          pre   = pre,
          isEvt = isEvt,
          arr   = dim,
          n_awaits = 0,
          fields ={},
          auxtag = z1.auxtag,
          supertp = c.supertp
      }
--print("env::newvar:",id,tp,c.supertp)
      blk.vars[#blk.vars+1] = var
      nvar[#nvar+1]=var
--print(print_r(c.fields,'env::newvar: c.fields'))
      for k, v in ipairs(c.fields) do
        local z1 = _TP.getAuxTag(tp,dim)
        local var = {
            ln    = me.ln,
            id    = id..'.'..v.id,
            field_id    = v.id,
            tp    = (v.dim and v.tp..'*') or v.tp,
            --blk   = blk,
            pre   = v.pre,
            isEvt = false,
            arr   = v.dim,
            lval  = true,
            n_awaits = 0,
            auxtag = z1.auxtag,
        }
        blk.vars[#blk.vars].fields[#blk.vars[#blk.vars].fields+1] = var
        blk.vars[#blk.vars].fields[v.id] = var
        --nvar[#nvar+1]=var
      end
    else
        local z1 = _TP.getAuxTag(tp,dim)
        local var = {
            ln    = me.ln,
            id    = id,
            tp    = (dim and tp..'*') or tp,
            blk   = blk,
            pre   = pre,
            isEvt = isEvt,
            arr   = dim,
            n_awaits = 0,
            auxtag = z1.auxtag,
            read_only = read_only,
        }
        blk.vars[#blk.vars+1] = var
        nvar[#nvar+1]=var
    end
    return nvar
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

F = {

    Block_pos = function (me)
--print('env::Block_pos:',me.tag,#me.vars)
        for _, var in ipairs(me.vars) do
--print('env::Block_pos: var:',var.id,var.ln,var.auxtag,var.firstOper)
          ASR(not(var.auxtag=='pointer' and var.firstOper == 'Exp'),{ln=var.firstOperLn},'pointer "'.. var.id ..'" not initialized at this point.')
        end
    end,

    Block_pre = function (me)
        me.vars = {}
        local async = _AST.iter()()
        if async.tag == 'Async' then
            local vars, blk = unpack(async)
            if vars then
                for _, n in ipairs(vars) do
                    local var = n[1].var
                    ASR(not var.arr, vars, 'invalid argument')
                    n.new = newvar(vars, blk, false, var.tp, nil, var.id)
                end
            end
        end
    end,

    CfgBlk = function (me)
        local cfgParams = me[1]
        local name, n1, n2, n3 = unpack(cfgParams)
--print("env::CfgBlk:", unpack(cfgParams)) 
        _ENV.vm_name = name
        _ENV.vm_version = string.format("%03d.%03d.%03d",(n1 or 0),(n2 or 0),(n3 or 0))
        _ENV.motes_max_size = {}
        for i=5,#cfgParams,2 do
          _ENV.motes_max_size[cfgParams[i]]=cfgParams[i+1]
        end
    end,
    
    Dcl_ext = function (me)
        local dir, mod, retTp, id, argTp, idx = unpack(me)
--print(print_r(_ENV.c,"ENV.c"))
--        ASR(tp=='void' or _TP.deref(tp)) or _ENV.c[tp],me, 'invalid event type')
  
--print("env::Dcl_ext:",id, tp, _TP.isBasicType(tp),_TP.deref(tp), (_TP.isBasicType(tp) or  _TP.deref(tp)) )
--        ASR( (_TP.isBasicType(tp) or  _TP.deref(tp)),me, 'invalid event type')
        local tp,idAux
        idAux = id .. (( (dir=='input' and argTp~='void') and '()') or '')
        tp = (dir=='output' and argTp) or retTp
--print("env::Dcl_ext:", dir, retTp, id, argTp, idx, '|', idAux,tp)

        for k,val in ipairs(_ENV.exts) do
          if val.pre==dir then 
            ASR(not (val.id==idAux), me, 'event "'..idAux..'" is already declared at line '.. (val.ln or 0))
            ASR(not (val.idx==idx), me, dir..' event numeric id "'..idx..'" is already in use at line '.. (val.ln or 0))
          end
        end
        ASR(_ENV.c[tp] or _ENV.packets[tp],me,'type/packet not defined')
        ASR(idx<255, me, dir..' event numeric id must be less than 255')
        me.ext = {
            ln    = me.ln,
            id    = idAux,
            n     = #_ENV.exts,
            tp    = tp,
            pre   = dir,
            isEvt = true,
            idx   = idx,
            inArg = (dir=='input' and argTp~='void'),
            mod = mod
        }
        _ENV.exts[idAux] = me.ext
        _ENV.exts[#_ENV.exts+1] = me.ext
        -- Force 0 or 1 args -- void or non void
        if dir == 'output' then 
          _ENV.extOut_nArgs[idx] = ((tp=='void') and 0) or 1
        end
    end,

    Dcl_int = 'Dcl_var',
    Dcl_var = function (me)
        local pre, tp, dim, id, exp = unpack(me)
        ASR(_ENV.c[tp] or _ENV.c[_TP.deref(tp)],me,'invalid type')
        local z =  _TP.getAuxTag(tp,dim)
        ASR( z.lvl <= 1, me,'invalid pointer to pointer type')
--print("env::Dcl_var:",tp,dim,id, _TP.isBasicType(_TP.deref(tp) or tp),(not dim) or  _TP.isBasicType(_TP.deref(tp) or tp),me.read_only)
        ASR( (not dim) or  _TP.isBasicType(_TP.deref(tp) or tp),me,'Arrays can have only basic types')
        me.var = newvar(me, _AST.iter'Block'(), pre, tp, dim, id,me.read_only)
    end,

    Dcl_regt = function(me)
--print(print_r(me,"env::Dcl_regt: me"))
      local RegId = me[1]
      ASR(not _ENV.c[RegId],me,'Register type `'.. RegId ..'´ is already declared as Register.')
      ASR(not _ENV.packets[RegId],me,'Register type `'.. RegId ..'´ is already declared as Packet.')
      local RegFields= {}
      local memsize = 0
      local offset = 0
      local lastSize = 0
      for i=2, #me do
        offset = offset + lastSize
        local var = me[i]
--print('env::Dcl_regt: var',var)
        local  pre, tp, dim, id = unpack(var)
        ASR(not RegFields[id],var,'duplicated field id `'..id ..'´')
        local len = ((dim and dim*_ENV.c[var[2]].len) or _ENV.c[var[2]].len)
        lastSize = len
        RegFields[id]={pre=pre,tp=tp,dim=dim,id=id,len=len,offset=offset}
        RegFields[i-1]=RegFields[id]
--print('env::Dcl_regt:',tp,id)
        memsize = memsize + len
      end
      _ENV.c[RegId] = { tag='type', id=RegId, len=memsize , fields=RegFields}
    end,

    Dcl_packet = function(me)
--print(print_r(me,"env::Dcl_packet: me"))
      local RegId = me[1]
      ASR(not _ENV.packets[RegId],me,'Packet type `'.. RegId ..'´ is already declared as Packet.')
      ASR(not _ENV.c[RegId],me,'Packet type `'.. RegId ..'´ is already declared as Register.')
      local RegFields= {}
      local memsize = 0
      local offset = 0
      local lastSize = 0
      local payloadCount=0
      for i=2, #me do
        offset = offset + lastSize
        local var = me[i]
--print('env::Dcl_regt: var',var)
        local  pre, tp, dim, id = unpack(var)
        ASR(not RegFields[id],var,'duplicated field id `'..id ..'´')
        local len = ((dim and dim*_ENV.c[var[2]].len) or _ENV.c[var[2]].len)
        lastSize = len
        RegFields[id]={pre=pre,tp=tp,dim=dim,id=id,len=len,offset=offset}
        RegFields[i-1]=RegFields[id]
--print('env::Dcl_regt:',tp,id)
        memsize = memsize + len
        if tp == 'payload' then payloadCount = payloadCount + 1 end
      end
      ASR(payloadCount == 1, me,'packet needs exactly one `payload´ type, it received '..payloadCount)
      _ENV.packets[RegId] = { tag='type', id=RegId, len=memsize , fields=RegFields}
    end,

    Dcl_pktype = function(me)
--print(print_r(me,"env::Dcl_pktype: me"))
      local RegId = me[1]
      local packet = me[2]
      ASR(not _ENV.c[RegId],me,'Register type `'.. RegId ..'´ is already declared.')
      ASR(_ENV.packets[packet],me,'packet type `'.. packet ..'´ is not defined.')
      local RegFields= {}
      local memsize = 0
      local offset = 0
      local lastSize = 0
      local pos = 1
--print('env::Dcl_pktype: subtype:supertype',RegId,packet,_ENV.packets[packet].fields)
--print(print_r(RegFields,"env::Dcl_pktype: RegFields"))

      for x, field in ipairs(_ENV.packets[packet].fields) do
        if field.tp ~= 'payload' then
          RegFields[field.id] = field
          RegFields[pos] = field
          pos = pos + 1
        else
          offset = field.offset
          lastSize=0
          for i=3, #me do
            offset = offset + lastSize
            local var = me[i]
--print('env::Dcl_pktype: var',var)
            local  pre, tp, dim, id = unpack(var)
            ASR(not RegFields[id],var,'duplicated field id `'..id ..'´')
            local len = ((dim and dim*_ENV.c[var[2]].len) or _ENV.c[var[2]].len)
            lastSize = len
            RegFields[id]={pre=pre,tp=tp,dim=dim,id=id,len=len,offset=offset}
            RegFields[pos]=RegFields[id]
            pos = pos + 1
--print('env::Dcl_pktype:',tp,id)
            memsize = memsize + len
            ASR(memsize<=field.len,me,'subtype size '.. memsize ..' is  greater than payload size '..field.len)
          end
          if memsize < field.len then -- complete remain bytes
            local dim = (field.len - memsize)
            RegFields._remain={pre=field.pre,tp='ubyte',dim=dim,id='_remain',len=(dim*1),offset=offset + lastSize}
            RegFields[pos]=RegFields._remain
            pos = pos + 1
          end
        end
      end
--print(print_r(RegFields,"env::Dcl_pktype: RegFields"))
      _ENV.c[RegId] = { tag='type', supertp=packet, id=RegId, len=_ENV.packets[packet].len , fields=RegFields}
    end,

    Dcl_func = function (me)
       local op,mod,tp,id,args,idx = unpack(me)
--print("env::Dcl_func:", op, mod, tp, id, #args, idx)
--print("env::Dcl_func:", tp=='void', _TP.deref(tp) , _ENV.c[tp]~=nil)
        ASR(not(tp=='void' or _TP.deref(tp)) and _ENV.c[tp],me, 'invalid function type "'..tp..'"')
        for k,val in ipairs(_ENV.exts) do
          if val.pre=='func' then 
            ASR(not (val.id==id), me, 'function "'..id..'" is already declared at line '.. (val.ln or 0))
            ASR(not (val.idx==idx), me, ' function numeric id "'..idx..'" is already in use at line '.. (val.ln or 0))
          end
        end
        ASR(idx<255, me,' function event numeric id must be less than 255')

        for k,tp in ipairs(args) do
--print("env::Dcl_func: arg:",k, tp, (_TP.isBasicType(tp) or _TP.isBasicType(_TP.deref(tp))) or _TP.deref(tp))
          ASR(not(tp=='void') and (_ENV.c[tp] or _ENV.c[_TP.deref(tp)] or _ENV.packets[tp]) ,me, '<'..tp..'> in position '..k..' is invalid argument type in function <'..id..'>')
          ASR((_TP.isBasicType(tp) or _TP.isBasicType(_TP.deref(tp))) or not _TP.deref(tp),me, 'register <'..tp..'> in position '..k..' in function <'..id..'> can not be a pointer.')
        end
        me.ext = {
            ln    = me.ln,
            mod   = mod,
            id    = id,
            n     = #_ENV.exts,
            tp    = tp,
            pre   = 'func',
            isEvt = false,
            args  = args,
            idx   = idx,
        }
        _ENV.exts[#_ENV.exts+1] = me.ext
        _ENV.exts[id] = me.ext
        _ENV.func_nArgs[idx] = #args
    end,

    Ext = function (me)
        local id = unpack(me)
--print("env::Ext:",id,_ENV.exts[id], _ENV.exts[id .. '()'])
        me.ext = ASR(_ENV.exts[id] or _ENV.exts[id .. '()'],me, 'event "'..id..'" is not declared') -- moved to AwaitExt
    end,

    Func = function (me)
--print("env::Func:",me[1],me.blk)
--print(print_r(me,"env::Func: me"))
        local id = unpack(me)
        ASR(_ENV.exts[id],me, 'function "'..id..'" is not declared')
        me.ext = _ENV.exts[id]
        me.tp = _ENV.exts[id].tp
        
        if not (me.ext and (me.ext.mod=='pure' or me.ext.mod=='nohold')) then
            for pos, tp in ipairs(me.ext.args) do
                if _TP.deref(tp) or not _TP.isBasicType(tp)  then
                    local blk = me.blk or _AST.iter('Block')()
                    ASR(blk.fin, me,
                        'block at line '..blk.ln..' must contain `finally´')
                end
            end
        end

    end,


   
    Var = function (me)
        local id, idField = unpack(me)
--print("env::Var:",id)
--print(print_r(me,"env::Var: me"))
        local blk = me.blk or _AST.iter('Block')()
--print(print_r(blk.vars,"env::Var: blk.vars"))
        while blk do
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
--print("env::Var:",id,me.read_only)
--print(print_r(var,"env::Var: var"))
                  me.var  = var
                  me.tp   = var.tp
                  me.lval = (not var.arr)
                  me.fst  = var
                  me.arr = var.arr
                  me.auxtag = var.auxtag
                  me.supertp = var.supertp
                  me.ref = me
                  me.read_only = var.read_only
                  return
                end
            end
            blk = blk.par
        end
        ASR(false, me, 'variable/event/function "'..id..'" is not declared')
    end,

    Dcl_c = function (me)
        local mod, tag, id, len = unpack(me)
        _ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
    end,

    Dcl_det = function (me)                 -- TODO: verify in _ENV.c
        local id1 = det2id(me[1])
        ASR(_ENV.exts[id1],me,'event or function `' .. id1 .. '´ was not found.')
        local t1 = _ENV.dets[id1] or {}
        _ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])
            ASR(_ENV.exts[id2],me,'event or function `' .. id2 .. '´ was not found.')
            local t2 = _ENV.dets[id2] or {}
            _ENV.dets[id2] = t2
            t1[id2] = true
            t2[id1] = true
        end
    end,

    Pause = function (me)
        local exp, _ = unpack(me)
        ASR(exp.var.isEvt, me, 'event "'..exp.var.id..'" is not declared')
        ASR(_TP.isNumeric(exp.var.tp), me, 'event type must be numeric')
    end,

    AwaitExt = function (me)
        local e1,e2 = unpack(me)
        local idAux = e1[1] .. ((e2 and '()') or '')
--print("env::AwaitExt:",idAux..'|'..((e2 and '()') or '')..'|')
        me[1].ext =  _ENV.exts[idAux] or me[1].ext -- Try to overhide value got in 'Exp'
--print("env::AwaitExt:",e1.ext.id,e1.ext.idx, e1.ext.pre, e2, (e2 and e2.tag),(e2 and e2.tp),(e2 and e2[1].tag))
        ASR(e1.ext.pre == 'input',me,'await expect an input event, a time expression, or a var event.')

        if e2 then
          ASR(_ENV.exts[idAux],me,'event '.. e1[1] ..' doesn´t expect any argument.')
          local err,cast = _TP.tpCompat('ubyte',e2.tp,nil,nil)
          ASR(not err,me,'type/size incompatibility: '.. 'ubyte' ..' <--> '.. e2.tp..'')
          WRN(not cast,me, 'Automatic casting from `'.. e2.tp ..'´ to `' .. 'ubyte' ..'´. ')
        else
          ASR(_ENV.exts[idAux] ,me,'event '.. e1[1] ..' expect an `ubyte/byte´ argument.')
        end
        
        me.gte = (_ENV.awaits[e1.ext] or 0)
        _ENV.awaits[e1.ext] = (_ENV.awaits[e1.ext] or 0) + 1
    end,

    AwaitInt = function (me)
        local exp,_ = unpack(me)
        local var = exp.var
        ASR(var and var.isEvt, me,'event "'..(var and var.id or '?')..'" is not declared')
        me.gte = var.n_awaits
        var.n_awaits = var.n_awaits + 1
        me.tp = var.tp
        me.id = var.id
    end,

    AwaitT = function (me)
        me.gte = _ENV.n_wclocks
        _ENV.n_wclocks = _ENV.n_wclocks + 1
    end,

    EmitInt = function (me)
        local e1, e2 = unpack(me)
        ASR(e1.var.isEvt, me, 'event "'..e1.var.id..'" is not declared')
        if (e2) then
--print("env::EmitInt:",e1.var.tp,e2.tp)
          err, cast,_,_, len1, len2 = _TP.tpCompat(e1.var.tp,e2.tp)
          ASR(not err,me,'type/size incompatibility: '.. e1.var.tp..'/'..len1 ..' <--> '.. e2.tp..'/'..len2..'')
          WRN(not cast,me, 'Automatic casting from `'.. e2.tp ..'´ to `' .. e1.var.tp ..'´. ')
        end
        me.gte = _ENV.n_emits
        _ENV.n_emits = _ENV.n_emits + 2     -- (cnt/awk)
    end,

    EmitExtS = function (me)
        local e1, _ = unpack(me)
        ASR(e1.ext.pre=='output', me, 'emit expect an output event or a var event.')
        if e1.ext.pre=='output' then
            F.EmitExtE(me)
        end
    end,
    EmitExtE = function (me)
        local e1, e2 = unpack(me)
        ASR(e1.ext.pre=='output', me, 'invalid input `emit´')
        me.tp = e1.ext.tp

        if e2 then
          err, cast,_,_,len1,len2 = _TP.tpCompat((e1.ext.supertp or e1.ext.tp),(e2.supertp or e2.tp),nil,e2.arr)
          ASR(not err,me,'type/size incompatibility: '.. e1.ext.tp..'/'..len1 ..' <--> '.. e2.tp..'/'..len2..'')
          WRN(not cast,me, 'Automatic casting from `'.. e2.tp ..'´ to `' .. e1.ext.tp ..'´. ')
        else
            ASR(e1.ext.tp=='void',me, "missing parameters on `emit´")
        end
    end,

    Async = function (me)
        me.gte = _ENV.n_asyncs
        _ENV.n_asyncs = _ENV.n_asyncs + 1
    end,

    -- gates for cleaning
    ParOr_pre = function (me)
        me.gtes = {
            asyncs  = { _ENV.n_asyncs,  nil },
            wclocks = { _ENV.n_wclocks, nil },
            emits   = { _ENV.n_emits,   nil },
        }

        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                me.gtes[ext] = { _ENV.awaits[ext] or 0, nil }
            end
        end

        for blk in _AST.iter'Block' do
            for _, var in ipairs(blk.vars) do
                if var.isEvt then
                    me.gtes[var] = { var.n_awaits, nil }
                end
            end
        end
    end,
    ParOr = function (me)
        me.gtes.asyncs[2]  = _ENV.n_asyncs
        me.gtes.wclocks[2] = _ENV.n_wclocks
        me.gtes.emits[2]   = _ENV.n_emits

        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                local t = me.gtes[ext]
                if t then
                    t[2] = _ENV.awaits[ext] or 0
                end
            end
        end

        for blk in _AST.iter'Block' do
            for _, var in ipairs(blk.vars) do
                if var.isEvt then
                    me.gtes[var][2] = var.n_awaits
                end
            end
        end
    end,
    Loop_pre     = 'ParOr_pre',
    Loop         = 'ParOr',
    SetBlock_pre = 'ParOr_pre',
    SetBlock     = 'ParOr',

    --------------------------------------------------------------------------

    SetExp = function (me)
        local e1, e2, no_fin = unpack(me)
        e1 = e1 or _AST.iter'SetBlock'()[1]
--print('env::SetExp:',e1.tag,e2.tag, e1[1].tag, e2[1].tag, e1.lval,e1.tp,e2.tp,e1[1].arr,e2[1].arr,no_fin)
--        WRN(e1.lval and _TP.contains(e1.tp,e2.tp,true),me, 'invalid attribution: ['.. e1.tp ..'] can not contain [' .. e2.tp ..']')
          ASR(not (e1[1].tag=='CONST'),me,'constant at left side of attribution.')
          ASR(not (e1[1].tag=='Op1_&'),me,'VarAddr at left side of attribution.')

        local error, cast, tp1,tp2,len1,len2 = _TP.tpCompat((e1.supertp or e1.tp),(e2.supertp or e2.tp),e1[1].arr,e2[1].arr)
          ASR(not error,me,'type incompatibility: `'.. (e1.supertp or e1.tp) ..'´ <--> `'.. (e2.supertp or e2.tp) ..'´')
          WRN(not cast,me, 'Automatic casting from `'.. (e2.supertp or e2.tp) ..'´ to `' .. (e1.supertp or e1.tp) ..'´. ')

        if no_fin then
            return              -- no `finally´ required
        end

-- :: afb ::
-- Can't pass here, current function implementation only returns a non pointer integer type. 
-- If it changes, the below code must be reviewed.

--        if _TP.deref(e1.tp) then
--            local blk1 = (e1.fst=='_' and _AST.root) or e1.fst.blk
--            if e2.fst and e2.fst~='_' then
--                local blk2 = e2.fst.blk
--                ASR(blk2.fin or blk2.depth<=blk1.depth, me,
--                    'block at line '..blk2.ln..' must contain `finally´')
--                -- int a; pa=&a;    -- `a´ termination must consider `pa´
--            else
--                ASR(blk1.fin or e2[1].tag~='Op2_call' or e2[1].c.mod=='pure',
--                    me, 'block at line '..blk1.ln..' must contain `finally´')
--                -- int* pa = _f();   -- `pa´ termination must consider `_f´
--            end
--        end
    end,

    SetAwait = function (me)
        local e1, awt = unpack(me)
        ASR(e1.lval, me, 'invalid attribution: not a value')
        if awt.ret.tag == 'AwaitT' then
            ASR(_TP.isNumeric(e1.tp,true), me, 'invalid attribution: not a numeric value')
        else    -- AwaitInt / AwaitExt
            local evt = awt.ret[1].var or awt.ret[1].ext
--print("env::SetAwait:",e1.supertp, e1.tp)
            -- ASR(_TP.contains(e1.tp,evt.tp,true), me, 'invalid attribution: ['.. e1.tp ..'] can not contain [' .. evt.tp ..']')
            local error, cast, tp1,tp2,len1,len2 = _TP.tpCompat((e1.supertp or e1.tp),evt.tp,e1[1].arr,awt[1].arr)
            ASR(not error,me,'type/size incompatibility: '.. e1.tp..'/'..len1 ..' <--> '.. evt.tp..'/'..len2..'')
            WRN(not cast,me, 'Automatic casting from `'.. evt.tp ..'´ to `' .. e1.tp ..'´. ')
        end
        me.fst = awt.fst
    end,

    CallStmt = function (me)
        local call = unpack(me)
--print("env::CallStmt:",call[1].tag)
        ASR(call[1].tag == 'Op2_call', me, 'invalid statement')
    end,

    --------------------------------------------------------------------------

    LExp = function (me)
--print("env::LExp:",me.tag,me[1].auxtag,me[1].tag, me[1].arr, me[1][1],me[1].read_only)
--print(print_r(me,"env::Exp: me"))
--        ASR(not(me[1].tag=='Var' and (me[1].arr)),me,'missing array index for "'..me[1][1]..'".')
        ASR(not(me[1].read_only),me,'`'.. me[1][1] .. '´ is a read only variable')

        me.lval = me[1].lval
        me.tp   = me[1].tp
        me.fst  = me[1].fst
        me.supertp = me[1].supertp
    end,

    Exp = function (me)
--print("env::Exp:",me.tag,me[1].auxtag,me[1].tag,me[1][1],me[1].lval)
--print(print_r(me,"env::Exp: me"))
--        ASR(not(me[1].tag=='Var' and (me[1].arr)),me,'missing array index for "'..me[1][1]..'".')
        me.lval = me[1].lval
        me.tp   = me[1].tp
        me.fst  = me[1].fst
        me.supertp = me[1].supertp
    end,

--[[ -- C Calls are not used in Terra
    Op2_call = function (me)
        local _, f, exps = unpack(me)
--print("env::Op2_call:",f.tag)
        me.tp  = '_'
        me.fst = '_'
        if f.tag == 'C' then
            me.c = _ENV.c[ f[1] ]
            ASR(me.c.tag=='func', me,
                'C function "'..(f[1])..'" is not declared')
            me.fid = f[1]
        else
            me.fid = '$anon'
        end
        _ENV.calls[me.fid] = true
        ASR((not _OPTS.c_calls) or _OPTS.c_calls[me.fid],
            me, 'C calls are disabled')
        if not (me.c and (me.c.mod=='pure' or me.c.mod=='nohold')) then
            if me.org then
                error'oi'
            end
            for _, exp in ipairs(exps) do
                if _TP.deref(exp.tp) and exp.fst then
                    local blk = (exp.fst=='_' and _AST.root) or exp.fst.blk
                    ASR(blk.fin, me,
                        'block at line '..blk.ln..' must contain `finally´')
                    -- int* pa; _f(pa); -- `pa´ termination must consider `_f´
                end
            end
        end
    end,
--]]

    Op2_idx = function (me)
--print(print_r(me,"env:Op2_idx: me"))
--print("env::Op2_idx:",me[2][1],me[2].tag,me[2].tp,me[2][2],me[3][1],me[3].tag,me[3].tp)
        local _, arr, idx = unpack(me)
--print("env::Op2_idx:",arr.tp)
        ASR(arr.arr, me, 'cannot index a non array')
        local _arr = ASR(_TP.deref(arr.tp,true), me, 'cannot index a non array')
--        ASR(_arr and _TP.isNumeric(idx.tp,true), me, 'invalid array index')
        --me.tp   = _TP.deref(me[2].tp)
        me.tp   = _arr
        me.lval = true
        me.fst  = arr.fst
        me.ref = arr.ref
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
--print("env::Op2_int_int:",e2.tag,e2[1])
        ASR(_TP.isNumeric(e1.tp,true) and _TP.isNumeric(e2.tp,true),me, 'invalid operands to binary "'..op..'"')
--        ASR((e2.tag=='CONST' and tonumber(e2[1])>0) or (e2.tag~='CONST'),me, 'division by zero')
        me.tp  = _TP.max(e1.tp,e2.tp,true)
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        ASR(_TP.isNumeric(e1.tp,true),
                me, 'invalid operand to unary "'..op..'"')
        me.tp  = (op=='not' and 'ubyte')  or e1.tp
    end,
    ['Op1_~']  = 'Op1_int',
    ['Op1_-']  = 'Op1_int',

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        ASR(_TP.max(e1.tp,e2.tp,true),
                me, 'invalid operands to binary "'..op..'"')
        me.tp  = 'ubyte'
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = 'ubyte'
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op1_int',

--    ['Op1_*'] = function (me)
--        local op, e1 = unpack(me)
--        local tp
--        
----print("env::Op1_*:",e1.tp,e1.tag,e1[2])
--        ASR(_TP.deref(e1.tp, true) and e1.tag~='CONST', me, 'invalid operand to unary "*"')
--        me.tp   = _TP.deref(e1.tp, true)
--        me.lval = true
--        me.fst  = e1.fst
--        
------print(print_r(e1,"env::Op1_*: e1"))
----      if (e1.tag=='Var') then  -- single var/field (not array) 
----        if (e1[2]) then -- field
----          ASR(_TP.deref(e1.tp, true) and e1.tag=='Var', me, 'invalid operand to unary "*"')
----          ASR(_ENV.c[_TP.deref(e1.tp)].fields[e1[2]], me, 'invalid field "'.. e1[2] ..'" for "'.. _TP.deref(e1.tp) ..'" register type.')
----          tp   = _ENV.c[_TP.deref(e1.tp)].fields[e1[2]].tp
----          me.offset = _ENV.c[_TP.deref(e1.tp)].fields[e1[2]].offset
----        else  -- var
----          ASR(_TP.deref(e1.tp, true) and e1.tag=='Var', me, 'invalid operand to unary "*"')
----          tp   = _TP.deref(e1.tp, true)
----        end
----      else    -- Op2_idx
----print("env::Op1_*:",e1.tag,e1[2][1],e1[2][2])
----        if (e1[2][2]) then -- field array
------print("env::Op1_*:",e1.tp,e1.tag,e1[2][2])--,_ENV.c[e1.tp].fields[e1[2][2]].tp,_ENV.c[e1.tp].fields[e1[2][2]].dim)
----          tp   = e1.tp
----          me.dim = e1.dim
----        else -- var array
----          tp = _TP.deref(e1.tp)
----        end
----      end
----      me.tp   = tp
----      me.lval = true
----      me.fst  = e1.fst        
--    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        ASR(e1.lval, me, 'invalid operand to unary "&"')
        me.tp   = e1.tp..'*'
        me.lval = false
        me.fst  = e1.fst
        me.ref = e1.ref
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
--print("env::Op_.:", op, id, e1[1], e1.tag,me.tag)
        ASR(_ENV.c[_TP.deref(e1.tp) or e1.tp].fields, me,'var "'.. e1[1]..'" is not a register. ')
        local field = _ENV.c[_TP.deref(e1.tp) or e1.tp].fields[id]
        ASR(field, me, 'invalid field name')
        me.tp   = (field.dim and field.tp..'*') or field.tp
        me.lval = true
        me.fst  = e1.fst
        me.arr = field.dim
        me.ref = e1.ref
    end,

    Op_var = function (me)
        local op, exp = unpack(me)
--print("env::Op_var:", op,exp[1].tag,exp[1].tp, exp[1].tag,exp[1].lval,exp[1].fst,_TP.isNumeric(exp.tp),_TP.deref(exp.tp))
        ASR((exp.tag=='Var' or exp.tag=='Op2_idx' or exp.tag=='Op2_.') and _TP.isBasicType(exp.tp), me, 'invalid "inc/dec" target. Received a "'..exp.tag..'" of type "'..exp.tp..'"')
        me.tp   = exp.tp
        me.lval = exp.lval
        me.fst  = exp.fst
        me.ref = exp.ref
     end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
--print("env::Op1_cast:", tp)
        ASR(not _TP.deref(exp.tp),me,'can not cast an address value')
        ASR(_TP.isBasicType(exp.tp),me,'can not cast register types')
        me.tp   = tp
        me.lval = exp.lval
        me.fst  = exp.fst
        me.ref = exp.ref
     end,

    C = function (me)
        local id = unpack(me)
        local c = _ENV.c[id]
        ASR(c and (c.tag=='var' or c.tag=='func'), me,
            'C variable/function "'..id..'" is not declared')
        me.tp   = '_'
        me.lval = '_'
        me.fst  = '_'
    end,

    WCLOCKK = function (me)
        me.tp   = 'ulong'
        me.lval = false
        me.fst  = false
    end,
    WCLOCKE = 'WCLOCKK',
    WCLOCKR = 'WCLOCKK',

    SIZEOF = function (me)
--print("env::SIZEOF")
        me.tp   = 'ushort'
        me.lval = true
    end,

    STRING = function (me)
        ASR(false, me, 'strings are not allowed')
        me.tp   = 'char*'
        me.lval = false
        me.fst  = false
    end,
    CONST = function (me)
        local v = unpack(me)
        --ASR(_TP.getConstLen(v) < 3,me,'Constant > 32bits size')
        me.tp   = _TP.getConstType(v,me)
        me.lval = false
        me.fst  = false
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
    end,
    NULL = function (me)
        me.tp   = 'void*'
        me.lval = false
        me.fst  = false
    end,
}

_AST.visit(F)

end

--    _AST.dump(_AST.root)
    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

function MAX_all (me, t)
    t = t or me
    me.n_tracks = 1
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.n_tracks = MAX(me.n_tracks, sub.n_tracks)
        end
    end
end

function ADD_all (me, t)
    t = t or me
    me.n_tracks = 0
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.n_tracks = me.n_tracks + sub.n_tracks
        end
    end
end

_PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_asyncs  = false,
    has_emits   = false,
}

local NO_fin = {
    Loop=true, Finally=true, Break=true,
    Host=true, Return=true, Async=true,
    ParEver=true, ParOr=true, ParAnd=true,
    AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
    EmitInt=true,
}

local NO_async = {
    ParEver=true, ParOr=true, ParAnd=true,
    EmitInt=true,
    Async=true,
    Finally=true,
    AwaitExt=true, AwaitInt=true, AwaitN=true, AwaitT=true,
}

F = {
    Node_pre = function (me)
        me.n_tracks = 1
    end,
    Node = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
        if NO_fin[me.tag] then
            ASR(not _AST.iter'Finally'(), me, 'not permitted inside `finally´')
        end
        if NO_async[me.tag] then
            ASR(not _AST.iter'Async'(), me,'not permitted inside `async´')
        end
    end,

    Root    = ADD_all,
    Block   = MAX_all,
    BlockN  = MAX_all,
    ParEver = ADD_all,
    ParAnd  = ADD_all,
    ParOr   = ADD_all,

    Dcl_ext = function (me)
        _PROPS.has_exts = true
    end,

    Async = function (me)
        _PROPS.has_asyncs = true
    end,

    If = function (me)
        local c, t, f = unpack(me)
        f = f or c
        MAX_all(me, {t,f})
    end,

    ParOr_pre = function (me)
        me.nd_join = true
    end,

    Loop_pre = function (me)
        F.ParOr_pre(me)
        me.brks = {}
    end,
    Break = function (me)
        local loop = _AST.iter'Loop'()
        ASR(loop, me, 'break without loop')
        loop.brks[me] = true

        local fin = _AST.iter'Finally'()
        ASR(not fin or fin.depth<loop.depth, me, 'not permitted inside `finally´')

        local async = _AST.iter'Async'()
        if async then
            local loop = _AST.iter'Loop'()
            ASR(loop.depth>async.depth, me, '`break´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        F.ParOr_pre(me)
        me.rets = {}
    end,
    Return = function (me)
        local blk = _AST.iter'SetBlock'()
        blk.rets[me] = true

        local async = _AST.iter'Async'()    
        if async then
            local setblk = _AST.iter'SetBlock'()
            ASR(async.depth<=setblk.depth+1, me, '`return´ without block')
        end
    end,

    AwaitT = function (me)
        _PROPS.has_wclocks = true
    end,

    EmitInt = function (me)
        me.n_tracks = 2     -- cont / match
        _PROPS.has_emits = true
    end,

    EmitExtS = function (me)
        if _AST.iter'Async'() then
            ASR(me[1].ext.pre=='input',  me, 'not permitted inside `async´')
        else
            ASR(me[1].ext.pre=='output', me, 'not permitted outside `async´')
        end
    end,
    EmitExtE = function (me)
        F.EmitExtS(me)
    end,
    EmitT = function (me)
        ASR(_AST.iter'Async'(), me,'not permitted outside `async´')
    end,

    SetExp = function (me)
        local e1, e2 = unpack(me)
        local async = _AST.iter'Async'()
        if async and (not e1) then
            ASR( async.depth <= _AST.iter'SetBlock'().depth+1,
                    me, 'invalid access from async')
        end
    end,

    Var = function (me)
        local async = _AST.iter'Async'()
        if async then
--print("props:Var",me[1])
            --ASR(not(string.sub(me[1],1,1) == '$' and me[1]~='$ret'),me,'`finally´ is not implemented inside async')
            ASR(_AST.iter'VarList'() or         -- param list
                me.ret or                       -- var assigned on return
                async.depth < me.var.blk.depth, -- var is declared inside
                    me, 'invalid access from async')
        end
    end,
}

_AST.visit(F)

end

    
do
 --[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]
 
 -- TODO: rename to flow
_ANA = {
    ana = {
        isForever  = nil,
        reachs   = 0,      -- unexpected reaches
        unreachs = 0,      -- unexpected unreaches
        asyncSeq = 1,
    },
}

-- avoids counting twice (due to loops)
-- TODO: remove
local __inc = {}
function INC (me, c)
    if __inc[me] then
        return true
    else
        _ANA.ana[c] = _ANA.ana[c] + 1
        __inc[me] = true
        return false
    end
end

-- [false]  => never terminates
-- [true]   => terminates w/o event

function OR (me, sub, short)

    -- TODO: short
    -- short: for ParOr/Loop/SetBlock if any sub.pos is equal to me.pre,
    -- then we have a "short circuit"

    for k in pairs(sub.ana.pos) do
--print("ana::OR:",me.tag,sub.tag,k,me.ana.pos[k],me.ana.pos[false])
        if k ~= false then
            me.ana.pos[false] = nil      -- remove NEVER
            me.ana.pos[k] = true
        end
    end
end

function COPY (n)
    local ret = {}
    for k in pairs(n) do
        ret[k] = true
    end
    return ret
end

function _ANA.CMP (n1, n2)
    return _ANA.HAS(n1, n2) and _ANA.HAS(n2, n1)
end

function _ANA.HAS (n1, n2)
    for k2 in pairs(n2) do
        if not n1[k2] then
            return false
        end
    end
    return true
end

local LST = {
    Do=true, Stmts=true, Block=true, Root=true, Dcl_cls=true,
    Pause=true,
}

F = {
    Root_pos = function (me)
--print(print_r(me,"ana::Root_pos: me"))
        _ANA.ana.isForever = not (not me[1].ana.pos[false])
    end,

    Node_pre = function (me)
        if me.ana then
            return
        end

        local top = _AST.iter()()
        me.ana = {
            pre  = (top and top.ana.pre) or { [true]=true },
        }
    end,
    Node = function (me)
        if me.ana.pos then
            return
        end
        if LST[me.tag] and me[#me] then
            me.ana.pos = COPY(me[#me].ana.pos)  -- copy lst child pos
        else
            me.ana.pos = COPY(me.ana.pre)       -- or copy own pre
        end
    end,

--    Dcl_cls_pre = function (me)
--        if me ~= _MAIN then
--            me.ana.pre = { [me.id]=true }
--        end
--    end,
--    Orgs = function (me)
--        me.ana.pos = { [false]=true }       -- orgs run forever
--    end,

    Stmts_bef = function (me, sub, i)
        if i == 1 then
            -- first sub copies parent
            sub.ana = {
                pre = COPY(me.ana.pre)
            }
        else
            -- broken sequences
            if me[i-1].ana.pos[false] and (not me[i-1].ana.pre[false]) then
                --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
                me.__unreach = true
                WRN( INC(me, 'unreachs'),
                     sub, 'statement is not reachable')
            end
            -- other subs follow previous
            sub.ana = {
                pre = COPY(me[i-1].ana.pos)
            }
        end
    end,

    ParOr_pos = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub, true)
        end
        if me.ana.pos[false] then
            --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, 'at least one trail should terminate')
        end
    end,

    ParAnd_pos = function (me)
        -- if any of the sides run forever, then me does too
        -- otherwise, behave like ParOr
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                me.ana.pos = { [false]=true }
                --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
                WRN( INC(me, 'unreachs'),
                     sub, 'trail should terminate')
                return
            end
        end

        -- like ParOr, but remove [true]
        local onlyTrue = true
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub)
            if not sub.ana.pos[true] then
                onlyTrue = false
            end
        end
        if not onlyTrue then
            me.ana.pos[true] = nil
        end
    end,

    ParEver_pos = function (me)
        me.ana.pos = { [false]=true }
        local ok = true
        for _, sub in ipairs(me) do
--print("ana::ParEver_pos:",sub.ana.pos[false])
            if sub.ana.pos[false]==nil or sub.ana.pos[false]==false  then
                ok = false
                break
            end
        end
        if not ok then
            --_ANA.ana.reachs = _ANA.ana.reachs + 1
            --WRN( INC(me, 'reachs'), me, 'all trails must terminate')
            INC(me, 'reachs')
        end
        ASR(ok,me,'all trails must terminate')
    end,

    If = function (me)
--print("ana::If:",me[1],me[2],me[3])
        if me.isFor then
            me.ana.pos = COPY(me.ana.pre)
            return
        end

        me.ana.pos = { [false]=true }
        for _, sub in ipairs{me[2],me[3]} do
          if sub then
            OR(me, sub)
          end
        end
    end,

    SetBlock_pre = function (me)
        me.ana.pos = { [false]=true }   -- `return/break´ may change this
    end,
    Return = function (me)
        local top = _AST.iter((me.tag=='Return' and 'SetBlock') or 'Loop')()
--print("ana::Return: <<",me.tag,top.tag,top.ana.pos[false])
        me.ana.pos = COPY(me.ana.pre)
        OR(top, me, true)
        me.ana.pos = { [false]='esc' }   -- diff from [false]=true
--print("ana::Return: >>",top.tag,top.ana.pos[true],top.ana.pos[false])
    end,
    SetBlock = function (me)
--print(print_r(me,"ana::SetBlock: me"))
--print("ana::SetBlock:",me.tag,me[1].tag,me[2].tag,"| ", (me[2][1] and me[2][1].tag),(me[2][2] and me[2][2].tag),(me[2][3] and me[2][3].tag))
--print("ana::SetBlock:",me[2].ana.pos[true], me[2].ana.pos[false],me[2].tag,me[2][1])
        local blk = me[2]
-- afb  if   (not blk.ana.pos[false])
        if   (    me.ana.pos[false]) 
        and  (me[2].tag ~= 'Async')     -- async is assumed to terminate
        and me[2][1].tag                    -- afb Not check if CfgBlk-> me[2][1].tag is nil
        then
            --_ANA.ana.reachs = _ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 blk, 'missing `return´ statement for the block')
        end
    end,

    Loop_pre = 'SetBlock_pre',
    Break    = 'Return',

    Loop = function (me)
-- TODO: why?
--print("ana::Loop:",me.isFor)
        if me.isFor then
            me.ana.pos = COPY(me[1].ana.pos)
            return
        end

        if me[1].ana.pos[false] then
            --_ANA.ana.unreachs = _ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, '`loop´ iteration is not reachable')
        end
    end,

    Async = function (me)
        if me.ana.pre[false] then
            me.ana.pos = COPY(me.ana.pre)
        else 
--afb            me.ana.pos = { ['ASYNC_'..me.n]=true }
            me.ana.pos = { ['ASYNC_'.._ANA.ana.asyncSeq]=true }
            _ANA.ana.asyncSeq = _ANA.ana.asyncSeq + 1
        end
    end,

    SetAwait = function (me)
        local set, awt = unpack(me)
        set.ana.pre = COPY(awt.ana.pos)
        set.ana.pos = COPY(awt.ana.pos)
        me.ana.pre = COPY(awt.ana.pre)
        me.ana.pos = COPY(set.ana.pos)
    end,

    AwaitS = function (me)
        DBG'TODO - ana.lua - AwaitS'
    end,

    AwaitExt_aft = function (me, sub, i)
--print("ana::AwaitExt_aft:",me, sub, i, me.tag,me[1][1],me[2])
--afb        if i  > 1 then
        if (i or 1) > 1 then
            return
        end
        if me.tag == 'AwaitInt' and 
           string.sub(me[1][1],1,4) == '$fin' -- Ignores AwaitInt from Finally
        then 
          return
        end

        -- between Await and Until

        local awt, cnd = unpack(me)

        local t
        if me.ana.pre[false] then
            t = { [false]=true }
        else
            -- use a table to differentiate each instance
            t = { [{awt.evt and awt.evt or 'WCLOCK'}]=true }
        end
        me.ana.pos = COPY(t)
        if cnd then
            cnd.ana = {
                pre = COPY(t),
            }
        end
    end,
    AwaitInt_aft = 'AwaitExt_aft',
    AwaitT_aft   = 'AwaitExt_aft',

    AwaitN = function (me)
        me.ana.pos = { [false]=true }
    end,
}

local _union = function (a, b, keep)
    if not keep then
        local old = a
        a = {}
        for k in pairs(old) do
            a[k] = true
        end
    end
    for k in pairs(b) do
        a[k] = true
    end
    return a
end

-- TODO: remove
-- if nested node is reachable from "pre", join with loop POS
function _ANA.union (root, pre, POS)
    local t = {
        Node = function (me)
            if me.ana.pre[pre] then         -- if matches loop begin
                _union(me.ana.pre, POS, true)
            end
        end,
    }
    _AST.visit(t, root)
end

_AST.visit(F)


end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_ANA.ana.acc  = 0      -- nd accesses
_ANA.ana.abrt  = 0      -- nd flows
_ANA.ana.excpt = 0      -- nd excpt

-- any variable access calls this function
-- to be inserted on parent Parallel sub[i] or Class
function iter (n)
    local par = n.__par and n.__par.tag
--print("acc::iter:",n.tag,par)
    return par=='ParOr' or par=='ParAnd' or par=='ParEver'
--        or n.tag=='Dcl_cls'
end

function INS (acc, exists)
-- afb comment 'cls'
--    if not exists then
--        acc.cls = CLS()                     -- cls that acc resides
--    end
    local n = _AST.iter(iter)()             -- child Block from PAR
--print("acc::INS:",n)
    if n then
        n.ana.accs[#n.ana.accs+1] = acc
    end
    return acc
end

F = {
-- accs need to be I-indexed (see CHK_ACC)
    Dcl_cls_pre = function (me)
        me.ana.accs = {}
    end,
    ParOr_pre = function (me)
        for _, sub in ipairs(me) do
            sub.ana.accs = {}
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

    ParOr_pos = function (me)
        -- insert all my subs on my parent Par
        if _AST.iter(_AST.pred_par) then -- requires ParX_pos
            for _, sub in ipairs(me) do
                for _,acc in ipairs(sub.ana.accs) do
    -- check par/enter only against immediate pars
                    if acc.md ~= 'par' then
    -- check ParOr esc only against immediate pars
                    if not (acc.md=='esc' and acc.id.tag=='ParOr') then
    -- check Loop esc only against nested pars
                    --if not (acc.md=='esc' and acc.id.tag=='Loop'
                            --and acc.id.depth>me.depth) then
                        INS(acc, true)
                    --end
                    end
                    end
                end
            end
        end
    end,
    ParAnd_pos  = 'ParOr_pos',
    ParEver_pos = 'ParAnd_pos',

    Spawn = 'SetNew',
    SetNew = function (me)
        for _,acc in ipairs(me.cls.ana.accs) do
            INS(acc, true)
        end
    end,

-- TODO: usar o Dcl_var p/ isso
--[=[
    Orgs = function (me)
        -- insert cls accs on my parent ParOr
        for _, var in ipairs(me.vars) do
            for _,acc in ipairs(var.cls.ana.accs) do
                INS(acc, true)
            end
        end
    end,
]=]

    EmitExtS = function (me)
        local e1, _ = unpack(me)
--        if e1.evt.pre == 'output' then
        if e1.ext.pre == 'output' then
            F.EmitExtE(me)
        end
    end,
    EmitExtE = function (me)
        local e1, e2 = unpack(me)
        INS {
            path = me.ana.pre,
--            id  = e1.evt.id,    -- like functions (not table events)
            id  = e1.ext.id,    -- like functions (not table events)
            md  = 'cl',
            tp  = '_',
            any = false,
--            err = 'event `'..e1.evt.id..'´ (line '..me.ln..')'
            err = 'event `'..e1.ext.id..'´ (line '..me.ln..')',
            tag = 'EmitExt'
        }
--[[
        if e2 then
            local tp = _TP.deref(e1.evt.tp, true)
            if e2.accs and tp then
                e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become 
                    "any"
                e2.accs[1][2] = (me.c and me.c.mod=='pure' and 'rd') or 'wr'
                e2.accs[1][3] = tp
            end
        end
]]
    end,

    Func = function (me)
        local f = unpack(me)
        INS {
            path = me.ana.pre,
            id  = f,    -- like functions (not table events)
            md  = 'cl',
            tp  = '_',
            any = false,
            err = 'function `'.. f ..'´ (line '..me.ln..')',
            tag = 'Func'
        }
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        f.ref.acc.md = 'cl'
        for i, exp in ipairs(exps) do
            local tp = _TP.deref(exp.tp, true)
            if tp then
                local v = exp.ref
                if v then   -- ignore constants
--DBG(exp.tag, exp.ref)
                    v.acc.any = exp.lval    -- f(&x) // a[N] f(a) // not "any"
                    v.acc.md  = (me.c and me.c.mod=='pure' and 'rd') or 'wr'
                    v.acc.tp  = tp
                end
            end
        end
    end,

    EmitInt = function (me)
        local e1, e2 = unpack(me)
--print("acc::EmitInt:",e1[1])
        if string.sub(e1[1],1,4) == '$fin' then
          e1.ref.acc.md   = 'no'
        else
          e1.ref.acc.md   = 'tr'
        end
        e1.ref.acc.node = me        -- emtChk
        me.emtChk = false
        e1.ref.acc.tag = 'EmitInt'
    end,

    SetAwait = 'SetExp',
    SetExp = function (me)
--print("acc::SetExp1:",me.tag, me[1][1][1] ,me[1].tag,me[1][1].ref,me[1][1].ref.acc.md)
        me[1][1].ref.acc.md = 'wr'
        me[1][1].ref.acc.setEvt = ((me[2].tag=='AwaitExt' or me[2].tag=='AwaitInt') and me[2]) or nil
    end,
    AwaitInt = function (me)
        me[1].ref.acc.md = 'aw'
        F.AwaitExt(me)  -- flow
    end,
    
    Op_var = function (me)
        local op, exp = unpack(me)
        exp.ref.acc.md = 'wr'
    end,

    ['Op1_*'] = function (me)
        me.ref.acc.any = true
        me.ref.acc.tp  = _TP.deref(me.ref.acc.tp,true)
    end,
    ['Op1_&'] = function (me)
        me.ref.acc.md = 'no'
    end,

    ['Op2_.'] = function (me)
        if me.org then
            me.ref.acc.org = me.org.ref
        end
    end,

--    Global = function (me)
--        me.acc = INS {
--            path = me.ana.pre,
--            id  = 'Global',
--            md  = 'rd',
--            tp  = me.tp,
--            any = true,
--            err = 'variable `global´ (line '..me.ln..')',
--        }
--    end,
--
--    This = function (me)
--        me.acc = INS {
--            path = me.ana.pre,
--            id  = me,
--            md  = 'rd',
--            tp  = me.tp,
--            any = true,
--            err = 'variable `this´ (line '..me.ln..')',
--        }
--    end,

    Var = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me.var,
            md  = 'rd',
            tp  = me.var.tp,
            any = false,
            err = 'variable/event `'..me.var.id..'´ (line '..me.ln..')',
        }
    end,

--    Nat = function (me)
--        me.acc = INS {
--            path = me.ana.pre,
--            id  = me[1],
--            md  = 'rd',
--            tp  = '_',
--            any = false,
--            err = 'symbol `'..me[1]..'´ (line '..me.ln..')',
--        }
--    end,

    -- FLOW --

    Break = function (me, TAG, PRE)
        TAG = TAG or 'Loop'
        PRE = PRE or me.ana.pre
        local top = _AST.iter(TAG)()
        INS {
            path = PRE,
            id  = top,
            md  = 'esc',
            err = 'escape (line '..me.ln..')',
        }
    end,
    Return = function (me)
        F.Break(me, 'SetBlock')
    end,
    Node = function (me)
        local top = me.__par and me.__par.tag
        if top == 'ParOr' then
            if not me.ana.pos[false] then
                F.Break(me, 'ParOr', me.ana.pos)
            end
        end

        if top=='ParOr' or top=='ParAnd' or top=='ParEver' then
            if not me.ana.pre[false] then
                me.parChk = false           -- only chk if ND flw
                INS {
                    path = me.ana.pre,
                    id   = me,--.__par,
                    md   = 'par',
                    err  = 'par enter (line '..me.ln..')',
                }
            end
        end
    end,

    AwaitExt = function (me)
        INS {
            path = me.ana.pos,
            id  = me,--_AST.iter(TAG)(),
            md  = 'awk',
            err = 'awake (line '..me.ln..')',
        }
    end,
    AwaitT = 'AwaitExt',
    --AwaitInt = <see above>,
}

_AST.visit(F)

------------------------------------------------------------------------------

local ND = {
    acc = { par={},awk={},esc={},
        cl  = { cl=true, tr=true,  wr=true,  rd=true,  aw=true  },
--        tr  = { cl=true, tr=true,  wr=false, rd=false, aw=true  },
        tr  = { cl=true, tr=true,  wr=false, rd=false, aw=false  },
        wr  = { cl=true, tr=false, wr=true,  rd=true,  aw=false },
        rd  = { cl=true, tr=false, wr=true,  rd=false, aw=false },
        aw  = { cl=true, tr=true,  wr=false, rd=false, aw=false },
        no  = {},   -- never ND ('ref')
    },

    flw = { cl={},tr={},wr={},rd={},aw={},no={},
        par = { par=false, awk=false, esc=true },
        awk = { par=false, awk=false, esc=true },
        esc = { par=true,  awk=true,  esc=true },
    },
}

local ALL = nil     -- holds all emits starting from top-most PAR

--[[
    ana = {
        acc = 1,  -- false positive
    },
    ana = {
        isForever = true,
        n_unreachs = 1,
    },
]]

-- {path [A]=true, [a]=true } => {ret [A]=true, [aX]=true,[aY]=true }
-- {T [a]={[X]=true,[Y]=true} } (emits2pres)
local function int2exts (path, NO_emts, ret)
    ret = ret or {}

    local more = false                  -- converged
    for int in pairs(path) do
        if type(int)=='table' and int[1].pre=='event' then
            for emt_acc in pairs(ALL) do
                if int[1]==emt_acc.id and (not NO_emts[emt_acc]) then
                    for ext in pairs(emt_acc.path) do
                        if not ret[ext] then
                            more = true         -- not converged yet
                            ret[ext] = true     -- insert new ext
                        end
                    end
                end
            end
        else
            ret[int] = true             -- already an ext
        end
    end
    if more then
        return int2exts(ret, NO_emts, ret, cache) -- not converged
    else
        if next(ret)==nil then
            ret[false] = true   -- include "never" if empty
        end
        return ret
    end
end

function par_rem (path, NO_par)
    for id in pairs(path) do
        if NO_par[id] then
            path[id] = nil
        end
    end
    if next(path)==nil then
        path[true] = true       -- include "tight" became empty
    end
    return path
end

function par_isConc (path1, path2, T)
    for id1 in pairs(path1) do
        for id2 in pairs(path2) do
            if (id1 == false) then
            elseif (id1 == id2) or
                     (type(id1) == 'table') and (type(id2) == 'table') and
                     (id1[1] == id2[1])
            then
                return true
            end
        end
    end
end

--local CACHE = setmetatable({},
    --{__index=function(t,k) t[k]={} return t[k] end})

function CHK_ACC (accs1, accs2, NO_par, NO_emts)

--print(print_r(accs1,"acc::CHK_ACC: accs1"))

--print("acc:CHK_ACC:",#accs1,#accs2,#NO_par, #NO_emts)
-- afb comment 'cls'
--    local cls = CLS()

    -- "acc": i/j are concurrent, and have incomp. acc
    -- accs need to be I-indexed
    for _, acc1 in ipairs(accs1) do
        local path1 = int2exts(acc1.path, NO_emts)
              path1 = par_rem(path1, NO_par)
        for _, acc2 in ipairs(accs2) do
            local path2 = int2exts(acc2.path, NO_emts)
                  path2 = par_rem(path2, NO_par)
--print("acc:CHK_ACC: acc1.id",acc1.err,acc2.err)
            if par_isConc(path1,path2) then

-- FLOW
--print("acc:CHK_ACC:ND.flw...",acc1.md,acc2.md,ND.flw[acc1.md][acc2.md])
                if ND.flw[acc1.md][acc2.md] then
                    if _AST.isChild(acc1.id, acc2.id)
                    or _AST.isChild(acc2.id, acc1.id)
                    then
                        WRN(false,nil,'abortion : '..
                                acc1.err..' vs '..acc2.err)
                        _ANA.ana.abrt = _ANA.ana.abrt + 1
--[[
DBG'==============='
DBG(acc1.cls.id, acc1, acc1.id, acc1.md, acc1.tp, acc1.any, acc1.err)
for k in pairs(path1) do
    DBG('path1', acc1.path, type(k)=='table' and k[1].id or k)
end
DBG(acc2.cls.id, acc2, acc2.id, acc2.md, acc2.tp, acc2.any, acc2.err)
for k in pairs(path2) do
    DBG('path2', acc2.path, type(k)=='table' and k[1].id or k)
end
DBG'==============='
]]
                        if acc1.md == 'par' then
                            acc1.id.parChk = true
                        end
                        if acc2.md == 'par' then
                            acc2.id.parChk = true
                        end
                    end
                end

-- ACC
--print("acc:CHK_ACC:ND.acc...",acc1.md,acc2.md,ND.acc[acc1.md][acc2.md])
                if ND.acc[acc1.md][acc2.md] then

-- afb comment 'cls'
                    -- this.x vs this.x (both accs bounded to cls)
--                    local cls_ = (acc1.cls == cls) or
--                                 (acc2.cls == cls)

-- afb comment 'org'
                    -- a.x vs this.x
--                    local _nil = {}
--                    local o1 = (acc1.org or acc2.org)
--                    o1 = o1 and o1.acc or _nil
--                    local o2 = (acc2.org or acc1.org)
--                    o2 = o2 and o2.acc or _nil

--                    -- orgs are compatible
--                    local org_ = (o1 == o2)
--                              or o1.any
--                              or o2.any
--
--                    -- orgs are compatible
--                    local org_ = o1.id == o2.id
--                              or o1.any
--                              or o2.any

                    -- ids are compatible
                    local id_ = acc1.id == acc2.id
                             or acc1.md=='cl' and acc2.md=='cl'
                             or acc1.any and _TP.contains(acc1.tp,acc2.tp)
                             or acc2.any and _TP.contains(acc2.tp,acc1.tp)

                    -- C's are det
                    local c1 = _ENV.c[acc1.id] or _ENV.exts[acc1.id]
                    c1 = c1 and (c1.mod=='pure' or c1.mod=='constant')
                    local c2 = _ENV.c[acc2.id]  or _ENV.exts[acc1.id]
                    c2 = c2 and (c2.mod=='pure' or c2.mod=='constant')
                    local c_ = c1 or c2
                            or (_ENV.exts[acc1.id] and not(_ENV.dets[acc1.id] and _ENV.dets[acc1.id][acc2.id]))

        --DBG(id_, c_,c1,c2, acc1.any,acc2.any)
-- afb                    if cls_ and org_ and id_ and (not c_)
--print("acc:CHK_ACC:id_, not c_",id_, not c_,acc1.md,acc2.md,acc1.trg,acc2.trg,not (acc1.trg == '_') , acc1.trg==acc2.trg)
                    if id_ and (not c_)
                    then
--print("acc:CHK_ACC:",acc1.md,acc2.md,acc1.trg,acc2.trg)
                        --if not(acc1.trg=='_') and acc1.trg==acc2.trg then
                            if acc1.md=='cl' and acc1.md==acc2.md  then
                              if not(acc1.trg=='_') and acc1.trg==acc2.trg then
                                WRN(not _OPTS.wstrong,nil,'nondeterminism (call conflict) : '..acc1.err..' vs '..acc2.err)
                              else
                                WRN(not _OPTS.wweak,nil,'nondeterminism (weak call conflict) : '..acc1.err..' vs '..acc2.err)
                              end
                            elseif not(acc1.md=='rd') and acc1.md==acc2.md  then
                              if not(acc1.trg=='_') and acc1.trg==acc2.trg then
                                WRN(not _OPTS.wstrong,nil,'nondeterminism (write conflict) : '..acc1.err..' vs '..acc2.err)
                              else
                                WRN(not _OPTS.wweak,nil,'nondeterminism (weak write conflict) : '..acc1.err..' vs '..acc2.err)
                              end
                            else
                              WRN(not _OPTS.wweak,nil,'nondeterminism (weak read conflict) : '..acc1.err..' vs '..acc2.err)
                            end
--                        else
--                            if not(acc1.md=='rd') and acc1.md==acc2.md then
--                              WRN(not _OPTS.wweak,nil,'nondeterminism (weak write conflict) : '..acc1.err..' vs '..acc2.err)
--                            else
--                              WRN(not _OPTS.wweak,nil,'nondeterminism (weak read conflict) : '..acc1.err..' vs '..acc2.err)
--                            end
--                        end
                        _ANA.ana.acc = _ANA.ana.acc + 1
                    end
                end
            end
        end
    end
end

function _chk (n, id)
    for k in pairs(n) do
        if type(k)=='table' and k[1]==id then
            return true
        end
    end
    return false
end

-- TODO: join with CHK_ACC
-- emits vs rets/ors/breaks (the problem is that emits are considered in par)
function CHK_EXCPT (s1, s2, isOR)
    for _, ana in ipairs(s1.ana.accs) do
        if ana.md == 'tr' then
            if _chk(s2.ana.pos,ana.id) and isOR or -- terminates w/ same event
               s2.ana.pos[false] --or       -- ~terminates (return/break)
               --s2.ana.pos[true]                 -- terminates tight
            then
                WRN(false,nil,'exception : line '..s2.ln..' vs '..ana.err)
                _ANA.ana.excpt = _ANA.ana.excpt + 1
                ana.node.emtChk = true
            end
        end
    end
end

G = {
-- take all emits from top-level PAR
    ParOr_pre = function (me)
        if ALL then
            return
        end
        ALL = {}
        for _, sub in ipairs(me) do
            for _,acc in ipairs(sub.ana.accs) do
                if acc.md == 'tr' then
                    ALL[acc] = true
                end
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

-- look for nondeterminism
    ParOr = function (me)
--print("acc::ParOr:#me",#me)

-- afb :: Leave out all vars 'rd' if it has a first var 'wr' in the same trail. Also define its trigger event.
        for z=1, #me do
          local first_md = {}
          local trail_trigger = string.sub(tostring(me[1].ana.accs),8)
          for k,acc in ipairs(me[z].ana.accs) do
          local tag = acc.tag or acc.id.tag or (acc.id.pre and 'var') 
--print("acc::ParOr: wr+rd",z,'[', acc.tag,acc.id.tag, acc.id.pre,']', tag,acc.id.id, acc.md,trail_trigger)
            if tag=='var' or tag=='event' then -- is a Var/VarEvent
--print(print_r(acc,"acc::ParOr: var/evet acc"))
              if acc.setEvt then
--print("acc::ParOr: SetExp?",z, k,acc.setEvt.tag, acc.setEvt[1][1], (acc.setEvt[2] and acc.setEvt[2][1].tag),(acc.setEvt[2] and acc.setEvt[2][1][1]))
                trail_trigger = acc.setEvt[1][1]
                trail_trigger = trail_trigger .. '$' .. (((acc.setEvt.tag=='AwaitExt' and (acc.setEvt[2] and acc.setEvt[2][1].tag=='CONST')) and acc.setEvt[2][1][1]) or '0')
              end
              if not first_md[acc.id.id] then first_md[acc.id.id] = acc.md end
              if acc.md == 'rd' and first_md[acc.id.id]=='wr' then acc.md='no' end
              acc.trg = trail_trigger
            else -- is not a var, then it is a new trail
--print("acc::ParOr: tag",tag)--,string.sub(tag or ' ',1,5) == 'Await')
              if string.sub(tag or ' ',1,5) == 'Await' then
                first_md = {}
                trail_trigger = ((acc.id.tag=='AwaitExt' or acc.id.tag=='AwaitInt') and ((acc.id[1] and acc.id[1][1]) or acc.id.id)) or string.sub(tostring(acc),8)
                trail_trigger = trail_trigger .. '$' .. (((acc.id.tag=='AwaitExt' and (acc.id[2] and acc.id[2][1].tag=='CONST')) and acc.id[2][1][1]) or '0')
                acc.trg = trail_trigger
              else
                acc.trg = trail_trigger -- ((acc.id[1] and acc.id[1][1]) or acc.id.id or acc.id) 
              end
--print("acc::ParOr: not var",z,acc.trg,'$'..(((acc.id.tag=='AwaitExt' and acc.id[2] and acc.id[2][1].tag=='CONST') and acc.id[2][1][1]) or '0'), acc.id.tag, acc.md, (acc.id[1] and acc.id[1][1]) or acc.id.id, acc.trg)
--print(print_r(acc.id,"acc::ParOr: acc.id"))
            end
          end
        end


        for i=1, #me do
            for j=i+1, #me do

                -- holds invalid emits
                local NO_emts = {}
                for _,acc in ipairs(me[i].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
--print("acc::ParOr:#me[i].ana.accs",#me[i].ana.accs,#NO_emts)

                for _,acc in ipairs(me[j].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
--print("acc::ParOr:#me[j].ana.accs",#me[j].ana.accs,#NO_emts)

                for acc in pairs(ALL) do
                    if _ANA.CMP(acc.path, me.ana.pre) then
                        NO_emts[acc] = true -- instantaneous emit
                    end
                end
--print("acc::ParOr:#ALL",#ALL,#NO_emts)

                CHK_ACC(me[i].ana.accs, me[j].ana.accs,
                        me.ana.pre,
                        --_ANA.union(me.ana.pre,me.ana.pos),
                        NO_emts)
                CHK_EXCPT(me[i], me[j], me.tag=='ParOr')
                CHK_EXCPT(me[j], me[i], me.tag=='ParOr')
            end
        end
    end,
    ParAnd  = 'ParOr',
    ParEver = 'ParOr',

-- TODO: workaround
    -- Loop can only be repeated after nested PARs evaluate CHK_*
    Loop = function (me)
        -- pre = pre U pos
        if not me[1].ana.pos[false] then
            _ANA.union(me[1], next(me.ana.pre), me[1].ana.pos)
        end
    end,
}

_AST.visit(G)


end

--print(print_r(_AST.root,"terrac: root"))
    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_MEM = {
    off  = 0,
    max  = 0,
    gtes = {
        exts = {},
    },
    vars = {},
}

function alloc (n)
    local cur = _MEM.off
    _MEM.off = _MEM.off + n
    _MEM.max = MAX(_MEM.max, _MEM.off)
    return cur
end


local t2n = {
     ms = 10^0,
      s = 10^3,
    min = 60*10^3,
      h = 60*60*10^3,
}


local t2idx = {
     ms = 0,
      s = 1,
    min = 2,
      h = 3,
}

_MEM.t2idx=t2idx

function accs_join (dst, src)
    if src.accs then
        for _,v in ipairs(src.accs) do
            dst.accs[#dst.accs+1] = v
        end
    end
end

local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

F = {

    Root_pre = function (me)
--print("mem::Root_pre: curr mem in",alloc(0))
--print("mem::Root_pre: wclocks/syncs/emits",_ENV.n_wclocks,_ENV.n_asyncs,_ENV.n_emits)
        _MEM.gtes.wclock0 = alloc(_ENV.n_wclocks * _ENV.c.tceu_wclock.len)
        _MEM.gtes.async0  = alloc(_ENV.n_asyncs  * _ENV.c.tceu_nlbl.len)
        _MEM.gtes.emit0   = alloc(_ENV.n_emits   * _ENV.c.tceu_nlbl.len)
--print("mem::Root_pre: curr mem after gtes",alloc(0))
        local int outcount=0;
        _ENV.gate0 = _MEM.off; --afb save gates0 offset value
        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' and (_ENV.awaits[ext] or 0) > 0 then  -- only active events
--print("mem::Root_pre: in evt",ext.id,_ENV.awaits[ext],(2 +(_ENV.awaits[ext] or 0)*_ENV.c.tceu_nlbl.len))

              if not ext.inArg then
                  _MEM.gtes[ext.n] = alloc(2 + -- 1+2=2 -> idx, gates
                                      (_ENV.awaits[ext] or 0) * _ENV.c.tceu_nlbl.len) 
              else
                  _MEM.gtes[ext.n] = alloc(2 + -- 1+2=2 -> idx, gates
                                      (_ENV.awaits[ext] or 0) * (_ENV.c.tceu_nlbl.len + 1)) -- (idAux,addr)*             
              end

            else
              _MEM.gtes[ext.n] = alloc(0)
            end
--print("mem::Root_pre:",ext.id,_MEM.gtes[ext.n])
            if ext.pre == 'output' then
            	ext.seq = outcount;
            	outcount = outcount + 1;
            end
        end
        _MEM.gtes.loc0 = alloc(0)
--print("mem::Root_pre: curr mem out",_MEM.gtes.loc0)
    end,

    Block_pre = function (me)
--print(print_r(me,"mem::Block_pre: me"))
        me.off = _MEM.off

        for _, var in ipairs(me.vars) do
--print("mem::Block_pre: var",var.id,me.off,_MEM.off)
            local len
            if var.arr then
				        if _TP.deref(_TP.deref(var.tp)) then 
                    len = 2 * var.arr
                else
                	len = _ENV.c[_TP.deref(var.tp)].len * var.arr
                end
            elseif _TP.deref(var.tp) then
                len = _ENV.c.pointer.len
            else
                len = _ENV.c[var.tp].len
            end
            
            if _OPTS.analysis_run then
                var.off = 0
            else
                var.off = alloc(len)
            end
            -- afb build a var table in _MEM
            _MEM.vars[var.off]= (_MEM.vars[var.off] or '')..var.id..':'..len..', '
            
            if var.isEvt then
                var.awt0 = alloc(1)
				-- afb build a var table in _MEM
		        _MEM.vars[var.awt0]= (_MEM.vars[var.awt0] or '')..var.id..'_awt0, '
                local temp=alloc(_ENV.c.tceu_nlbl.len*var.n_awaits)
				-- afb build a var table in _MEM
		        if (var.n_awaits>0) then _MEM.vars[temp]=  (_MEM.vars[temp] or '') .. var.id..'_waits['..var.n_awaits..'], ' end
            end

-- afb            var.val = '(*(('.._TP.c(var.tp)..'*)(CEU->mem+'..var.off..')))'
            var.val = ''..var.off..''
            if var.arr then
-- afb                var.val = '(('.._TP.c(var.tp)..')(&'..var.val..'))'
                var.val = ''..var.off..''
            end

            -- Create relative field offset 'val'
            if var.fields then
              local offset = 0
              local lastSize = 0
              for k,field in ipairs(var.fields) do
--print('mem::Block_pre: fields:', k, field.tp, field.id)
                offset = offset + lastSize
                if field.arr then
                    if _TP.deref(_TP.deref(field.tp)) then 
                        len = 2 * field.arr
                    else
                      len = _ENV.c[_TP.deref(field.tp)].len * field.arr
                    end
                elseif _TP.deref(field.tp) then
                    len = _ENV.c.pointer.len
                else
                    len = _ENV.c[field.tp].len
                end
                lastSize = len
                field.offset = offset
                field.val = offset + var.val
              end
            end

        end

        me.max = _MEM.off
    end,
    Block = function (me)
        for blk in _AST.iter'Block' do
            blk.max = MAX(blk.max, _MEM.off)
        end
--print("mem::Block: me.off,_MEM.off",me.off,_MEM.off,'ln='.. me.ln)
        _MEM.off = me.off
    end,

    ParEver_aft = function (me, sub)
--print("mem::ParEver_aft: me.lst,_MEM.off,sub.max",me.lst,_MEM.off,sub.max,'ln='.. me.ln)
        me.lst = sub.max
    end,
    ParEver_bef = function (me, sub)
--print("mem::ParEver_bef: me.lst,_MEM.off",me.lst,_MEM.off,'ln='.. me.ln)
        _MEM.off = me.lst or _MEM.off
    end,
    ParOr_aft  = 'ParEver_aft',
    ParOr_bef  = 'ParEver_bef',
    ParAnd_aft = 'ParEver_aft',
    ParAnd_bef = 'ParEver_bef',

    ParAnd_pre = function (me)
--print("mem::ParAnd_pre:",'ParAnd_flag['..#me..']',me.off,_MEM.off)
        me.off = alloc(#me)        -- TODO: bitmap?
		-- afb build a var table in _MEM
        _MEM.vars[me.off]= ( _MEM.vars[me.off] or '')..'ParAnd_flag['..#me..'], '
    end,
    ParAnd = 'Block',

    -- for analysis_run, ParEver behaves like ParAnd (n_reachs)
    ParEver_pre = function (me)
        if _OPTS.analysis_run then
            F.ParAnd_pre(me)
        end
    end,
    ParEver = function (me)
        if _OPTS.analysis_run then
            F.Block(me)
        end
    end,

    Var = function (me)
--print("mem:Var:",me.var.id,me.var.val,me.var.arr)
--print(print_r(me,"mem:Var: me"))
        me.val = me.var.val
        me.accs = { {me.var, (me.var.arr and 'no') or 'rd', me.var.tp, false,
                    'variable/event `'..me.var.id..'´ (line '..me.ln..')'} }
    end,

    AwaitInt = function (me)
        local e = unpack(me)
        e.accs[1][2] = 'aw'
        if string.sub(e.var.id,1,4) == '$fin' then
            e.accs[1][2] = 'no'
        end
        me.val = e.val
    end,

    EmitInt = function (me)
        local e1, e2 = unpack(me)
        e1.accs[1][2] = 'tr'
        if string.sub(e1.var.id,1,4) == '$fin' then
            e1.accs[1][2] = 'no'
        end
    end,

    --------------------------------------------------------------------------

    SetAwait = 'SetExp',
    SetExp = function (me)
        local e1, e2 = unpack(me)
        e1.accs[1][2] = 'wr'
    end,

    EmitExtS = function (me)
        local e1, _ = unpack(me)
        if e1.ext.pre == 'output' then
            F.EmitExtE(me)
        end
    end,
    EmitExtE = function (me)
        local e1, e2 = unpack(me)
        e1.acc = {e1.ext.id, 'cl', '_', false,
                    'event `'..e1.ext.id..'´ (line '..me.ln..')'}
        local len, val, valType
        if e2 then
            local tp = _TP.deref(e1.ext.tp, true)
--print("mem::EmitExtE:",e1.ext.id, e1.ext.tp, e2.tp)
            if tp then
            ASR(_TP.deref(e2.tp),me,'invalid type. Expecting '..e1.ext.tp..' and received '.. e2.tp)
                len = _ENV.c[_TP.deref(_TP.deref(e2.tp)) or _TP.deref(e2.tp) or e2.tp].len --'sizeof('.._TP.c(tp)..')'
                val = e2.val
                valType = ''
                if e2.accs and tp then
                    e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become "any"
                    local c = _ENV.c[me.fid]
                    e2.accs[1][2] = (c and c.mod=='pure' and 'rd') or 'wr'
                    e2.accs[1][3] = tp
                end
            else
                len = _ENV.c[_TP.deref(e2.tp) or e2.tp].len -- 'sizeof('.._TP.c(e1.ext.tp)..')'
--afb                val = 'ceu_ext_f('..e2.val..')'
                val = e2.val
                valType = e2.tp
            end
            -- afb : Resize array len
            if (type(e2.fst)=='table' and e2.fst.arr) then
            	len = len * e2.fst.arr
            end
        else
            len = 0
-- afb            val = 'NULL'
            val = '0'
            valType = _TP.getConstType(val,me.ln)
        end
		
--        me.val = '\n'..[[
--     //> ceu_out_event(OUT_]]..e1.ext.id..','..len..','..val..[[)
--afb #if defined(ceu_out_event_]]..e1.ext.id..[[)
--afb     ceu_out_event_]]..e1.ext.id..'('..val..[[)
--afb #elif defined(ceu_out_event)
--afb     ceu_out_event(OUT_]]..e1.ext.id..','..len..','..val..[[)
--afb #else
--afb     0
--afb #endif
--afb ]]
    end,

    AwaitExt = function (me)
        local e1 = unpack(me)
        if _TP.deref(e1.ext.tp) then
            me.val = '(('.._TP.c(e1.ext.tp)..')CEU->ext_data)'
        else
            me.val = '*((int*)CEU->ext_data)'
        end
    end,

    AwaitT = function (me)
        me.val = 'CEU->wclk_late'
    end,

    LExp = function (me)
        me.val  = me[1].val
        me.accs = me[1].accs
    end,

    Exp = function (me)
        me.val  = me[1].val
        me.accs = me[1].accs
    end,

    Func = function (me)
        me.val  = me[1].val
        me.accs = me[1].accs
    end,


    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        me.accs = {}
        accs_join(me, f)
        f.accs[1][2] = 'cl'
        for i, exp in ipairs(exps) do
            ps[i] = exp.val
            accs_join(me, exp)
            local tp = _TP.deref(exp.tp, true)
            if exp.accs and tp then
                exp.accs[1][4] = (exp.accs[1][2] ~= 'no')   -- &x does not become "any"
                exp.accs[1][2] = (me.c and me.c.mod=='pure' and 'rd') or 'wr'
                exp.accs[1][3] = tp
            end
        end
        me.val = f.val..'('..table.concat(ps,',')..')'
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
-- afb        me.val = '('..arr.val..'['..idx.val..'])'
--print('mem::Op2_idx:',arr.val,idx.val)
        me.val = arr.val 
        me.accs = {}
        accs_join(me, arr)
        accs_join(me, idx)
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        me.val = ' '
        me.accs = e1.accs
        me.accs = {}
        accs_join(me, e1)
        accs_join(me, e2)

    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        me.val = '('..ceu2c(op).. '`exp´' ..')'
        me.accs = e1.accs
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',

    ['Op1_not'] = 'Op1_any',

--    ['Op1_*'] = function (me)
--        local op, e1 = unpack(me)
--        ASR(e1.val,me,'invalid operand to unary "*"')
--        me.val = '('..ceu2c(op)..e1.val..')'
--        me.accs = e1.accs
--        me.accs[1][3] = _TP.deref(me.accs[1][3], true)
--        me.accs[1][4] = true
--    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        me.val = ' '
        me.accs = e1.accs
        me.accs[1][2] = 'no'
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        local field = _ENV.c[_TP.deref(e1.tp) or e1.tp].fields[id]
--        me.val  = '('..e1.val..ceu2c(op)..e1.fst.fields[id].var..')'
        me.val  = field.var
        me.tp   = me.tp
        me.accs = e1.accs
    end,

    Op_var = function (me)
        me.val  = me[1].val
        me.accs = me[1].accs
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.val = exp.val
        me.accs = exp.accs
        me.tp = tp
    end,

    WCLOCKK = function (me)
        local h,min,s,ms = unpack(me)
 --       me.us  = (ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h)*1000
        me.ms  = (ms*t2n.ms + s*t2n.s + min*t2n.min + h*t2n.h)
--afb        me.val = me.us
        me.val = _TP.getConstType(me.ms,me.ln)..' '..me.ms   -- uses milli
--afb        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
        ASR(me.ms>0 and me.ms<= (math.pow(2,32))-1, me, 'constant is out of range')
    end,

    WCLOCKE = function (me)
        local exp, unit = unpack(me)
        me.ms   = nil
--afb        me.val  = exp.val .. '*' .. t2n[unit] .. 'L'
        me.val  = t2idx[unit]..' '..exp.tp..' '.. (exp.val or '--')
        me.accs = exp.accs
    end,

    WCLOCKR = function (me)
        me.val = 'PTR(tceu_wclock*,CEU_WCLOCK0)['..me.awt.gte..'].togo'
    end,

    C = function (me)
        me.val = string.sub(me[1], 2)
        me.accs = { {me[1], 'rd', '_', false,
                    'symbol `'..me[1]..'´ (line '..me.ln..')'} }
    end,
    SIZEOF = function (me)
      ASR(_ENV.c[_TP.deref(me[1]) or me[1]],me,'invalid type "'.. me[1] ..'"')
      local tp = (_TP.deref(me[1]) and 'ushort') or me[1]
--print("mem::SIZEOF:",_ENV.c[tp].len,_TP.getConstType(_ENV.c[tp].len),me.ln)
--        me.val = 'sizeof('.._TP.c(me[1])..')'
      me.val = _ENV.c[tp].len
      me.tp = _TP.getConstType(_ENV.c[tp].len,me.ln)
      me.accs = me[1].accs
    end,
--    STRING = function (me)
--        me.val = me[1]
--    end,
    CONST = function (me)
        me.val = me[1]
    end,
    NULL = function (me)
        me.val = '((void *)0)'
    end,
}

_AST.visit(F)

end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

function OR_all (me, t)
    t = t or me
    me.awaits  = false
    me.returns = false
    me.blocks  = false
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.awaits  = me.awaits  or sub.awaits
            me.returns = me.returns or sub.returns
            me.blocks  = me.blocks or sub.blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.awaits  = true
    me.returns = true
    me.blocks  = true
    for _, sub in ipairs(t) do
        if _AST.isNode(sub) then
            me.awaits  = me.awaits  and sub.awaits
            me.returns = me.returns and sub.returns
            me.blocks  = me.blocks and sub.blocks
        end
    end
end

function SAME (me, sub)
    sub = sub or me[1]
    me.awaits  = sub.awaits
    me.returns = sub.returns
    me.blocks  = sub.blocks
end

F = {
    Node_pre = function (me)
        me.awaits  = false
        me.returns = false
        me.blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Block   = OR_all,
    BlockN  = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,

    Finally = SAME,

    If = function (me)
        local c, t, f = unpack(me)
        t = t or c
        f = f or c
        if me.isBounded then
            SAME(me, f)
        else
            AND_all(me, {t,f})
        end
    end,

    ParOr = AND_all,

    Break = function (me)
        me.blocks = true
    end,
    Loop = function (me)
        local body = unpack(me)
        SAME(me, body)
--print("tight::Loop:",_AST.iter'Async'(),me.isBounded,body.blocks)
        ASR(_AST.iter'Async'() or me.isBounded or body.blocks,
        --afb ASR(_AST.iter'Async'() or body.blocks,
                me,'tight loop')
        me.blocks = body.awaits or body.returns
    end,

    SetBlock = function (me)
        local _,blk = unpack(me)
        SAME(me, blk)
        me.returns = false
    end,
    Return = function (me)
        me.returns = true
        me.blocks  = true
    end,

    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.awaits = true
        me.blocks = true
    end,

    AwaitExt = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitInt = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitT = function (me)
        me.awaits = true
        me.blocks = true
    end,
    AwaitN = function (me)
        me.awaits = true
        me.blocks = true
    end,
}

_AST.visit(F)

end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_LABELS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code = '',
    gte2lbl = {},   --
}

function new (lbl)
    lbl.id = lbl[1] .. (lbl[2] and '' or '_' .. #_LABELS.list)
    lbl.id = string.gsub(lbl.id, '%$','_')

    _LABELS.list[lbl] = true
    lbl.n = #_LABELS.list                   -- starts from 0
    _LABELS.list[#_LABELS.list+1] = lbl
    lbl.par = {}                            -- { [lblK]=true }

    for n in _AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end
    return lbl
end

F = {
    Exp = function (me)
        if me.accs then
            for _, acc in ipairs(me.accs) do
                acc.lbl_ana = new{'Exp', acc=acc}
            end
        end
    end,

    Root_pre = function (me)
        new{'Inactive', true}
        new{'Init', true}
    end,

    Root = function (me)
        assert(#_LABELS.list < 2^(_ENV.c.tceu_nlbl.len*8))
        me.lbl_ana = new{'Exit'}

        -- enum of labels
        for i, lbl in ipairs(_LABELS.list) do
            _LABELS.code = _LABELS.code..'    '..lbl.id..' = '..lbl.n..',\n'
        end
    end,

    _Escape_pre = function (me)
        me.lbls_emt = { #_LABELS.list }
    end,
    _Escape = function (me)
        me.lbls_emt[2] = #_LABELS.list-1
    end,

    Prog    = '_Escape',
--    CfgBlk  = '_Escape',


    SetBlock_pre = function (me)
        F._Escape_pre(me)
        me.lbl_ana_no = new{'SetBlock_no', to_reach=false,
                            me=me, err='end of block'}
        me.lbl_out = new{'Set_out', tree=me.depth,
                        me=me, err='`return´ from block'}
        if me[1][1][1] ~= '$ret' then
            me.lbl_out.to_reach = true
        end
    end,
    SetBlock = '_Escape',

    _Par_pre = function (me)
        me.lbls_in  = {}
        for i, sub in ipairs(me) do
            me.lbls_in[i] = new{me.tag..'_sub_'..i}
            sub.lbls_all = {}
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParEver_chk'}
        me.lbl_ana_out = new{'ParEver_out'}
        me.lbl_ana_no  = new{'ParEver_no', to_reach=false,
                        me=me, err='end of `par´'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out', tree=me.depth, to_reach=true,
                        me=me, err='end of `par/or´'}
        F._Escape_pre(me)
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_ana_out = new{'ParAnd_out', to_reach=true,
                        me=me, err='end of `par/and´'}
    end,

    ParEver = function (me)
        for i=1, #me do
            local t1 = me[i].lbls_all
            for j=i+1, #me do
                local t2 = me[j].lbls_all
                for lbl1 in pairs(t1) do
                    for lbl2 in pairs(t2) do
                        lbl1.par[lbl2] = true
                        lbl2.par[lbl1] = true
                    end
                end
            end
        end
    end,
    ParAnd = 'ParEver',
    ParOr = function (me)
        F.ParEver(me)
        F._Escape(me)
    end,

    If = function (me)
        local c, t, f = unpack(me)
        me.lbl_t = new{'True'}
        me.lbl_f = f and new{'False'}
        me.lbl_e = new{'EndIf'}
    end,

    Async_pre = function (me)
        me.lbls_all = {}
    end,
    Async = function (me)
        for lbl in pairs(me.lbls_all) do
            lbl.to_reach = nil                          -- they are not simulated
        end
        me.lbl = new{'Async_'..me.gte, to_reach=true,   -- after `for´ above
                    me=me, err='`async´'}
    end,

    Loop_pre = function (me)
        me.lbl_ini = new{'Loop_ini'}
        me.lbl_ana_mid = new{'Loop_mid', to_reach=true,
                        me=me, err='`loop´ iteration'}
        me.lbl_out = new{'Loop_out', tree=me.depth }
        F._Escape_pre(me)
    end,
    Loop = '_Escape',

    EmitExtS = function (me)
        local e1 = unpack(me)
        if e1.ext.pre == 'output' then   -- e1 not Exp
            me.lbl_ana_emt = new{'Emit_'..e1.ext.id, acc=e1.acc}
        end
        me.lbl_cnt = new{'Async_cont'}
    end,
    EmitT = function (me)
        me.lbl_cnt = new{'Async_cont'}
    end,

    EmitInt = function (me)
        local int = unpack(me)
        me.lbl_ana_emt = new{'Emit_ana_emt_'..int.var.id, acc=int.accs[1]} -- int not Exp
        me.lbl_mch     = new{'Emit_mch_'..int.var.id}
        me.lbl_cnt     = new{'Emit_cnt_'..int.var.id}
        me.lbl_ana_cnt = new{'Emit_ana_cnt_'..int.var.id, to_reach=true,
                            me=me, err='continuation of `emit´'}

        -- TODO
        --if string.sub(int.var.id,1,4) == '$fin' then
            --me.lbl_cnt.to_reach = nil
        --end
    end,

    AwaitInt = function (me)
        local int = unpack(me)
        me.lbl_ana = new{'Await_ana_'..me[1][1], acc=int.accs[1]}
        me.lbl_awt = new{'Await_'..me[1][1]}
        me.lbl_awk = new{'Awake_'..me[1][1], to_reach=true,
                        me=me, err='awake of `await´'}
    end,
    AwaitT = function (me)
        if me[1].tag == 'WCLOCKE' then
          if (me[1][1][1].tag=='Var') then
            me.lbl = new{'Awake_'..me[1][1][1][1], to_reach=true,me=me, err='awake of `await´'}
          else
            me.lbl = new{'Awake_'..'exp', to_reach=true,me=me, err='awake of `await´'}
          end
        else
            me.lbl = new{'Awake_'..me[1].ms, to_reach=true,
                        me=me, err='awake of `await´'}
        end
    end,
    AwaitExt = function (me)
        me.lbl = new{'Awake_'..me[1][1], to_reach=true,
                    me=me, err='awake of `await´'}
        _LABELS.gte2lbl[me.gte] = me.lbl.n
    end,
}

_AST.visit(F)

end

--os.exit()
--    _AST.dump(_AST.root)
--print(print_r(_AST.root,"terrac: root"))
    
do
--[[
    Terra IoT System - A small Virtual Machine and Reactive Language for IoT applications.
    Copyright (C) 2014-2017  Adriano Branco
  
  This file is part of Terra IoT.
  
  Terra IoT is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Terra IoT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Terra IoT.  If not, see <http://www.gnu.org/licenses/>.  
--]]


opcode={
op_nop=0,
op_end=1,
op_bnot=2,
op_lnot=3,
op_neg=4,
op_sub=5,
op_add=6,
op_mod=7,
op_mult=8,
op_div=9,
op_bor=10,
op_band=11,
op_lshft=12,
op_rshft=13,
op_bxor=14,
op_eq=15,
op_neq=16,
op_gte=17,
op_lte=18,
op_gt=19,
op_lt=20,
op_lor=21,
op_land=22,
op_popx=23,


op_neg_f=25,
op_sub_f=26,
op_add_f=27,
op_mult_f=28,
op_div_f=29,
op_eq_f=30,
op_neq_f=31,
op_gte_f=32,
op_lte_f=33,
op_gt_f=34,
op_lt_f=35,
op_func=36,
op_outevt_e=37,
op_outevt_z=38,
op_clken_e=39,
op_clken_v=40,
op_clken_c=41,
op_set_v=42,
op_setarr_vc=43,
op_setarr_vv=44,



op_poparr_v=48,
op_pusharr_v=50,
op_getextdt_e=52,
op_trg=54,
op_exec=56,
op_chkret=58,
op_tkins_z=60,


op_push_c=64,
op_cast=68,
op_memclr=72,
op_ifelse=76,
op_asen=80,
op_tkclr=84,
op_outevt_c=88,
op_getextdt_v=92,
op_inc=96,
op_dec=100,
op_set_e=104,
op_deref=112,
op_memcpy=120,

op_tkins_max=136,
op_push_v=144,
op_pop=160,
op_outevt_v=176,
op_set_c=192,

}

typelen={
ubyte=0,byte=0,   -- 1 byte
ushort=1,short=1, -- 2 bytes
ulong=2,long=2,   -- 4 bytes
float=2,          -- 4 bytes
void=0,
}

sig={
ubyte='u',byte='s',
ushort='u',short='s',
ulong='u',long='s',
float='s',
void='u',
}
sign={
ubyte=0,byte=1,
ushort=0,short=1,
ulong=0,long=1,
float=1,
void=0,
}

vartype={
ubyte=0,byte=4,
ushort=1,short=5,
ulong=2,long=6,
float=3,
int=6,
}

--mode= 00:u32->f; 01:s32->f; 10:f->u32; 11:f->s32; 
castMode={
ulongfloat=0,
longfloat=1,
floatulong=2,
floatlong=3,
}


function OPCODE (me,line,codeA,codeB,n_stack)
	n_stack = n_stack or 0;
	code = code or '--'
	local idx=1
	LINE(me,line,0)
  local offset = table.getn(me.opcode)
	for token in string.gmatch(line, "[^%s]+") do
		me.opcode[offset+idx]=token
		me.n_stack[offset+idx]=n_stack
		n_stack = 0
		idx=idx+1
	end
    spc2 = 30 - string.len(codeA)
    if (spc2 < 0) then spc2 = 2 end
    spc2 = string.rep(' ', spc2)
    me.code2[offset+1] = (codeA or '')..spc2..'| '..(codeB or '') 
end

function BYTECODE(me,codeB,mnemonic,...)
	_OPCODES[mnemonic](me,codeB,...)
end



 _OPCODES = {

-- Generic opcode functions


-- Specific opcode functions
  -- arg={}
  op_nop= function (me,codeB)
    local bytecode = string.format('%02x',(opcode['op_nop']))
    local codeA = 'nop'
    OPCODE(me,bytecode,codeA,codeB)
  end, 

  -- arg={}
  op_end = function (me,codeB)
    local bytecode = string.format('%02x',(opcode['op_end']))
    local codeA = 'end'
    OPCODE(me,bytecode,codeA,codeB)
  end,

--[[
op_bnot= function (me,codeB,arg) end, 
op_lnot= function (me,codeB,arg) end, 
op_neg= function (me,codeB,arg) end, 
op_sub= function (me,codeB,arg) end, 
op_add= function (me,codeB,arg) end, 
op_mod= function (me,codeB,arg) end, 
op_mult= function (me,codeB,arg) end, 
op_div= function (me,codeB,arg) end, 
op_bor= function (me,codeB,arg) end, 
op_band= function (me,codeB,arg) end, 
op_lshft= function (me,codeB,arg) end, 
op_rshft= function (me,codeB,arg) end, 
op_bxor= function (me,codeB,arg) end, 
op_eq= function (me,codeB,arg) end, 
op_neq= function (me,codeB,arg) end, 
op_gte= function (me,codeB,arg) end, 
op_lte= function (me,codeB,arg) end, 
op_gt= function (me,codeB,arg) end, 
op_lt= function (me,codeB,arg) end, 
op_lor= function (me,codeB,arg) end, 
op_land= function (me,codeB,arg) end, 


op_neg_f= function (me,codeB,arg) end, 
op_sub_f= function (me,codeB,arg) end, 
op_add_f= function (me,codeB,arg) end, 
op_mult_f= function (me,codeB,arg) end, 
op_div_f= function (me,codeB,arg) end, 
op_eq_f= function (me,codeB,arg) end, 
op_neq_f= function (me,codeB,arg) end, 
op_gte_f= function (me,codeB,arg) end, 
op_lte_f= function (me,codeB,arg) end, 
op_gt_f= function (me,codeB,arg) end, 
op_lt_f= function (me,codeB,arg) end, 
--]]

  -- arg={funcID}
  op_func= function (me,codeB,funcID) 
    local bytecode = string.format('%02x',(opcode['op_func']))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(funcID))
    local codeA = 'func '..funcID
    OPCODE(me,bytecode,codeA,codeB,(-1*(_ENV.func_nArgs[funcID]))+1) -- nArgs pop's  + 1 return push
  end, 

 
  -- arg={evtId}
  op_outevt_e= function (me,codeB,evtId) 
    local bytecode=''
    local codeA = ''
      bytecode = string.format('%02x %02x',(opcode['op_outevt_e']),evtId)
      codeA = 'outevt_e '..evtId
    OPCODE(me,bytecode,codeA,codeB,-1)     
  end,
    
  -- arg={evtId}
  op_outevt_z = function (me,codeB,evtId)
    local bytecode = string.format('%02x',(opcode['op_outevt_z']))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(evtId))    
    local codeA = 'outevt_z '..evtId
    OPCODE(me,bytecode,codeA,codeB)     
  end, 
 
  -- arg={gate,unit,lblAddr}
  op_clken_e= function (me,codeB,gate,unit,lblAddr)
    local bytecode = string.format('%02x %02x',opcode['op_clken_e'],unit*(2^4)+_TP.getConstLen(gate)*(2^1)+_TP.getConstLenLbl(lblAddr)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(gate),_TP.getConstBytesLbl(lblAddr))
    local codeA = 'clken_e '..gate ..' '..unit ..' '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)     
  end,
 
 
  -- arg={gate,unit, varType, varAddr,lblAddr}
  op_clken_v= function (me,codeB,gate,unit, varType, varAddr,lblAddr)
    local bytecode = string.format('%02x %02x',opcode['op_clken_v'],unit*(2^5)+typelen[varType]*(2^3)+_TP.getConstLen(gate)*(2^2)+_TP.getConstLen(varAddr)*(2^1)+_TP.getConstLenLbl(lblAddr)*(2^0))
    bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(gate),_TP.getConstBytes(varAddr),_TP.getConstBytesLbl(lblAddr))
    local codeA = 'clken_v '..gate ..' '..unit ..' '..varType ..' '..varAddr ..' '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)     
  end,


  -- arg={gate,constTime,lblAddr}
  op_clken_c= function (me,codeB,gate,constTime,lblAddr) 
    local bytecode = string.format('%02x %02x',opcode['op_clken_c'],_TP.getConstLen(gate)*(2^3)+_TP.getConstLen(constTime)*(2^1)+_TP.getConstLenLbl(lblAddr)*(2^0))
    bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(gate),_TP.getConstBytes(constTime),_TP.getConstBytesLbl(lblAddr))
    local codeA = 'clken_c '..gate ..' '..constTime ..' '..lblAddr 
    OPCODE(me,bytecode,codeA,codeB)   
  end, 
 
  -- arg={var1Type,var2Type,var1Addr,var2Addr}  
  op_set_v= function (me,codeB,var1Type,var2Type,var1Addr,var2Addr) 
    local bytecode = string.format('%02x %02x', opcode['op_set_v'], _TP.getConstLen(var1Addr)*(2^7) + vartype[var1Type]*(2^4) + _TP.getConstLen(var2Addr)*(2^3) + vartype[var2Type]*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(var1Addr),_TP.getConstBytes(var2Addr))   
    local codeA = 'set_v' ..' ' ..var1Type ..' '..var1Addr..' ' ..var2Type  ..' '..var2Addr
    OPCODE(me,bytecode,codeA,codeB)
  end, 
 
  -- arg={arrType,arrAddr,idxType,idxAddr,idxMax,constVal}
  op_setarr_vc= function (me,codeB,arrType,arrAddr,idxType,idxAddr,idxMax,constVal) 
    local bytecode = string.format('%02x %02x %02x', 
        opcode['op_setarr_vc'], 
        _TP.getConstLen(arrAddr)*(2^7) + vartype[arrType]*(2^4) + _TP.getConstLen(idxAddr)*(2^3) + vartype[idxType]*(2^0),
        _TP.getConstLen(idxMax)*(2^2)+_TP.getConstLen(constVal)*(2^0))
    bytecode = string.format('%s %s %s %s %s',bytecode,_TP.getConstBytes(arrAddr),_TP.getConstBytes(idxAddr),_TP.getConstBytes(idxMax),_TP.getConstBytes(constVal))
    local codeA = 'setarr_vc '..arrType ..' '..arrAddr ..' '..idxType ..' '..idxAddr ..' '..idxMax ..' '..constVal
    OPCODE(me,bytecode,codeA,codeB)
  end, 
 
  -- arg={arrType,arrAddr,idxType,idxAddr,idxMax,varType,varAddr}
  op_setarr_vv= function (me,codeB,arrType,arrAddr,idxType,idxAddr,idxMax,varType,varAddr) 
    local bytecode = string.format('%02x %02x %02x', 
        opcode['op_setarr_vv'], 
        _TP.getConstLen(arrAddr)*(2^7) + vartype[arrType]*(2^4) + _TP.getConstLen(idxAddr)*(2^3) + vartype[idxType]*(2^0),
        _TP.getConstLen(idxMax)*(2^4) + _TP.getConstLen(varAddr)*(2^3) + vartype[varType]*(2^0))
    bytecode = string.format('%s %s %s %s %s',bytecode,_TP.getConstBytes(arrAddr),_TP.getConstBytes(idxAddr),_TP.getConstBytes(idxMax),_TP.getConstBytes(varAddr))
    local codeA = 'setarr_vv '..arrType ..' '..arrAddr ..' '..idxType ..' '..idxAddr ..' '..idxMax ..' '..varType ..' '..varAddr
    OPCODE(me,bytecode,codeA,codeB)
  end, 



  -- arg={varType,idxType,idxAddr,ArrSize,ArrAddr}
  op_poparr_v= function (me,codeB,varType,idxType,idxAddr,ArrSize,ArrAddr)
    local bytecode = string.format('%02x %02x',
      (opcode['op_poparr_v'])+_TP.getConstLen(ArrSize)*(2^0),
      (_TP.getConstLen(ArrAddr)*(2^7) + vartype[varType]*(2^4) + _TP.getConstLen(idxAddr)*(2^3) + vartype[idxType]*(2^0)))
    bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(ArrAddr),_TP.getConstBytes(idxAddr),_TP.getConstBytes(ArrSize))
    local codeA = 'poparr_v '..varType ..' '..ArrAddr ..' '..idxType ..' '..idxAddr ..' '..ArrSize
    OPCODE(me,bytecode,codeA,codeB,-1)  
  end, 
  
  -- arg={varType,idxType,idxAddr,ArrSize,ArrAddr}
  op_pusharr_v= function (me,codeB,varType,idxType,idxAddr,ArrSize,ArrAddr)
    local bytecode = string.format('%02x %02x',
      (opcode['op_pusharr_v'])+_TP.getConstLen(ArrSize)*(2^0),
      (_TP.getConstLen(ArrAddr)*(2^7) + vartype[varType]*(2^4) + _TP.getConstLen(idxAddr)*(2^3) + vartype[idxType]*(2^0)))
    bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(ArrAddr),_TP.getConstBytes(idxAddr),_TP.getConstBytes(ArrSize))
    local codeA = 'pusharr_v '..varType ..' '..ArrAddr ..' '..idxType ..' '..idxAddr ..' '..ArrSize
    OPCODE(me,bytecode,codeA,codeB,1)
  end,

  -- arg={size}
  op_getextdt_e= function (me,codeB,size)
    local bytecode = string.format('%02x',(opcode['op_getextdt_e']) + _TP.getConstLen(size))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(size))
    local codeA = 'getextdt_e '..size
    OPCODE(me,bytecode,codeA,codeB)   
  end, 

  -- arg={gate}
  op_trg= function (me,codeB,gate) 
    local bytecode = string.format('%02x',(opcode['op_trg'])+(_TP.getConstLen(gate)))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(gate))
    local codeA = 'trg '..gate
    OPCODE(me,bytecode,codeA,codeB) 
  end,

  -- arg={lblAddr}
  op_exec = function (me,codeB,lblAddr)
    local bytecode = string.format('%02x',(opcode['op_exec'])+(_TP.getConstLenLbl(lblAddr)))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytesLbl(lblAddr))
    local codeA = 'exec '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)
  end,
  
  -- arg={lblAddr}
  op_chkret= function (me,codeB,lblAddr)
    local bytecode = string.format('%02x',(opcode['op_chkret'])+(_TP.getConstLen(lblAddr)))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(lblAddr)) -- Não marcar como Label, já aponta diretor para memória de dados.
    local codeA = 'chkret '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)
  end,


  -- arg={ConstValue}
  op_push_c= function (me,codeB,ConstValue)
    local bytecode = string.format('%02x',(opcode['op_push_c'])+_TP.getConstLen(ConstValue))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(ConstValue))
    local codeA = 'push_c '..ConstValue
    OPCODE(me,bytecode,codeA,codeB,1)
  end,

  -- arg={fromType,toType}
  op_cast= function (me,codeB,fromType,toType)      
    local bytecode = string.format('%02x',(opcode['op_cast'])+(castMode[fromType .. toType] or 0)*(2^0))
    local codeA = 'cast '..fromType ..' '..toType .. ' ('.. (castMode[fromType .. toType] or "--")..')'
    OPCODE(me,bytecode,codeA,codeB)
  end,

  -- arg={size,addr}
  op_memclr = function (me,codeB,size,addr)
    local bytecode = string.format('%02x',(opcode['op_memclr']) + _TP.getConstLen(addr)*(2^1) + _TP.getConstLen(size)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(addr),_TP.getConstBytes(size))
    local codeA = 'memclr '..addr ..' '..size
    OPCODE(me,bytecode,codeA,codeB)
  end,

  -- arg={lblTAddr,lblFAddr}
  op_ifelse= function (me,codeB,lblTAddr,lblFAddr) 
    local bytecode = string.format('%02x',(opcode['op_ifelse']) + _TP.getConstLenLbl(lblTAddr)*(2^1) + _TP.getConstLenLbl(lblFAddr)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytesLbl(lblTAddr),_TP.getConstBytesLbl(lblFAddr))
    local codeA = 'ifelse '..lblTAddr ..' '..lblFAddr
    OPCODE(me,bytecode,codeA,codeB,-1)      
  end, 

  -- arg={gate,lblAddr)
  op_asen= function (me,codeB,gate,lblAddr)
    local bytecode = string.format('%02x',(opcode['op_asen']) + _TP.getConstLen(gate)*(2^1) + _TP.getConstLenLbl(lblAddr)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(gate),_TP.getConstBytesLbl(lblAddr))
    local codeA = 'asen '..gate ..' '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)   
  end, 

  -- arg={lbl1Addr,lbl2Addr}
  op_tkclr= function (me,codeB,lbl1Addr,lbl2Addr) 
    local bytecode = string.format('%02x',(opcode['op_tkclr']) + _TP.getConstLenLbl(lbl1Addr)*(2^1) + _TP.getConstLenLbl(lbl2Addr)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytesLbl(lbl1Addr),_TP.getConstBytesLbl(lbl2Addr))
    local codeA = 'tkclr '..lbl1Addr ..' '..lbl2Addr
    OPCODE(me,bytecode,codeA,codeB)     
  end, 
 
  -- arg={evtId,constVal}
  op_outevt_c = function (me,codeB,evtId,constVal)
    local bytecode = string.format('%02x',(opcode['op_outevt_c']) + _TP.getConstLen(constVal)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(evtId),_TP.getConstBytes(constVal))   
    local codeA = 'outevt_c '..evtId..' '..constVal
    OPCODE(me,bytecode,codeA,codeB)     
  end, 

  -- arg={addr,size}
  op_getextdt_v= function (me,codeB,addr,size)
    local bytecode = string.format('%02x',(opcode['op_getextdt_v']) + _TP.getConstLen(addr)*(2^1) + _TP.getConstLen(size)*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(addr),_TP.getConstBytes(size))
    local codeA = 'getextdt_v '..addr ..' '..size
    OPCODE(me,bytecode,codeA,codeB)   
  end, 
 
  -- arg={type}
  op_inc= function (me,codeB,type)
    local bytecode = string.format('%02x',(opcode['op_inc'])+(typelen[type] or '0' )*(2^0))
    local codeA = 'inc'..' '..type
    OPCODE(me,bytecode,codeA,codeB,-1)
  end, 

  -- arg={type}
  op_dec= function (me,codeB,type)      
    local bytecode = string.format('%02x',(opcode['op_dec'])+(typelen[type] or '0' )*(2^0))
    local codeA = 'dec'..' '..type
    OPCODE(me,bytecode,codeA,codeB,-1)
  end, 
 
  -- arg={type}
  op_set_e= function (me,codeB,type) 
    local bytecode = string.format('%02x',(opcode['op_set_e'])+vartype[type]*(2^0))
    local codeA = 'set_e'..' '.. type
    OPCODE(me,bytecode,codeA,codeB,-2)
  end,
 
  -- arg={type}
  op_deref= function (me,codeB,type)      
    local bytecode = string.format('%02x',(opcode['op_deref'])+vartype[type]*(2^0))
    local codeA = 'deref '..type
    OPCODE(me,bytecode,codeA,codeB)
  end, 

  -- arg={size,addrFrom,addrTo}
  op_memcpy= function (me,codeB,size,addrFrom,addrTo)
  local bytecode = string.format('%02x',(opcode['op_memcpy']) + _TP.getConstLen(size)*(2^2) + _TP.getConstLen(addrFrom)*(2^1) + _TP.getConstLen(addrTo)*(2^0))
  bytecode = string.format('%s %s %s %s',bytecode,_TP.getConstBytes(size),_TP.getConstBytes(addrFrom),_TP.getConstBytes(addrTo))
  local codeA = 'memcpy '..size ..'B. '..addrFrom ..' -> '.. addrTo
  OPCODE(me,bytecode,codeA,codeB)   
  end, 

 
  -- arg={chk,tree,lblAddr)
  op_tkins_z= function (me,codeB,chk,tree,lblAddr) 
    local bytecode = string.format('%02x %02x',(opcode['op_tkins_z']) + _TP.getConstLenLbl(lblAddr)*2^0, chk*(2^7)+tree*(2^0))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytesLbl(lblAddr))   
    local codeA = 'tkins_z '..chk ..' '..tree ..' '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)       
  end, 
 
  -- arg={stack,lblAddr)
  op_tkins_max= function (me,codeB,stack,lblAddr) 
    local bytecode = string.format('%02x',(opcode['op_tkins_max']) +  stack*(2^1) + _TP.getConstLenLbl(lblAddr)*2^0)
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytesLbl(lblAddr))    
    local codeA = 'tkins_max '..stack..' '..lblAddr
    OPCODE(me,bytecode,codeA,codeB)     
  end, 
 
  -- arg={type,addr}
  op_push_v= function (me,codeB,type,addr)
    local bytecode=''
    bytecode = string.format('%02x',(opcode['op_push_v'])+_TP.getConstLen(addr)*(2^3)+vartype[type]*(2^0))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(addr))
    local codeA = 'push_v'..' '..type ..' '..addr
    OPCODE(me,bytecode,codeA,codeB,1)
  end,
 
  -- arg={type,addr}
  op_pop= function (me,codeB,type,addr) 
    local bytecode = string.format('%02x',(opcode['op_pop'])+_TP.getConstLen(addr)*(2^3)+vartype[type]*(2^0))
    bytecode = string.format('%s %s',bytecode,_TP.getConstBytes(addr))
    local codeA = 'pop'..' '..type ..' '..addr
    OPCODE(me,bytecode,codeA,codeB,-1)
  end,

  -- arg={type,addr}
  op_popx= function (me,codeB) 
    local bytecode = string.format('%02x',(opcode['op_popx']))
    local codeA = 'popx'
    OPCODE(me,bytecode,codeA,codeB,-1)
  end,

  -- arg={evtId,varAddr,type}
  op_outevt_v= function (me,codeB,evtId,varAddr,type) 
    local bytecode = string.format('%02x',(opcode['op_outevt_v'])+_TP.getConstLen(varAddr)*(2^3)+vartype[type]*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(evtId),_TP.getConstBytes(varAddr))   
    local codeA = 'outevt_v '..evtId ..' '..varAddr
    OPCODE(me,bytecode,codeA,codeB)     
  end,
 
  -- arg={varType,varAddr,constVal,lblAddr}
  op_set_c= function (me,codeB,varType,varAddr,constVal,lblAddr) 
    local bytecode = string.format('%02x',(opcode['op_set_c']) + ((lblAddr and 1) or _TP.getConstLen(constVal))*(2^4) +_TP.getConstLen(varAddr)*(2^3)+vartype[varType]*(2^0))
    bytecode = string.format('%s %s %s',bytecode,_TP.getConstBytes(varAddr),(lblAddr and _TP.getConstBytesLbl(constVal)) or _TP.getConstBytes(constVal))
    local codeA = 'set_c '..varType..' '..varAddr..' '.. constVal
    OPCODE(me,bytecode,codeA,codeB)     
  end,


 	-- arg={lblAddr} 	
	lbl = function (me,codeB,lblAddr)
		local bytecode = string.format('L%04x',lblAddr)
		local codeA = bytecode
		OPCODE(me,bytecode,codeA,codeB)
	end,

------
-- Deprecated
-- 
--[[
  -- arg={}
  op_any = function (me,codeB,arg)
--print("asm::op_any:",arg[1],arg[2],arg[3])
    local bytecode = string.format('%02x %02x',(opcode['op_'..arg[1] ])+(typelen[arg[3] ] or '0' ),arg[2])
    local codeA = arg[1]..' '..arg[3]..' '..arg[2]
    OPCODE(me,bytecode,codeA,codeB)
  end,
--]]

 	-- arg={oper}
	op1_any = function (me,codeB,oper)
		local bytecode = string.format('%02x',(opcode['op_'..oper]))
		local codeA = oper
		OPCODE(me,bytecode,codeA,codeB)
	end,

 	-- arg={oper}
	op2_any = function (me,codeB,oper)
--print(unpack(arg))
		local bytecode = string.format('%02x',(opcode['op_'..oper]))
		local codeA = oper
		OPCODE(me,bytecode,codeA,codeB,-1)
	end,

}



end

    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

_CODE = {
    labels = { 'Inactive', 'Init' },
    host   = '',
}



function CONC_ALL (me)
    for _, sub in ipairs(me) do
--DBG('@ ',(sub.tag or '-'),sub)
        if _AST.isNode(sub) then
--DBG('- '.._AST.isNode(sub))
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
    CONC_OP(me,sub)
end

function CONC_OP (me, sub)
    sub = sub or me[1]
    local offset = table.getn(me.opcode)
    for idxb,value in ipairs(sub.opcode) do
    	me.opcode[offset+idxb] = value
    	me.code2[offset+idxb] = sub.code2[idxb]
    	me.n_stack[offset+idxb] = sub.n_stack[idxb]
    end
end

--function ATTR (me, n1, n2)
--    if not _OPTS.analysis_run then
--        LINE(me,'//> '..n1.val..' = '..n2.val..';')
--        LINE(me,n2.code..' // TODO ? pop_'..n1.tp..n1.code..';')
--    end
--end

--function EXP (me, e)
--    if _OPTS.analysis_run and e.accs then
--        for _, acc in ipairs(e.accs) do
--            SWITCH(me, acc.lbl_ana)
--            CASE(me, acc.lbl_ana)
--        end
--    end
--end

function CASE (me, lbl)
    --LINE(me, '//> case '..lbl.id..':', 0)
    codeB = LINE(me, lbl.id..':', 0)
    BYTECODE(me,codeB,'lbl',lbl.n)
end

function LINE (me, line, spc,comment)
    spc = spc or 4
    spc = string.rep(' ', spc)
    spc2 = 30 - string.len(line) - string.len(spc)
    if (spc2 < 0) then spc2 = 2 end
    spc2 = string.rep(' ', spc2)
    me.code = me.code .. spc .. line .. spc2 .. (comment or '') .. '\n'
	return line
end

function HALT (me)
    --LINE(me, '//> break;')
    codeB = LINE(me, 'end')
    BYTECODE(me,codeB,'op_end')
end

function SWITCH (me, lbl)
--    LINE(me, [[
--//> _lbl_ = ]]..lbl.id..[[;
--//> goto _SWITCH_;
--]])
    codeB = LINE(me,'goto '..' '..lbl.n, nil,'// goto '..lbl.id)
    BYTECODE(me,codeB,'op_exec',lbl.n)
end

function COMM (me, comm)
    LINE(me, '// /* '..comm..' */', 0)
end

function BLOCK_GATES (me)
    -- TODO: test if out is reachable, test if has inner parallel
    -- in both cases, no need to run anything

    CASE(me, me.lbl_out)
--    COMM(me, 'close gates')

    -- do not resume inner ASYNCS
    local n = me.gtes.asyncs[2] - me.gtes.asyncs[1]
    if n > 0 then
--        LINE(me, '//> memset(PTR(char*,CEU_ASYNC0) + '
--                    ..me.gtes.asyncs[1]..'*sizeof(tceu_nlbl), 0, '
--                    ..n..'*sizeof(tceu_nlbl));')
        codeB = LINE(me, 'clear asyncs gates from '..me.gtes.asyncs[1]..' to '..me.gtes.asyncs[2],nil,'// close gates') 
        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len, _MEM.gtes.async0 +me.gtes.asyncs[1]*_ENV.c.tceu_nlbl.len)
    end

    -- do not resume inner WCLOCKS
    local n = me.gtes.wclocks[2] - me.gtes.wclocks[1]
    if n > 0 then
--        LINE(me, '//> memset(PTR(char*,CEU_WCLOCK0) + '
--                    ..me.gtes.wclocks[1]..'*sizeof(tceu_wclock), 0, '
--                    ..n..'*sizeof(tceu_wclock));')
        codeB = LINE(me, 'clear WClocks gates from '..me.gtes.wclocks[1]..' to '..me.gtes.wclocks[2],nil,'// close gates') 
        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_wclock.len, _MEM.gtes.wclock0 + me.gtes.wclocks[1]*_ENV.c.tceu_wclock.len)
    end

    -- stop awaiting inner EXTS
    for _, ext in ipairs(_ENV.exts) do
        local t = me.gtes[ext]
        if t then
            local n = t[2] - t[1]
            if n > 0 then
--                LINE(me, '//> memset(PTR_EXT(IN_'..ext.id..','..t[1]..'), 0, '
--                    ..n..'*sizeof(tceu_nlbl));')
            local gateLen = ((ext.inArg and 1) or 0) + 2
		        codeB = LINE(me, 'clear EXT gates for '..ext.id..'['.. t[1] ..']',nil,'// stop awaiting inner externals') 
		        BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len + ((ext.inArg and 1) or 0), _MEM.gtes[ext.n]+2+t[1]*gateLen)
            end
        end
    end

    -- stop awaiting inner internal events
    for blk in _AST.iter'Block' do
        for _, var in ipairs(blk.vars) do
            if me.gtes[var] then
                local t = me.gtes[var]
                local n = t[2] - t[1]
                if n > 0 then
--                    LINE(me, '//> memset(CEU->mem+'..var.awt0..'+1+'
--                            ..t[1]..'*sizeof(tceu_nlbl), 0, '
--                            ..n..'*sizeof(tceu_nlbl));')
			        codeB = LINE(me, 'clear Internal gates for '..var.id,nil,'// stop awaiting inner intenals') 
					BYTECODE(me,codeB,'op_memclr', n*_ENV.c.tceu_nlbl.len, var.awt0 + 1 + t[1] * _ENV.c.tceu_nlbl.len)
                end
            end
        end
    end

    -- do not resume inner EMITS continuations (await/emit)
    -- TODO: check if needed
    if _PROPS.has_emits then
--        LINE(me, '//> ceu_track_clr('..me.lbls_emt[1]..','..me.lbls_emt[2]..');')

-- Testando sem o TkClr
--        codeB = LINE(me, 'clear tracks from label '..me.lbls_emt[1]..' to label '..me.lbls_emt[2],nil,'// do not resume inner EMITS continuations (await/emit)') 
--    		BYTECODE(me,codeB,'op_tkclr',me.lbls_emt[1],me.lbls_emt[2])
    end
end

--function PAUSE (me, N, PTR)
--    if me.more then
--        LINE(me, [[
--{ short i;
--for (i=0; i<]]..N..[[; i++) {
--    if (]]..PTR..'['..i..']'..[[ >= Init) {
--        ]]..PTR..'['..i..']'..[[ = Init-1;
--    } else {
--        ]]..PTR..'['..i..']'..[[--;
--    }
--} }
--]])
--    else
--        LINE(me, [[
--{ short i;
--for (i=0; i<]]..N..[[; i++) {
--    if (]]..PTR..'['..i..']'..[[ >= Init) {
--        ]]..PTR..'['..i..']'..[[ = Init-1;
--    } else {
--        ]]..PTR..'['..i..']'..[[--;
--    }
--} }
--]])
--    end
--end


function getAuxValues(e1)
    -- Calculate aux memory access
--print("code::getAuxValues: tags",e1.tag,e1[1].tag,e1[1][1])
    local x1
    x1={}
    x1.tag = e1.tag
    x1.tp = e1.tp
    x1.ntp = (_TP.deref(e1.tp) and 'ushort') or e1.tp  -- Redefine tp if it is a pointer
   
    -- **********************************************************
    -- * auxtag3 computation from _TP.getAuxTag() used in env.lua
    -- **********************************************************
    local z1 = _TP.getAuxTag(e1.tp,e1[1].arr)
    x1.auxtag3 = z1.auxtag

    -- **********************************
    -- * x1 parameter table computation 
    -- **********************************
    if not (e1.tag == 'AwaitInt') then   
      if e1[1].tag == 'CONST' then
          x1.auxtag1 = 'Const'
          x1.auxtag2 = 'Const'
          x1.val = e1.val
          x1.auxval = (x1.ntp=='float' and _TP.float2hex(tonumber(e1.val)))
--print("code::getAuxValues:",x1.val,x1.auxval)
          x1.id = e1.val
      elseif e1[1].tag == 'Var' then -- Var/Var*, Reg/Reg*
        if _TP.isBasicType(_TP.deref(e1.tp) or e1.tp) then
          if _TP.deref(e1.tp) then -- Var*
            if (e1[1].arr) then
              x1.auxtag1 = 'Arr'
              x1.auxtag2 = 'Var*'
              x1.val = e1.val
              x1.id = (e1.fst and e1.fst.id) or e1[1][1]
              x1.arr = e1[1].arr
            else
              x1.auxtag1 = 'Var*'
              x1.auxtag2 = 'Var*'
              x1.val = e1.val
              x1.id = (e1.fst and e1.fst.id) or e1[1][1]
            end
          else -- Var
            x1.auxtag1 = 'Var'
            x1.auxtag2 = 'Var'
            x1.val = e1.val
            x1.id = (e1.fst and e1.fst.id) or e1[1][1]
          end    
        else  -- Reg/Reg* (without field)
          if _TP.deref(e1.tp) then -- Reg*
            x1.auxtag1 = 'Reg*'
            x1.auxtag2 = 'Var*'
            x1.val = e1.val
            x1.id = (e1.fst and e1.fst.id) or e1[1][1]
          else -- Reg
            x1.auxtag1 = 'Reg'
            x1.auxtag2 = 'Reg'
            x1.val = e1.val
            x1.id = (e1.fst and e1.fst.id) or e1[1][1]
          end
        end
      elseif e1[1].tag == 'Op1_&' then
        if (e1[1][2].tag == 'Var') then
--print("code::getAuxValues: Pointer = &Var,",e1[1][2].tag,e1.tp,e1[1][2][1]) -- TODO fazer um set_v addr, mas tem que testar Var/Var.Field/Var.Field[idx]/var[idx]/???var[]/Var.Fieled[]
          if(_TP.deref(e1.tp)) then
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var*'
            x1.val = e1[1][2].val
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][1]
          else
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var'
            x1.val = e1[1][2].val
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][1]
          end
        elseif (e1[1][2].tag == 'Op2_idx'  and e1[1][2][2].tag == 'Var') then
--print("code::getAuxValues: Pointer = &Op2_idx Var : ,",e1[1][2][2].tag,e1.tp,e1[1][2][3].val) 
          if(_TP.deref(e1.tp)) then
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var*'
            x1.val = e1[1][2].val + e1[1][2][3].val
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][2][1]..'['.. e1[1][2][3].val ..']'
          else
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var'
            x1.val = e1[1][2].val
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][1]
          end
        elseif (e1[1][2].tag == 'Op2_idx'  and e1[1][2][2].tag == 'Op2_.' and e1[1][2][3].tag == 'CONST') then
          local field = _ENV.c[_TP.deref(e1[1][2][2][2].tp) or e1[1][2][2][2].tp].fields[e1[1][2][2][3]]
--print("code::getAuxValues: Pointer = &Op2_idx Filed : ",e1[1][2][2][2].tag,e1[1][2][2][2][1],field.id,e1[1][2][2][2].val,field.offset,e1[1][2][3].tag,e1[1][2][3].val) 
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var*'
            x1.val = e1[1][2][2][2].val + field.offset + e1[1][2][3].val
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][2][2][1]..'.'.. field.id..'['.. e1[1][2][3].val ..']'
        elseif (e1[1][2].tag == 'Op2_.' and e1[1][2][2].tag == 'Var') then
          local field = _ENV.c[_TP.deref(e1[1][2][2].tp) or e1[1][2][2].tp].fields[e1[1][2][3]]
--print("code::getAuxValues: Pointer = &Op2_. Var : ",e1[1][2][2].tag,e1.tp,e1[1][2][2][1],field.id,e1[1][2][2].val,field.offset) 
            x1.auxtag1 = 'Var*'
            x1.auxtag2 = '&Var*'
            x1.val = e1[1][2][2].val + field.offset
            x1.tp = e1.tp
            x1.id = '&'.. e1[1][2][2][1]..'.'.. field.id
        else
          x1.auxtag1 = 'Exp'
          x1.auxtag2 = 'Exp'
        end
      elseif e1[1].tag == 'Op2_.' then
          local field = _ENV.c[_TP.deref(e1[1][2].tp) or e1[1][2].tp].fields[e1[1][3]]
          if _TP.deref(e1[1][2].tp) then -- Var*.field
--  print("code::getAuxValues: Var.field",e1[1][2].tp,e1[1][2].val,field.offset)
            x1.auxtag1 = 'Exp'
            x1.auxtag2 = 'Exp'
          else
            if field.dim then -- Var.Field[] (without index)
              x1.auxtag1 = 'Var.field*'
              x1.auxtag2 = 'Var*'
              x1.val = e1[1][2].val+field.offset
              x1.id = e1[1][2][1]..'.'..e1[1][3]
              x1.arr = field.dim
            else
--  print("code::getAuxValues: Var.field",e1[1][2].tp,e1[1][2].val,field.offset)
              x1.auxtag1 = 'Var.field'
              x1.auxtag2 = 'Var'
              x1.val = e1[1][2].val+field.offset
              x1.id = e1[1][2][1]..'.'..e1[1][3]
            end
          end
        elseif e1[1].tag == 'Op2_idx' then
        if e1[1][2].tag == 'Var' then
          if _TP.deref(_TP.deref(e1[1][2].tp)) then
            if e1[1][3].tag == 'CONST' then
--  print("code::getAuxValues: Var*[idx]",e1[1][2].tag,e1[1][2].tp,e1[1][3].tag)
              x1.auxtag1 = 'Var*[idx]'
              x1.auxtag2 = 'Var*'
              x1.val = e1[1][2].val+(e1[1][3].val*_ENV.c[x1.ntp].len)
              x1.id = e1[1][2][1]..'*['..e1[1][3].val..']'
            elseif e1[1][3].tag == 'Var' then
 -- print("code::getAuxValues: Var*[Var]",e1[1][2].tag,e1[1][2].tp,e1[1][3].tag,e1[1][3].tp,e1[1][3].val,e1.fst.arr)
              x1.auxtag1 = 'Var*[Var]'
              x1.auxtag2 = 'Var*[Var]'
              x1.val = e1[1][2].val
              x1.id = e1[1][2][1]..'*['..e1[1][3][1]..']'
              x1.idxval = e1[1][3].val
              x1.idxtp = e1[1][3].tp
              x1.idxmax = e1.fst.arr            
            else
              x1.auxtag1 = 'Exp'
              x1.auxtag2 = 'Exp'
            end
          else
            if e1[1][3].tag == 'CONST' then
 -- print("code::getAuxValues: Var[idx]",e1[1][2].tag,e1[1][2].tp,e1[1][3].tag)
              x1.auxtag1 = 'Var[idx]'
              x1.auxtag2 = 'Var'
              x1.val = e1[1][2].val+(e1[1][3].val*_ENV.c[x1.ntp].len)
              x1.id = e1[1][2][1]..'['..e1[1][3].val..']'
            elseif e1[1][3].tag == 'Var' then
 -- print("code::getAuxValues: Var[Var]",e1[1][2].tag,e1[1][2].tp,e1[1][3].tag,e1[1][3].tp,e1[1][3].val,e1.fst.arr)
              x1.auxtag1 = 'Var[Var]'
              x1.auxtag2 = 'Var[Var]'
              x1.val = e1[1][2].val
              x1.id = e1[1][2][1]..'['..e1[1][3][1]..']'
              x1.idxval = e1[1][3].val
              x1.idxtp = e1[1][3].tp
              x1.idxmax = e1.fst.arr
            else
              x1.auxtag1 = 'Exp'
              x1.auxtag2 = 'Exp'
            end
          end
        elseif e1[1][2].tag == 'Op2_.' then
          local field = _ENV.c[_TP.deref(e1[1][2][2].tp) or e1[1][2][2].tp].fields[e1[1][2][3]]
          if _TP.deref(e1[1][2][2].tp) then
            x1.auxtag1 = 'Exp'
            x1.auxtag2 = 'Exp'
          else
            if e1[1][3].tag == 'CONST' then
--print("code::getAuxValues: Var.field[idx]",e1[1][2][2].val,field.offset,(e1[1][3].val*_ENV.c[x1.ntp].len))
              x1.auxtag1 = 'Var.field[idx]'
              x1.auxtag2 = 'Var'
              x1.val = e1[1][2][2].val + field.offset + (e1[1][3].val*_ENV.c[x1.ntp].len)
              x1.id = e1[1][2][2][1]..'.'..e1[1][2][3]..'['..e1[1][3].val..']'
            else
              x1.auxtag1 = 'Exp'
              x1.auxtag2 = 'Exp'
            end
          end
        else
          x1.auxtag1 = 'Exp'
          x1.auxtag2 = 'Exp'
        end
      else
        x1.auxtag1 = 'Exp'
        x1.auxtag2 = 'Exp'
      end
    else -- AwaitInt
      x1.auxtag1 = 'Var'
      x1.auxtag2 = 'AwaitInt'
      x1.val = e1.val
      x1.id = (e1.fst and e1.fst.id) or e1[1][1]
    end
--print("code::getAuxValues:-->:",x1.tag,x1.auxtag1,x1.auxtag2,x1.auxtag3)
--print("code::getAuxValues:var:",x1.tp,x1.ntp,x1.val,x1.id,x1.arr)
--print("code::getAuxValues:idx:",x1.idxval,x1.idxtp,x1.idxmax)
  return x1
end

function tryDerefCode(me,tag,tp)
    local ntp = (_TP.deref(tp) and 'ushort') or tp
--print("code::tryDerefCode:",tag,tp, ntp,me.tag)
    if (  tag == 'Op2_idx' or tag == 'Op2_.')
     then
      codeB = LINE(me,'deref '..tp,nil,'// deref Var ')
      BYTECODE(me,codeB,'op_deref',ntp)
    end
end

function Op1_any(me,mnemonic)
    local op, e1 = unpack(me)
		CONC(me,e1)
--print("code::Op1_any",e1.tag)
    mnemonic = (e1.tp=='float' and opcode['op_'..mnemonic..'_f'] and mnemonic..'_f') or mnemonic 
    codeB = LINE(me,mnemonic,nil,'// stack0 = '..mnemonic..'(stack0)')
    BYTECODE(me,codeB,'op1_any',mnemonic)
end

function Op2_any(me,mnemonic)
    local op, e1, e2 = unpack(me)
--print("code::Op2_any:",op,e1.tag,e1.tp,e2.tag,e2.tp,e1.arr,e2.arr,_TP.max(e1.tp,e2.tp))
  local err,cast, _, _, len1, len2 = _TP.tpCompat(e1.tp,e2.tp,e1.arr,e2.arr)
  ASR(not err ,me,'type/size incompatibility: "'..e1.tp..'/'..len1 .. '" <--> "'..e2.tp..'/'..len2)
  --WRN(not cast,me,'automatic cast from ['.. e2.tp ..'] to [' .. e1.tp ..'].')
  local maxTp =  _TP.max(e1.tp,e2.tp)
  local toTp = _TP.getCastType(maxTp)  
  local from2Tp = _TP.getCastType(e2.tp)  
  local from1Tp = _TP.getCastType(e1.tp) 

--print("code::Op2_any:",toTp,opcode['op_'..mnemonic..'_f'],mnemonic..'_f')  
  mnemonic = (toTp=='float' and opcode['op_'..mnemonic..'_f'] and mnemonic..'_f') or mnemonic 
  -- exp 2
	CONC(me,me[3])
  tryDerefCode(me,e2.tag,e2.tp)
  if (from2Tp~=toTp and (from2Tp=='float' or toTp=='float')) then
--print("code::Op2_any: cast exp2",e1.tp,e2.tp,from2Tp,toTp)
    codeB = LINE(me,'cast '..from2Tp..' '..toTp,nil,'// cast <type> ')
    BYTECODE(me,codeB,'op_cast',from2Tp,toTp)
  end
  -- exp 1
	CONC(me,me[2])
  tryDerefCode(me,e1.tag,e1.tp)
  if (from1Tp~=toTp and (from1Tp=='float' or toTp=='float')) then
--print("code::Op2_any: cast exp1",e1.tp,e2.tp,from2Tp,toTp)
    codeB = LINE(me,'cast '..from1Tp..' '..toTp,nil,'// cast <type> ')
    BYTECODE(me,codeB,'op_cast',from1Tp,toTp)
  end
  -- operation
	codeB = LINE(me,mnemonic,nil,'// stack0 = stack0 '..mnemonic..' stack1')
  BYTECODE(me,codeB,'op2_any',mnemonic)
end

function INC_STACK()
	_AST.root.n_stack=_AST.root.n_stack+1;
	_AST.root.max_stack = math.max(_AST.root.max_stack,_AST.root.n_stack)
--print('inc stack=',_AST.root.max_stack,_AST.root.n_stack)
end
function DEC_STACK()
	_AST.root.n_stack=_AST.root.n_stack-1;
end
function CLR_STACK()
	_AST.root.n_stack=0;
end

-- *******************************************************
-- * -- SetExp() function                                *
-- * -- Code generation for different kinds of SetExp -- *
-- *                                                     *
-- *  Includes code optimization for simple attribution  *
-- *******************************************************
function SetExp(me)
    local e1, e2 = unpack(me)
--print("code::SetExp():",e1.tag,e2.tag,e1[1].tag,e2[1].tag,e1.arr,e2.arr)

    local x1 = getAuxValues(e1)
    local x2 = getAuxValues(e2)

--print("code::SetExp: e1:",x1.auxtag1,x1.auxtag2, x1.tp, x1.ntp, x1.val,x1.id)
--print("code::SetExp: e2:",x2.auxtag1,x2.auxtag2, x2.tp, x2.ntp, x2.val,x2.id)

-- ********************************************************
-- *** getAuxValues() translation: tag -> auxtag2; auxtag3
-- *******************************************************
-----------------------------------------------------
-- CONST                  -> Const
-- Var & BasicType        -> Var
-- Var* & BasicType & arr -> Var* & arr
-- Var & ~BasicType       -> Reg
-- Var* & ~BasicType      -> Var*
-- Var[Const]             -> Var
-- Var*[Const]            -> Var*
-- Var[Var|Exp]           -> Exp
-- Var*[Var|Exp]          -> Exp
-- Var.Field              -> Var
-- Var.Field & arr        -> Var*
-- Var*.Field             -> Exp
-- Var.Field[Const]       -> Var
-- Var*.Field[Const       -> Exp
-- Var.Field[Var|Exp]     -> Exp
-- Var*.Field[Var|Exp]    -> Exp
-- AwaitInt               -> AwaitInt  ... used in SetAwait
-- &Var                   -> &Var
-- &Var*                  -> &Var*
-----------------------------------------------------

--  type            -> auxtag3;    tp;   size   (from _TP.tpCompat() used in 'env.lua')
-----------------------------------------------------
-- reg*             -> pointer;   ushort;   reg len
-- reg              -> data;      reg;      reg len
-- tpBasic          -> var;       tp;       tp len
-- tpBasic* + ~arr  -> pointer;   ushort;   arr*tp
-- tpBasic* +  arr  -> data;      arr*tp;   arr*tp
-- tpBasic** + ~arr -> pointer;   ushort;   arr*tp
-- tpBasic** +  arr -> pointer;   ushort;   arr*tp
-----------------------------------------------------

-- **********************************************
-- *** SetExp operation
-- **********************************************
-----------------------------------------------------
--R  Var*,arr   = Var*,arr  -> [memcpy]
--R+ data      = data
--R Var*,~arr  = Var*      -> [set_v]
--R+ pointer   = pointer
--R Var*,~arr  = Reg|&Var|&Var*|Var*,arr -> [set_c]
--R+ pointer   = data | pointer
-- Var        = Const     -> [set_c] | [CONC(e2),pop]
--+ var       = var
-- Var        = Var       -> [set_v]
--+ var       = var
-- Var        = AwaitInt  -> [Conc(e2),set_v]
--+ var       = var
--R Var*,~arr  = Exp       -> [Conc(e2),pop]
--R+ pointer   = pointer
-- Var        = Exp       -> [Conc(e2),pop]
--+ var       = var
-- Var[Var]   = Var       -> [setarr_vv]
--+ var       = var
-- Var[Var]   = AwaitInt  -> [Conc(e2),setarr_vv]
--+ var       = var
--R Var*[Var]  = Var*      -> [setarr_vv]
--R+ pointer   = pointer
-- Var[Var]   = Const     -> [setarr_vc]
--+ var       = var
-- Var[Var]   = Exp       -> [poparr_v]
--+ var       = var
-- Reg        = Reg       -> [memcpy]
--+ data      = data
--R Reg        = Var*,arr  -> [memcpy]
--R+ data      = data
--R Var*,arr   = Reg       -> [memcpy]
--R+ data      = data

--
--
-----------------------------------------------------
-- pending...
--R Exp:*varp  = Const       -> [push_c,push_v,set_e]
--R+ var       = var
--R Exp:*varp  = Var         -> [push_v,push_v,set_e]
--R+ var       = var
--R Var* ~arr  = Var* & Arr
--R+ pointer   = data



    if     x1.auxtag2 == 'Var' and x2.auxtag2 == 'Const'  then
      local toTp = _TP.getCastType(x1.tp)  
      local fromTp = _TP.getCastType(x2.tp)          
      if (toTp~=fromTp and (toTp=='float' or fromTp=='float')) then
        CONC(me,e2)
        codeB = LINE(me,'cast '..fromTp..' '..toTp,nil,'// cast <type> ')
        BYTECODE(me,codeB,'op_cast',fromTp,toTp)      
        codeB = LINE(me,'pop '..x1.id,nil,'// SetExp:: pop to var')
        BYTECODE(me,codeB,'op_pop',x1.tp,x1.val)  
      else  codeB = LINE(me,x1.id ..' = '.. x2.id,nil,'// SetExp:: set var=const' )        
        codeB = LINE(me,x1.id ..' = '.. x2.id,nil,'// SetExp:: set var=const' )        
        BYTECODE(me,codeB,'op_set_c',x1.tp,x1.val,x2.auxval or x2.val)
      end
  
    elseif x1.auxtag2 == 'Var' and x2.auxtag2 == 'Var'  and (x1.tp~= 'float' and x2.tp~='float') then
        codeB = LINE(me,x1.id ..' = '.. x2.id..'',nil,'// SetExp:: set var = var')        
        BYTECODE(me,codeB,'op_set_v',x1.ntp,x2.ntp,x1.val,x2.val)
      
    elseif x1.auxtag2 == 'Var' and x2.auxtag2 == 'AwaitInt'  then
        CONC(me,e2)
        codeB = LINE(me,x1.id ..' = '.. x2.id..'',nil,'// SetExp:: set var = var')        
        BYTECODE(me,codeB,'op_set_v',x1.ntp,x2.ntp,x1.val,x2.val)

    elseif x1.auxtag2 == 'Var' and x2.auxtag2 == 'Exp'  then
      CONC(me,e2)
      local toTp = _TP.getCastType(x1.tp)  
      local fromTp = _TP.getCastType(x2.tp)          
      if (toTp~=fromTp and (toTp=='float' or fromTp=='float')) then
        codeB = LINE(me,'cast '..fromTp..' '..toTp,nil,'// cast <type> ')
        BYTECODE(me,codeB,'op_cast',fromTp,toTp)
      end      
        codeB = LINE(me,'pop '..x1.id,nil,'// SetExp:: pop to var')
        BYTECODE(me,codeB,'op_pop',x1.tp,x1.val)  
      
    elseif x1.auxtag2 == 'Var[Var]' and x2.auxtag2 == 'Var' and (x1.tp~= 'float' and x2.tp~='float') then
        codeB = LINE(me,''..x1.id..' = '..x2.id,nil,'// set array[var] with var')        
        BYTECODE(me,codeB,'op_setarr_vv',x1.ntp,x1.val,x1.idxtp,x1.idxval,x1.idxmax,x2.tp,x2.val)

    elseif x1.auxtag2 == 'Var[Var]' and x2.auxtag2 == 'AwaitInt' then
        CONC(me,e2)
        codeB = LINE(me,''..x1.id..' = '..x2.id,nil,'// set array[var] with var')        
        BYTECODE(me,codeB,'op_setarr_vv',x1.ntp,x1.val,x1.idxtp,x1.idxval,x1.idxmax,x2.tp,x2.val)

    elseif x1.auxtag2 == 'Var[Var]' and x2.auxtag2 == 'Const' and (x1.tp~= 'float' and x2.tp~='float') then
        codeB = LINE(me,''..x1.id..' = '..x2.id,nil,'// set array[var] with Const')        
        BYTECODE(me,codeB,'op_setarr_vc',x1.ntp,x1.val,x1.idxtp,x1.idxval,x1.idxmax,x2.val)
    elseif x1.auxtag2 == 'Var[Var]' and x2.auxtag2 == 'Exp' and (x1.tp~= 'float' and x2.tp~='float') then
        CONC(me,e2)
        codeB = LINE(me,'pop to '..x1.id,nil,'// pop to array[var] ')        
        BYTECODE(me,codeB,'op_poparr_v',x1.ntp,x1.idxtp,x1.idxval,x1.idxmax,x1.val)

    elseif x1.auxtag2 == 'Reg' and x2.auxtag2 == 'Reg' and (x1.tp~= 'float' and x2.tp~='float') then
        codeB = LINE(me,'memcpy '..math.min(_ENV.c[x1.tp].len,_ENV.c[x2.tp].len)..'B. '..x2.id..' -> '..x1.id,nil,'// memcpy v2 v1')        
        BYTECODE(me,codeB,'op_memcpy',math.min(_ENV.c[x1.tp].len,_ENV.c[x2.tp].len),x2.val,x1.val)
        
    else
      -- ??) All other cases
      CONC(me,e2)
      local toTp = _TP.getCastType(x1.tp)  
      local fromTp = _TP.getCastType(x2.tp)          
      if (toTp~=fromTp and (toTp=='float' or fromTp=='float')) then
--print("code::SetExp: additional cast from "..fromTp..' to '..toTp)
        codeB = LINE(me,'cast '..fromTp..' '..toTp,nil,'// cast <type> ')
        BYTECODE(me,codeB,'op_cast',fromTp,toTp)      
      end


      if x1.auxtag2 == 'Var' then
        codeB = LINE(me,'push_c &'..x1.id..':'..x1.tp,nil,'// push Var ')
        BYTECODE(me,codeB,'op_push_c',x1.val)
      else
        CONC(me,e1)
      end

      codeB = LINE(me,'set ('.. e1.tp ..')*(pop1) = pop2',nil,'// SetExp:: pop stk1 to stk2')         
      BYTECODE(me,codeB,'op_set_e',x1.ntp)  
  end

end


F = {
    Node_pre = function (me)
        me.code = ''
        me.code2 = {}
        me.opcode={}
        me.n_stack={}
    end,

  Root = function (me)
    --        LINE(me, '//> memset(CEU->mem, 0, '.._MEM.gtes.loc0..');')
    --		LINE(me, 'main:',0,'// program main entry ')
    codeB = LINE(me, 'init_1:',0,'// program main entry ')
    local bytecode = string.format('L%04x',1)
    OPCODE(me,bytecode,codeB)
-- Nao precisa limpar na inicializacao
--    codeB = LINE(me, 'clear all gates',nil,'// Clear the gates ') 
--    BYTECODE(me,codeB,'op_memclr', _MEM.gtes.loc0, 0)
    for _,ext in ipairs(_ENV.exts) do
      if ((ext.pre == 'input') and ((_ENV.awaits[ext] or 0) >0)) then  -- save code to write 0
        --                LINE(me, '//> *PTR(ubyte*,IN_'..ext.id..') = '
        --                            ..(_ENV.awaits[ext] or 0)..';')

        -- event Id + nGates
        local Id_nGts = (ext.idx*256) + ((_ENV.awaits[ext] or 0) * 1) + ((ext.inArg and 128) or 0) -- if auxId set bit 7 in nGts
        local nGtsText = string.format("0x%04x = %d",Id_nGts,Id_nGts)
        codeB = LINE(me, 'config gate '..ext.id..' with '..(_ENV.awaits[ext] or 0)..' await(s) - '..nGtsText,nil,'// Config gate')
        BYTECODE(me,codeB,'op_set_c','ushort',_MEM.gtes[ext.n],Id_nGts)
      end
    end

    CONC_ALL(me)

--    if _OPTS.analysis_run then
--      SWITCH(me, me.lbl_ana)
--      CASE(me, me.lbl_ana)
--    end

    if not (_OPTS.analysis_use and _ANALYSIS.isForever) then
      local ret = _AST.root[1].vars[1]    -- $ret
      --afb            LINE(me, 'if (ret) *ret = '..ret.val..';')
      codeB = LINE(me, 'end program',nil,'// end; ')
      BYTECODE(me,codeB,'op_end')
    end
    HALT(me)
  end,

  Host = function (me)
    _CODE.host = _CODE.host .. me[1] .. '\n'
  end,

  SetExp = function (me)
    SetExp(me)
  end,

  SetAwait = function (me)
    local e1, e2 = unpack(me)
--print("code::SetWait:",e1.tp,e1[1].tag,e1[1].val,e2.tag)
--print(print_r(me,"code::SetWait: me"))
    --ATTR(me, e1, e2.ret)

    if (e2.tag =="AwaitInt") then
      SetExp(me)
    else -- e2.tag == AwaitExt
      CONC(me, e2)
      if e1[1].tag=='Var' then
        local x1 = getAuxValues(e1)
--print("code::SetAwait: var:",x1.auxtag1,x1.auxtag2, x1.tp, x1.ntp, x1.val,x1.id)
        codeB = LINE(me,'getExtData '..x1.id..' '.._ENV.c[e1.tp].len,nil,'// getExtDt <localVarAddr> <len>')
        BYTECODE(me,codeB,'op_getextdt_v',x1.val,_ENV.c[e1.tp].len)
      else
        CONC(me,e1)
        codeB = LINE(me,'getExtData stack len='.._ENV.c[e1.tp].len,nil,'// getExtDt <Stack:localVar Addr> <len>')
        BYTECODE(me,codeB,'op_getextdt_e',_ENV.c[e1.tp].len)
      end
    end	        

--    EXP(me, e1)     -- after awaking
  end,

    SetBlock = function (me)
        local _,blk = unpack(me)
        CONC(me, blk)
--        if _OPTS.analysis_run then
--            SWITCH(me, me.lbl_ana_no)
--            CASE(me, me.lbl_ana_no)
--        end
        HALT(me)        -- must escape with `return´
        BLOCK_GATES(me)
    end,
    Return = function (me)
        local top = _AST.iter'SetBlock'()
--        LINE(me, '//> ceu_track_ins(CEU->stack,' ..top.lbl_out.tree..', 1,'
--                    ..top.lbl_out.id..');')
        codeB = LINE(me, 'insert track '.. top.lbl_out.id .. ' tree '.. top.lbl_out.tree,nil,'// Return to '..top.lbl_out.id)
		    BYTECODE(me,codeB,'op_tkins_z',1,top.lbl_out.tree,top.lbl_out.n)
        HALT(me)
    end,

    Block = function (me)
        for _, var in ipairs(me.vars) do
--print("code::Block:",me[1].tag,var.id,var.ln)
            if var.isEvt then
--                LINE(me, '//> *PTR(ubyte*,'..var.awt0..') = '..var.n_awaits..';')  -- #gtes
              codeB = LINE(me, 'event '..var.id..' = '..var.n_awaits..' gates',nil,'// set event ')
      				BYTECODE(me,codeB,'op_set_c','ubyte',var.awt0,var.n_awaits)
--                LINE(me, '//> memset(CEU->mem+'..var.awt0..'+1, 0, '   -- gtes[i]=0
--                        ..(var.n_awaits*_ENV.c.tceu_nlbl.len)..');')
              WRN(var.n_awaits > 0, var.ln,'event "'..var.id ..'" without any await.')
              if var.n_awaits > 0 then
          				codeB = LINE(me, 'clear '.. var.id ..' '..var.n_awaits..' wait(s) ',nil,'// clear event waits') 
          				BYTECODE(me,codeB,'op_memclr', var.n_awaits*_ENV.c.tceu_nlbl.len, var.awt0+1)
              else
          		end
            end
        end
        CONC_ALL(me)
    end,

    BlockN  = CONC_ALL,
    Finally = CONC,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        for i, sub in ipairs(me) do
--            LINE(me, '//> ceu_track_ins(CEU->stack, CEU_TREE_MAX, 0, '
--                        ..me.lbls_in[i].id ..');')
	        codeB = LINE(me, 'insert track '.. me.lbls_in[i].id ,nil,'// insert track (Par)')
			BYTECODE(me,codeB,'op_tkins_max',0,me.lbls_in[i].n)
        end
        HALT(me)
    end,


    ParEver = function (me)
        -- behave as ParAnd, but halt on termination (TODO: +ROM)
--        if _OPTS.analysis_run then
--            F.ParAnd(me)
--            SWITCH(me, me.lbl_ana_no)
--            CASE(me, me.lbl_ana_no)
--            HALT(me)
--            return
--        end

        F._Par(me)
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
            HALT(me)
        end
    end,

    ParOr = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
--            COMM(me, 'PAROR JOIN')
--            LINE(me, '//> ceu_track_ins(CEU->stack,' .. 255 ..', 1,'
--                        ..me.lbl_out.id..');')
	        codeB = LINE(me, 'insert track '.. me.lbl_out.id,nil,'// Insert track (ParOr)')
			BYTECODE(me,codeB,'op_tkins_max',0,me.lbl_out.n)
            HALT(me)
        end
        BLOCK_GATES(me)
    end,

    ParAnd = function (me)
        -- close AND gates
--        LINE(me, '//> memset(PTR(char*,'..me.off..'), 0, '..#me..');')
		codeB = LINE(me, 'clear gates from addr '.. me.off ..' to addr '..me.off+#me-1,nil,'// close gates (ParAnd)') 
		BYTECODE(me,codeB,'op_memclr', #me, me.off)

        F._Par(me)

        for i, sub in ipairs(me) do
            CASE(me, me.lbls_in[i])
            CONC(me, sub)
--            LINE(me, '//> *PTR(ubyte*,'..(me.off+i-1)..') = 1; // open and')  -- open gate
            codeB = LINE(me, 'open gate '..i,nil,'// open gate (ParAnd)') 
			BYTECODE(me,codeB,'op_set_c','ubyte',(me.off+i-1),1)

            SWITCH(me, me.lbl_tst)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
--afb             LINE(me, 'if (! *PTR(ubyte*,'..(me.off+i-1)..'))')
			codeB = LINE(me,me.lbl_ana_out.id .. ' -- if (gate '..(i-1)..' == 0) PC=PC+1',nil,'')
			BYTECODE(me,codeB,'op_chkret', (me.off+i-1))
            HALT(me)
        end

--        if _OPTS.analysis_run then
--            SWITCH(me, me.lbl_ana_out)
--            CASE(me, me.lbl_ana_out)
--        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)
--        if _OPTS.analysis_run then
--afb            EXP(me, c)
--afb            local id = (me.lbl_f and me.lbl_f.id) or me.lbl_e.id
--afb            LINE(me, [[
--afb CEU_ANA_PRE(1);
--afb ceu_track_ins(CEU->stack, CEU_TREE_MAX, 0, ]]..id..[[);
--afb CEU_ANA_POS();
--afb ]])
--afb            SWITCH(me, me.lbl_t);
--        else
--afb            LINE(me, [[if (]]..c.val..[[) {]])
--afb            SWITCH(me, me.lbl_t)
--afb
--afb            LINE(me, [[} else {]])
--afb            if me.lbl_f then
--afb                SWITCH(me, me.lbl_f)
--afb            else
--afb                SWITCH(me, me.lbl_e)
--afb            end
--afb            LINE(me, [[}]])

--			LINE(me,'exp_ubyte '..c.val)
			CONC(me,c)
			if me.lbl_f then
				codeB = LINE(me, 'ifelse '..me.lbl_t.id..' '..me.lbl_f.id,nil,'// ifelse ')
				BYTECODE(me,codeB,'op_ifelse',me.lbl_t.n,me.lbl_f.n)
			else
				codeB = LINE(me, 'ifelse '..me.lbl_t.id..' '..me.lbl_e.id,nil,'// ifelse')			
				BYTECODE(me,codeB,'op_ifelse',me.lbl_t.n,me.lbl_e.n)
			end
--        end

        CASE(me, me.lbl_t)
        CONC(me, t, 4)
        SWITCH(me, me.lbl_e)

        if me.lbl_f then
            CASE(me, me.lbl_f)
            CONC(me, f, 4)
            SWITCH(me, me.lbl_e)
        end
        CASE(me, me.lbl_e)
    end,

    Async_pos = function (me)
        local vars,blk = unpack(me)
        for _, n in ipairs(vars) do
            --ATTR(me, n.new, n[1].var)
--            EXP(me, n)
--print(print_r(n.new,"code:Async_pos: n.new"))
--print("code::Async_pos:",n.new[1].id,n.new[1].tp,n.new[1].val,n[1].var.tp,n[1].var.id,n[1].var.val)
            codeB = LINE(me,n.new[1].id .."'=".. n[1].var.id,nil,'// SetExp:: set var=var')        
            BYTECODE(me,codeB,'op_set_v',n.new[1].tp,n[1].var.tp,n.new[1].val,n[1].var.val)
        end
--        LINE(me, 'ceu_async_enable('..me.gte..', '..me.lbl.id..');')
        codeB = LINE(me, 'ceu_async_enable '..me.gte..' '..me.lbl.id,nil,'// async enable')      
        BYTECODE(me,codeB,'op_asen',me.gte,me.lbl.n)

        HALT(me)
        CASE(me, me.lbl)
--        if _OPTS.analysis_run then
--            -- skip `blk´ on analysis
--            local set = _AST.iter()()       -- requires `Async_pos´
--            if set.tag == 'SetBlock' then
--                SWITCH(me, set.lbl_out)
--            end
--        else
            CONC(me, blk)
--        end
    end,

    Loop = function (me)
        local body = unpack(me)

--        COMM(me, 'Loop ($0):')
        CASE(me, me.lbl_ini)
        CONC(me, body)

--        if _OPTS.analysis_run then         -- verifies the loop "loops"
--            SWITCH(me, me.lbl_ana_mid)
--            CASE(me, me.lbl_ana_mid)
--        end

        local async = _AST.iter'Async'()
        if async then
          codeB = LINE(me, 'ceu_async_enable '..async.gte..' '..me.lbl_ini.id,nil,'// async enable')      
          BYTECODE(me,codeB,'op_asen',async.gte,me.lbl_ini.n)
          HALT(me)
--            LINE(me, [[
--#ifdef ceu_out_pending
--if (ceu_out_pending()) {
--#else
--{
--#endif
--    ceu_async_enable(]]..async.gte..', '..me.lbl_ini.id..[[);
--    break;
--}
--]])
        end

        -- a single iter is enough on analysis a tight loop
--        if (not _OPTS.analysis_run) or me.blocks then
            SWITCH(me, me.lbl_ini)
--        end

        BLOCK_GATES(me)
    end,

    Break = function (me)
        local top = _AST.iter'Loop'()
        if _AST.iter'Finally'() then
            SWITCH(me, top.lbl_out)     -- can't use prios inside a `finally´
        else
--            LINE(me, 'ceu_track_ins(CEU->stack,' ..top.lbl_out.tree..', 1,'
--                        ..top.lbl_out.id..');')
--print("code::Break:",top.lbl_out.tree,top.lbl_out.n)
          codeB = LINE(me, 'insert track '.. top.lbl_out.id .. ' tree '.. top.lbl_out.tree,nil,'// Break:: ')
          BYTECODE(me,codeB,'op_tkins_z',1,top.lbl_out.tree,top.lbl_out.n)
        end
        HALT(me)
    end,

    Pause = function (me)
        local exp, blk = unpack(me)
        CONC(me,blk)
    end,

-- afb: Not implemented in Terra
--    CallStmt = function (me)
--        local call = unpack(me)
--        EXP(me, call)
--        if not _OPTS.analysis_run then
--            LINE(me, call.val..';')
--        end
--    end,

    EmitExtS = function (me)
        local e1, e2 = unpack(me)
        local ext = e1.ext
    if ext.pre == 'output' then  -- e1 not Exp
        if (e2) then
          -- get event type data len
          local par_len,par_tp
          par_tp = (_TP.deref(e2[1].tp) and 'ushort') or e2[1].tp -- force 2 bytes pointer.
          par_len = (_ENV.c[par_tp] and _ENV.c[par_tp].len) or 0

          local x1 = getAuxValues(e2);

          if(e2[1].tag=='CONST') then
            codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' const='..e2[1].val,nil,'// EmitExtS:: const ')
            local auxval = (e2[1].tp=='float' and _TP.float2hex(tonumber(e2[1].val))) or e2[1].val
            BYTECODE(me,codeB,'op_outevt_c',e1.ext.idx,auxval)
          elseif (x1.auxtag2=='Var' and _TP.deref(e1.ext.tp)) then
            codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' var='..x1.id,nil,'// EmitExtS:: var')
            BYTECODE(me,codeB,'op_outevt_v',e1.ext.idx,x1.val, par_tp)
          elseif (_ENV.packets[e1.ext.tp]) then
            codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' var='..x1.id,nil,'// EmitExtS:: var')
            BYTECODE(me,codeB,'op_outevt_v',e1.ext.idx,e2.val, 'ushort')

--          elseif (e2[1].tag=='Var' and not _TP.deref(e2[1].tp)) then -- not pointer 
--            codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' var='..e2[1][1],nil,'// EmitExtS:: var')
--            BYTECODE(me,codeB,'op_outevt_v',e1.ext.seq,e2[1].val, par_tp)
--          elseif (e2[1].tag=='Var' and _TP.deref(e2[1].tp)) then -- pointer 
--            CONC(me,me[2])
--            codeB = LINE(me,'emit '..e1.ext.id,nil,'// EmitExtS::')
--            BYTECODE(me,codeB,'op_outevt_e',e1.ext.idx)
--          elseif (e2[1].tag=='Op1_&' and e2[1][2].tag=='Var') then -- &Var 
--            codeB = LINE(me,'emit '..e1.ext.id..' len='..par_len..' var='..e2[1][2][1],nil,'// EmitExtS:: var')
--            BYTECODE(me,codeB,'op_outevt_v',e1.ext.seq,e2[1][2].val, par_tp)
          else -- as expression
            CONC(me,me[2])
            codeB = LINE(me,'emit '..e1.ext.id,nil,'// EmitExtS::')
            BYTECODE(me,codeB,'op_outevt_e',e1.ext.idx)
          end
        else
          codeB = LINE(me,'emit '..e1.ext.id ,nil,'// EmitExtS:: void ')
          BYTECODE(me,codeB,'op_outevt_z',e1.ext.idx)
        end

     else
      ASR(false,me,'Emit INPUT_EVENT inside Async is not implemented.')
--        assert(ext.pre == 'input')
--        local async = _AST.iter'Async'()
--        LINE(me, 'ceu_async_enable('..async.gte..', '..me.lbl_cnt.id..');')
--        if e2 and (not _OPTS.analysis_run) then
--            if _TP.deref(ext.tp) then
--                LINE(me, 'return ceu_go_event(ret, IN_'..ext.id
--                        ..', (void*)'..e2.val..');')
--            else
--                LINE(me, 'return ceu_go_event(ret, IN_'..ext.id
--                        ..', (void*)ceu_ext_f('..e2.val..'));')
--            end
--
--        else
--            LINE(me, 'return ceu_go_event(ret, IN_'..ext.id ..', NULL);')
--        end
--        CASE(me, me.lbl_cnt)
    end
    return 

    end,

    EmitT = function (me)
    	ASR(false,me,'"EmitT" is not implemented.')

--        local exp = unpack(me)
--        local async = _AST.iter'Async'()
--        EXP(me, exp)
--        LINE(me, [[
--ceu_async_enable(]]..async.gte..', '..me.lbl_cnt.id..[[);
--#ifdef CEU_WCLOCKS
--{ long nxt;
--  int s = ceu_go_wclock(ret,]]..exp.val..[[, &nxt);
--  while (!s && nxt<=0)
--      s = ceu_go_wclock(ret, 0, &nxt);
--  return s;
--}
--#else
--return 0;
--#endif
--]])
 --       CASE(me, me.lbl_cnt)
    end,

  EmitInt = function (me)
    local int, exp = unpack(me)
    --        COMM(me, 'emit '..int.var.id)

--    CONC(me,exp)
--    codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')          
--    BYTECODE(me,codeB,'op_pop',int.tp,int.val)  

    -- attribution
    if exp then
--print("code::EmitInt:",int.fst.id,exp[1].tag,typelen[int.tp], typelen[exp.tp])      
      --afb  		ATTR(me, int, exp)
      if (exp[1].tag == "CONST") then
        if (typelen[int.tp] >= typelen[exp.tp]) then
          codeB = LINE(me,'emit '..int.var.id..'('..exp.val..')',nil,'// EmitInt:: Const')
          local auxval = (exp.tp=='float' and _TP.float2hex(tonumber(exp.val))) or exp.val
          BYTECODE(me,codeB,'op_set_c',int.tp,int.val,auxval)
        else
          CONC(me,exp)
          codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')					
          BYTECODE(me,codeB,'op_pop',int.tp,int.val)	
        end
      elseif (exp[1].tag == "Var") then
        if (typelen[int.tp] == typelen[exp.tp]) then
          codeB = LINE(me,'emit '..int.var.id..'('..exp[1][1]..')',nil,'// EmitInt:: Var')
          BYTECODE(me,codeB,'op_set_v',int.tp,exp.tp,int.val,exp.val)
        else
          CONC(me,exp)
          codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')          
          BYTECODE(me,codeB,'op_pop',int.tp,int.val)  
        end
      else -- is Expression
          CONC(me,exp)
          codeB = LINE(me,'emit '..int.fst.id..' from stack',nil,'// EmitInt:: pop to ')          
          BYTECODE(me,codeB,'op_pop',int.tp,int.val)  
      end
    end
--
--    -- emit vs await
--    if _OPTS.analysis_run then -- int not Exp
--      if exp then
--        EXP(me, exp)
--      end
--      SWITCH(me, me.lbl_ana_emt)
--      CASE(me, me.lbl_ana_emt)
--    end

    -- defer match: reaction must have a higher stack depth
    --        LINE(me, '//> ceu_track_ins(CEU->stack+2, CEU_TREE_MAX, 0,'
    --                    ..me.lbl_mch.id..');')
    codeB = LINE(me, 'insert track '.. me.lbl_mch.id,nil,'// EmitInt:: defer match')
    BYTECODE(me,codeB,'op_tkins_max',2,me.lbl_mch.n)
    -- defer continuation: all trails must react before I resume
    --        LINE(me, '//> ceu_track_ins(CEU->stack+1, CEU_TREE_MAX, 0,'
    --                    ..me.lbl_cnt.id..');')
    codeB = LINE(me, 'insert track '.. me.lbl_cnt.id,nil,'// EmitInt:: defer continuation')
    BYTECODE(me,codeB,'op_tkins_max',1,me.lbl_cnt.n)
    HALT(me)

    -- emit
    CASE(me, me.lbl_mch)
    --        LINE(me, '//> ceu_trigger('..int.var.awt0..');')
    codeB = LINE(me, 'trigger '..int.var.id,nil,'// EmitInt:: trigger')
    BYTECODE(me,codeB,'op_trg',int.var.awt0)

    HALT(me)

    -- continuation
    CASE(me, me.lbl_cnt)
    SWITCH(me, me.lbl_ana_cnt)
    CASE(me, me.lbl_ana_cnt)
  end,

  AwaitInt = function (me)
    local int, zero = unpack(me)
    if not zero then
      codeB = LINE(me, 'insert track '.. me.lbl_awt.id,nil,'// AwaitInt:: defer await')
      BYTECODE(me,codeB,'op_tkins_max',0,me.lbl_awt.n)
      HALT(me)
    end

    -- await
    CASE(me, me.lbl_awt)
    --        LINE(me, '//> *PTR(tceu_nlbl*,'
    --                    ..(int.var.awt0+1+me.gte*_ENV.c.tceu_nlbl.len)
    --                    ..') = '..me.lbl_awk.id..';')
    codeB = LINE(me, 'await '..me.lbl_awk.id,nil,'// AwaitInt:: wait')
    BYTECODE(me,codeB,'op_set_c','ushort',(int.var.awt0+1+me.gte*_ENV.c.tceu_nlbl.len),me.lbl_awk.n,true)

    HALT(me)

    -- awake
    CASE(me, me.lbl_awk)

-- mover para ???
--      codeB = LINE(me,'push$ '..me.id..':'..me.tp,nil,'// push Var ')
--      BYTECODE(me,codeB,'op_push_v',me.tp,me.val)

  end,

    AwaitN = function (me)
--        COMM(me, 'Never')
        HALT(me)
    end,
    AwaitT = function (me)
        local exp = unpack(me)
        CONC(me, exp)
        local val = exp.val
--        if _OPTS.analysis_run and
--            (exp.tag=='WCLOCKE' or exp.tag=='WCLOCKR') then
--            val = 'CEU_WCLOCK_ANY'
--        end
--        LINE(me, '//> ceu_wclock_enable('..me.gte..', '..val
--                    ..', '..me.lbl.id..');')
--        LINE(me, 'clken '.._TP.getConstType(me.gte,me)..' '..me.gte..' '.._TP.getConstType(val,me)..' '..val..' '.._TP.getConstType(me.lbl.n,me)..' '..me.lbl.n,nil,'// AwaitT '..me.lbl.id)


--print("code::AwaitT:",exp.tag)
		if (exp.tag=='WCLOCKK') then
     	codeB = LINE(me, 'clock enable '..me.lbl.id..' '..exp.ms..'msec',nil,'// AwaitT ')
			BYTECODE(me,codeB,'op_clken_c',me.gte,exp.ms,me.lbl.n)
		else
--print("code::AwaitT:",exp.tag,unpack(exp[1][1]))
			if (exp[1][1].tag=='Var') then
       	codeB = LINE(me, 'clock enable '..me.lbl.id..' ('.. exp[1][1][1]..':'..exp[1].tp ..')' .. exp[2],nil,'// AwaitT ')
				BYTECODE(me,codeB,'op_clken_v',me.gte,_MEM.t2idx[exp[2]],exp[1].tp,exp[1].val,me.lbl.n)
			else
--				ASR(false,me,'cannot use expressions in "await". ')
        CONC(me,exp[1])
        codeB = LINE(me, 'clock enable '..me.lbl.id..' '.. '(stack)' .. exp[2],nil,'// AwaitT ')
        BYTECODE(me,codeB,'op_clken_e',me.gte,_MEM.t2idx[exp[2]],me.lbl.n)
			end
		end
        HALT(me)
        CASE(me, me.lbl)
    end,
    
    AwaitExt = function (me)
        local e1,e2 = unpack(me)
--print("code::AwaitExt: ",e1.ext.idx,e1.ext.n,me.gte,me.lbl.n,_MEM.gtes[e1.ext.n])
--        LINE(me, '//> *PTR_EXT(IN_'..e1.ext.id..','..me.gte..') = '..me.lbl.id..';')

        if not e1.ext.inArg then -- evtId, nGtes, [addr]*
          codeB = LINE(me, 'await '..e1.ext.id..'['..me.gte..']',nil,'// AwaitExt:: ')
          BYTECODE(me,codeB,'op_set_c','ushort',(_MEM.gtes[e1.ext.n]+2+(me.gte*2)),me.lbl.n,true)
        else -- evtId, nGtes, [idAux,addr]*
          CONC(me,e2)
          codeB = LINE(me, 'evt '..e1.ext.id..' auxId = pop',nil,'// AwaitExt:: ')
          BYTECODE(me,codeB,'op_pop','ubyte', (_MEM.gtes[e1.ext.n]+2+(me.gte*3))) 
          codeB = LINE(me, 'await '..e1.ext.id..'['..me.gte..']',nil,'// AwaitExt:: ')
          BYTECODE(me,codeB,'op_set_c','ushort',(_MEM.gtes[e1.ext.n]+2+1+(me.gte*3)),me.lbl.n,true)
        end

        HALT(me) 
        CASE(me, me.lbl)
    end,
--[[
    Op2_call = function (me)
        local _, f, exps = unpack(me)
--print(print_r(me,"code::Op2_call: me"))
        ASR(false,me,'"call" is not implemented! ')
    end,
--]]    
    ['Op2_-'] = function (me) Op2_any(me,'sub') end,  
    ['Op2_+'] = function (me) Op2_any(me,'add') end,  
    ['Op2_%']   = function (me) Op2_any(me,'mod') end,
    ['Op2_*']   = function (me) Op2_any(me,'mult') end,
    ['Op2_/']   = function (me) Op2_any(me,'div') end,
    ['Op2_|']   = function (me) Op2_any(me,'bor') end,
    ['Op2_&']   = function (me) Op2_any(me,'band') end,
    ['Op2_<<']  = function (me) Op2_any(me,'lshft') end,
    ['Op2_>>']  = function (me) Op2_any(me,'rshft') end,
    ['Op2_^']   = function (me) Op2_any(me,'bxor') end,
    ['Op2_==']  = function (me) Op2_any(me,'eq') end,
    ['Op2_!=']  = function (me) Op2_any(me,'neq') end,
    ['Op2_>=']  = function (me) Op2_any(me,'gte') end,
    ['Op2_<=']  = function (me) Op2_any(me,'lte') end,
    ['Op2_>']   = function (me) Op2_any(me,'gt') end,
    ['Op2_<']   = function (me) Op2_any(me,'lt') end,
    ['Op2_or']  = function (me) Op2_any(me,'lor') end,
    ['Op2_and'] = function (me) Op2_any(me,'land') end,
    
    ['Op1_~']   = function (me) Op1_any(me,'bnot') end,
    ['Op1_-']   = function (me) Op1_any(me,'neg') end, 
    ['Op1_not']  = function (me) Op1_any(me,'lnot') end,

--    ['Op1_*'] = function (me)
--        local op, e1, e2 = unpack(me)
--        local tp = (_TP.deref(_TP.deref(e1.tp)) and 'ushort') or (_TP.deref(e1.tp) or e1.tp)
----print("code::Op1_*:",e1.tag,e1.val,e1.tp,tp,e1[1])
--		ASR(not _TP.deref(_TP.deref(e1.tp)),me,'"**Var" is not implemented! ')
--    ASR(_TP.isBasicType(tp),me,'type of "'..e1[1]..'" is not a basic type.')
--    CONC(me,e1)
--    codeB = LINE(me,'deref_ *'..e1[1],nil,'// Op1_*(push pointer content):: ')
--    BYTECODE(me,codeB,'op_deref',tp)
--    end,
    
  ['Op2_.'] = function (me)
    local op, e1, id = unpack(me)
    local field = _ENV.c[_TP.deref(e1.tp) or e1.tp].fields[id]
--print('________________________________________________________')
--print('code:Op2_.::',me.val,me.tp, e1.tag,e1.val,e1.tp,id)
--print('code:Op2_.::',me.fst.val, id,field.offset,field.tp,field.arr)
--print(print_r(me,'code::Op2_.:me',nil,5))
--print('--------------------------------------------------------')

    if _TP.deref(e1.tp) then
      CONC(me,e1) -- Reg Addr
      if (field.offset > 0) then -- 'add' only if offset > 0
        codeB = LINE(me,'push '..id ..' offset',nil,'// (push field position offset):: ')
        BYTECODE(me,codeB,'op_push_c',field.offset)
        codeB = LINE(me,'add: reg addr + field offset')
        BYTECODE(me,codeB,'op2_any','add')
      end
    else -- push varAddr+FieldPos
--print('code:Op2_.::',e1[1],id,me.tag,me.fst[1],me.lval,me[2])
      codeB = LINE(me,'push &'..e1[1]..'.'..id,nil,'// push &Var ')
      BYTECODE(me,codeB,'op_push_c',e1.val+field.offset)
    end
  end,
    
  ['Op1_&'] = function (me)
    local op, e1 = unpack(me)
--print("code::Op1_&",e1.tag)
    if e1.tag == 'Var' then
      codeB = LINE(me,'push &'..e1[1],nil,'// push &Var ')
      BYTECODE(me,codeB,'op_push_c',e1.val)
    else
      CONC(me,e1)
    end
  end,

  Op_var = function (me)
    local op, exp = unpack(me)
    if exp.tag == 'Var' then
--print("code::Op_var: Var",op,exp.var.id,exp.var.val,exp.tp)
      codeB = LINE(me,'push &'..exp[1],nil,'// push &Var ')
      BYTECODE(me,codeB,'op_push_c',exp.val)
    else
--print("code::Op_var: Var",op,exp[2][1],exp[3],exp.tp)
      CONC(me,exp)
    end
    codeB = LINE(me,op..' '..exp.tp,nil,'// Op_var <type> ')
    BYTECODE(me,codeB,'op_'..op,exp.tp)
  end,

  Op1_cast = function (me)
    local tp, exp = unpack(me)
    CONC(me,exp)
    local fromTp = ((exp.tp=='ubyte' or exp.tp=='ushort' or exp.tp=='ulong') and 'ulong') or ((exp.tp=='byte' or exp.tp=='short' or exp.tp=='long') and 'long') or 'float'  
    local toTp = ((tp=='ubyte' or tp=='ushort' or tp=='ulong') and 'ulong') or ((tp=='byte' or tp=='short' or tp=='long') and 'long') or 'float'  
    codeB = LINE(me,'cast '..fromTp..' '..toTp,nil,'// cast <type> ')
--print("code::Op1_cast:",tp,exp.tp,fromTp,toTp)
    if (fromTp~=toTp and (fromTp=='float' or toTp=='float')) then
      BYTECODE(me,codeB,'op_cast',fromTp,toTp)
    else
      WRN(false,me, 'Discarding ineffective "cast" from '..fromTp..' to '..toTp..'.')    
    end
  end,
  ['SIZEOF'] = function (me)
    --      LINE(me,'push '..me.tp..' '.. me[1]..'   // CONST| '..me[1])
    --      codeB = LINE(me,'push_c '.._TP.getConstLen(me[1])..' '..me[1],nil,'// push '.. me.tp ..' '.. me[1]..' :: CONST| '..me[1])
    codeB = LINE(me,'push '..me.val,nil,'// push sizeof<> ')
    BYTECODE(me,codeB,'op_push_c',me.val)
  end, 
  ['CONST'] = function (me)
    --    	LINE(me,'push '..me.tp..' '.. me[1]..'   // CONST| '..me[1])
    --    	codeB = LINE(me,'push_c '.._TP.getConstLen(me[1])..' '..me[1],nil,'// push '.. me.tp ..' '.. me[1]..' :: CONST| '..me[1])
    codeB = LINE(me,'push '..me[1],nil,'// push Const ')
    local auxval = (me.tp=='float' and _TP.float2hex(tonumber(me[1]))) or me[1]
--print("code::CONST:",me.tp,me[1],auxval)
    BYTECODE(me,codeB,'op_push_c',auxval)
  end,  
  
  ['Var'] = function (me)
    --		ASR(typelen[me.var.tp] or _TP.deref(me.var.tp),me,'must use custom type only as pointer.')
    local tp = (_TP.deref(me.var.tp) and 'ushort') or me.var.tp
--print("Code::Var:",me.var.id,me.var.tp,tp,me.var.arr,_TP.isBasicType( _TP.deref(me.var.tp) or me.var.tp))
    if _TP.isBasicType( (_TP.deref(me.var.tp) and _TP.deref(_TP.deref(me.var.tp))) or _TP.deref(me.var.tp) or me.var.tp) then
      if me.var.arr then -- needs addr
        codeB = LINE(me,'push_c &'..me.var.id..':'..me.var.tp,nil,'// push &Var ')
        BYTECODE(me,codeB,'op_push_c',me.var.val)
      else -- needs value
        codeB = LINE(me,'push '..me.var.id..':'..me.var.tp,nil,'// push Var ')
        BYTECODE(me,codeB,'op_push_v',tp,me.var.val)
      end
    else -- is a register var/pointer
      if _TP.deref(me.var.tp) then -- is a register pointer
        codeB = LINE(me,'push '..me.var.id..':'..me.var.tp,nil,'// push Var ')
        BYTECODE(me,codeB,'op_push_v',tp,me.var.val)
      else -- is a register var = addr
        codeB = LINE(me,'push_c &'..me.var.id..':'..me.var.tp,nil,'// push &Var ')
        BYTECODE(me,codeB,'op_push_c',me.var.val)
      end
    end
  end,
  
  LExp = function (me)
--print("code::LExp:",me[1].tag,me[1].tp,(_TP.deref(me[1].tp) and 'ushort') or me[1].tp,me.tp,me[1][2].tag,me.val)
    local tp = (_TP.deref(me[1].tp) and 'ushort') or me[1].tp
    if (me[1].code=="") then me[1].code='TODO' end -- ???? very old!! why??
    if me[1].tag=='Var' then
        codeB = LINE(me,'push_c &'..me[1][1]..':'..tp,nil,'// push Var ')
        BYTECODE(me,codeB,'op_push_c',me.val)
--    elseif me[1].tag == 'Op1_*' then
--      CONC(me,me[1][2]); -- Ignore this "Op1_*"  
    else
      CONC(me,me[1]);
    end
  end,

  Exp = function (me)
--print("code::Exp:",me[1].tag,me[1].tp,(_TP.deref(me[1].tp) and 'ushort') or me[1].tp,me.tp,me[1].arr)
    local tp = (_TP.deref(me[1].tp) and 'ushort') or me[1].tp
--    ASR(not me[1].arr,me,'missing array index.')
    if (me[1].code=="") then me[1].code='TODO' end
    CONC(me,me[1]);
    if (not me[1].arr)  then tryDerefCode(me,me[1].tag,me[1].tp) end
  end,
  
  ExpList = function (me)
--print("code::ExpList:",me[1].tag)
--print(print_r(me,"code::ExpList: me"))
    for k,arg in ipairs(me) do
--print("code::ExpList: arg=",k, arg.tag,arg.tp)    
      CONC(me,arg);
      if ((arg.tag == "Op2_.") or (arg.tag == "Op2_idx")) and (vartype[arg.tp] ~= nil ) then
        codeB = LINE(me,'deref '.. arg.tp,nil,'// deref Var ')
        BYTECODE(me,codeB,'op_deref',arg.tp)
      end
    end
  end,

  -- Terra call --- function without attribution
  Call = function (me)
    CONC(me,me[2]);
    codeB = LINE(me,'popx ',nil,'')
    BYTECODE(me,codeB,'op_popx')
  end,

  Func = function (me)
--print("code::Func:",me.ext.id, me.ext.tp,me.ext.idx)
--print("code::Func: args:",#me[2],#me.ext.args)
    ASR(#me[2]==#me.ext.args,me,'invalid number of arguments for function ['.. me.ext.id ..'], received '.. #me[2] .. ' and it was expecting '..#me.ext.args  )
    for k,arg in ipairs(me.ext.args) do
      local error, cast, ntp1, ntp2, len1, len2 =  _TP.tpCompat(arg,(me[2][k].supertp or me[2][k].tp))
      ASR(not error ,me,'argument #'..k ..' in function ['.. me.ext.id ..'] must be compatible to "'.. arg.. '/'.. len1 ..'" type, it received "'.. (me[2][k].supertp or me[2][k].tp) ..'/'.. len2 .. '" type')
      WRN(not cast,me, 'Applying the minimum size: "'.. arg..'/'..len1 ..'" <--> "' .. me[2][k].tp ..'/'..len2 ..'". ')
    end
    CONC(me,me[2]);
    codeB = LINE(me,'func '..me.ext.id,nil,'')
    BYTECODE(me,codeB,'op_func',me.ext.idx)
  end,
  
  Op2_idx = function (me)
    local _, arr, idx = unpack(me)
    local idx_tp = (_TP.deref(idx.tp) and 'ushort') or idx.tp
--print(print_r(me,"code::Op2_idx: me"))
--print("code::Op2_idx:",arr.tag,arr.tp,arr.arr,idx.val, idx_tp)
--print("code::Op2_idx:",idx.tag,arr.tp,me.tp,arr.val,idx.val,me[2][1],me[2][2])
    ASR(_TP.isBasicType( _TP.deref(_TP.deref(arr.tp)) or _TP.deref(arr.tp)),me,'Arrays can have only basic types.')

    if (arr.tag == 'Var') and (idx.tag=='CONST') then  -- push direct the addr+idx
        ASR((idx.val*1 < arr.arr*1),me,'array index out of range, 0..'.. arr.arr-1 ..'.')
        codeB = LINE(me,'push_c &'..arr[1]..'['..idx.val..']',nil,'')
        BYTECODE(me,codeB,'op_push_c',arr.val+(idx.val*(_ENV.c[_TP.deref(_TP.deref(arr.tp)) or _TP.deref(arr.tp)].len)))  
    elseif (arr.tag == 'Var') and (idx.tag=='Var') then  -- push direct the addr and idx
        codeB = LINE(me,'pusharr_v &'..arr[1]..'['..idx[1]..']',nil,'')
        BYTECODE(me,codeB,'op_pusharr_v',_TP.deref(arr.tp),idx.tp,idx.val,arr.arr*1,arr.val)  
    elseif (arr.tag == 'Op2_.')  and not(_TP.deref(arr[2].tp)) and (idx.tag=='CONST') then  -- push direct the var.field addr + idx
        ASR((idx.val*1 < arr.arr*1),me,'array index out of range, 0..'.. arr.arr-1 ..'.')
--print("code::Op2_idx: ",arr[2][1]..'.'..arr[3]..'['..idx.val..']', arr[2].val, arr[2].fst.fields[arr[3]].val, me.tp, (idx.val*_ENV.c[me.tp].len))
      codeB = LINE(me,'push_c '..arr[2][1]..'.'..arr[3]..'['..idx.val..']',nil,'')
      BYTECODE(me,codeB,'op_push_c',arr[2].fst.fields[arr[3]].val + (idx.val*_ENV.c[me.tp].len))  
    else
      CONC(me,arr) -- var addr
      if (idx.tag=='CONST') then -- Constant can have a small code
        ASR((idx.val*1 < arr.arr*1),me,'array index out of range, 0..'.. arr.arr-1 ..'.')
        if (idx.val*1) > 0 then -- push only idx > 0
          codeB = LINE(me,'push_c '..'['..idx.val..'] offset',nil,'')
--          BYTECODE(me,codeB,'op_push_c',(idx.val*_ENV.c[idx_tp].len))  
          BYTECODE(me,codeB,'op_push_c',(idx.val*(_ENV.c[_TP.deref(_TP.deref(arr.tp)) or _TP.deref(arr.tp)].len)))  
          codeB = LINE(me,'add: array base addr + len position')
          BYTECODE(me,codeB,'op2_any','add')
        end
      else
        codeB = LINE(me,'push idx max '..arr.arr,nil,'// push array max idx')
        BYTECODE(me,codeB,'op_push_c',arr.arr)
        CONC(me,idx); -- idx
        codeB = LINE(me,'mod: limmit idx')
        BYTECODE(me,codeB,'op2_any','mod')
        codeB = LINE(me,'push var len '.._TP.deref(arr.tp),nil,'// push array var len')
        BYTECODE(me,codeB,'op_push_c',_ENV.c[_TP.deref(_TP.deref(arr.tp)) or _TP.deref(arr.tp)].len)
        codeB = LINE(me,'mult: varlen * idx')
        BYTECODE(me,codeB,'op2_any','mult')
        codeB = LINE(me,'add: array base addr + len position')
        BYTECODE(me,codeB,'op2_any','add')
      end
    end
  end   
}
_AST.visit(F)

end

--    _AST.dump(_AST.root)
end

local tps = { [1]='ubyte', [2]='ushort', [4]='ulong' }

local ALL = {
    n_tracks = _AST.root.n_tracks, --_ANALYSIS.n_tracks,
    n_mem = _MEM.max,
    tceu_noff = tps[_ENV.c.tceu_noff.len],
    tceu_nlbl = tps[MAX(_ENV.c.tceu_nlbl.len,_ENV.c.tceu_noff.len)],
}

assert(_MEM.max < 2^(_ENV.c.tceu_noff.len*8))

-- TEMPLATE
local tpl
do
--    tpl = assert(io.open'template.c'):read'*a'
--
--    local sub = function (str, from, to)
--        local i,e = string.find(str, from)
--        return string.sub(str, 1, i-1) .. to .. string.sub(str, e+1)
--    end
--
--    tpl = sub(tpl, '=== N_TRACKS ===',  ALL.n_tracks)
--    tpl = sub(tpl, '=== N_MEM ===',     ALL.n_mem)
--
--    --afb tpl = sub(tpl, '=== HOST ===',      (_OPTS.analysis_run and '') or _CODE.host)
--    tpl = sub(tpl, '=== CODE ===',      _AST.root.code)
--
--    -- lbl >= off (EMITS)
--    --afb tpl = sub(tpl, '=== TCEU_OFF ===',  ALL.tceu_noff)
--    --afb tpl = sub(tpl, '=== TCEU_LBL ===',  ALL.tceu_nlbl)
--
--    -- GTES
--    tpl = sub(tpl, '=== CEU_WCLOCK0 ===', _MEM.gtes.wclock0)
--    tpl = sub(tpl, '=== CEU_ASYNC0 ===',  _MEM.gtes.async0)

    -- LABELS
    --afb tpl = sub(tpl, '=== N_LABELS ===', #_LABELS.list)
    --afb tpl = sub(tpl, '=== LABELS ===',   _LABELS.code)

    -- DEFINITIONS: constants & defines
    do
        -- EVENTS
        local str = ''
        local t = {}
        local outs = 0
        local ins  = {}
        for _, ext in ipairs(_ENV.exts) do
            if ext.pre == 'input' then
                --str = str..'#define IN_'..ext.id..' '.._MEM.gtes[ext.n]..'\n'
                ins[#ins+1] = _MEM.gtes[ext.n]
--print("terrac:: evts:",ext.id,ext.idx,_ENV.awaits[ext] or 0)
                if ((_ENV.awaits[ext] or 0) > 0) then
                  _ENV.n_ins_active = _ENV.n_ins_active + 1;
                end
            else
                --str = str..'#define OUT_'..ext.id..' '..ext.seq..'\n'
                outs = outs + 1
            end
        end
        _ENV.n_ins = #ins
        _ENV.n_outs = outs
        --str = str..'#define OUT_n '..outs..'\n'
        if _OPTS.analysis_run then
            --str = str..'#define IN_n '..#ins..'\n'
            --str = str .. 'short IN_vec[] = { '..table.concat(ins,',')..' };\n'
        end

        -- FUNCTIONS called
        for id in pairs(_ENV.calls) do
            if id ~= '$anon' then
                --str = str..'#define FUNC'..id..'\n'
            end
        end

        -- DEFINES
        if _PROPS.has_exts then
            --str = str .. '#define CEU_EXTS\n'
            ALL.exts = true
        end
        if _PROPS.has_wclocks then
            --str = str .. '#define CEU_WCLOCKS '.._ENV.n_wclocks..'\n'
            ALL.wclocks = true
        end
        if _PROPS.has_asyncs then
            --str = str .. '#define CEU_ASYNCS '.._ENV.n_asyncs..'\n'
            ALL.asyncs = true
        end
        if _PROPS.has_emits then
            --str = str .. '#define CEU_STACK\n'
            ALL.emits = true
        end
--        if _ANALYSIS.needsTree then
--            str = str .. '#define CEU_TREE\n'
--            ALL.tree = true
--        end
--        if _ANALYSIS.needsChk then
--            str = str .. '#define CEU_TREE_CHECK\n'
--            ALL.chk = true
--        end

        if _OPTS.defs_file then
            --local f = io.open(_OPTS.defs_file,'w')
            --f:write(str)
            --f:close()
            --afb tpl = sub(tpl, '=== DEFS ===','#include "'.. _OPTS.defs_file ..'"')
        else
            --afb tpl = sub(tpl, '=== DEFS ===', str)
        end
    end
end

-- outputs compilation parameters
local t = {}
for k,v in pairs(ALL) do
    if v == true then
        t[#t+1] = k
    else
        t[#t+1] = k..'='..v
    end
end
table.sort(t)
--DBG('[ '..table.concat(t,' | ')..' ]')
--[[
]]

-- OUTPUT
local out
if _OPTS.output == '-' then
--    out = io.stdout
else
--    out = assert(io.open(_OPTS.output,'w'))
end
--out:write(tpl)

-- run code optimization routine
do
  if _OPTS.opt then
    
do
--[[
Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

varType = {}
varType[0]='ubyte'
varType[1]='ushort'
varType[2]='ulong'
varType[3]='float'
varType[4]='byte'
varType[5]='short'
varType[6]='long'
varType[7]='----'


--------------------------------------------------
-- Replace ('push_c addr' + 'deref') -> 'push_v addr'
--------------------------------------------------
_AST.root.opcode_aux={}
for x,op in pairs(_AST.root.opcode) do
  if (string.sub(op,1,1) ~= 'L') then
    if (string.sub(op,1,1) ~= '.') and (string.sub(op,1,1) ~= '_') then
--print("...",op,_AST.root.code2[x])
      local op_num = tonumber('0x'..op)
      local op_code = math.floor(op_num/4)*4 -- push_c + 2bit flag
      local op_mod = op_num % 4
      if op_code == opcode.op_push_c  and string.sub((_AST.root.code2[x] or ''),1,6)=='push_c' then
        local next_op_num = tonumber('0x'.._AST.root.opcode[x+2+op_mod])
        local next_op_code = math.floor(next_op_num/8)*8 -- deref + 3bit flag
        local next_op_mod = next_op_num % 8
--print("optm::deref:*",op,op_num,op_code,op_mod,string.sub((_AST.root.code2[x] or ''),1,6))
        if  next_op_code == opcode.op_deref then
--print("optm::deref: ",_AST.root.opcode[x+2+op_mod],next_op_num,next_op_code,next_op_mod,string.sub((_AST.root.code2[x+2+op_mod] or ''),1,6))
          _AST.root.code2[x] = string.gsub(_AST.root.code2[x],"push_c", "push_v "..varType[next_op_mod]).." [Optm:: push_c addr + deref]"
          _AST.root.opcode[x]=string.format("%02x",opcode.op_push_v+ (op_mod*8) + next_op_mod)
          _AST.root.opcode[x+2+op_mod]='_'
        end
      end      
    end
  end 
end

--------------------------------------------------
-- Remove extra 'execs'
--------------------------------------------------

-- build Label2label Table - Label -> Exec operation => LabelExecOper
_AST.root.label2label={}
local lblL,lblH;
local labelOper, labelExec;
for x,op in ipairs(_AST.root.opcode) do
  if (string.sub(op,1,1) == 'L') then 
    labelOper = tonumber('0x'..string.sub(op,2,5))
  else
    if labelOper then
      if not labelExec then
        local op_num = tonumber('0x'..op)
        if op_num == opcode.op_exec+1 then -- exec + 1 bit flag
          labelExec = true
        elseif op_num == opcode.op_end then
           _AST.root.label2label[labelOper]= 0;
          labelExec = nil
          labelOper = nil
        else
          labelExec = nil
          labelOper = nil
        end
      else  
        if (string.sub(op,1,1) == '.') then
          if (lblH==nil) then
            lblH = string.sub(op,2,3)
          else
            lblL = string.sub(op,2,3)
            local lbl = tonumber(('0x'..lblH))*256 + tonumber('0x'..lblL)
            _AST.root.label2label[labelOper]= lbl;
            lblH = nil
            labelExec = nil
            labelOper = nil          
          end
        end
      end
    end
  end 
end
-- Minimize exec -> exec
local changed = true
while changed do
--print("+")
  changed = false
  for lbl,toLbl in pairs(_AST.root.label2label) do
--print(lbl,toLbl)
    _AST.root.label2label[lbl] = _AST.root.label2label[toLbl]  or toLbl
    changed = (changed or not (_AST.root.label2label[lbl] == toLbl))
  end
end
--print("-------")
for lbl,toLbl in pairs(_AST.root.label2label) do
  --print(lbl,toLbl)
end

-- Change label->exec1->exec2 to label->exec2
_AST.root.opcode_aux={}
local lblL,lblH;
for x,op in pairs(_AST.root.opcode) do
  if (string.sub(op,1,1) ~= 'L') then
    if (string.sub(op,1,1) == '.') then
      if (lblH==nil) then
        lblH = string.sub(op,2,3)
      else
        lblL = string.sub(op,2,3)
        local lbl = tonumber(('0x'..lblH))*256 + tonumber('0x'..lblL)
        local newLabel = (_AST.root.label2label[lbl]~=0 and _AST.root.label2label[lbl]) or lbl
        _AST.root.opcode[x-1]=string.format('.%02x',newLabel / 256)
        _AST.root.opcode[x]=string.format('.%02x',newLabel % 256)
        lblH = nil
      end
    end
  end 
end


-- Remove inactive 'execs' or change to 'end' opcode
--print("-------")
local action, labelOper, steps
steps=0
for x,op in pairs(_AST.root.opcode) do
  if (string.sub(op,1,1) == 'L') then
    labelOper = tonumber('0x'..string.sub(op,2,5))
    action = ((_AST.root.label2label[labelOper] and _AST.root.label2label[labelOper]>0) and 'rem') or nil
--print(x,op, action)
    --_AST.root.opcode[x]='_'
  else
--print(x,op, action)
    if action=='rem' then
      _AST.root.opcode[x]='_'
      steps = steps + 1
      if steps >=3 then action = nil; steps=0; end
    elseif action == 'end' then
      if steps == 0 then 
        _AST.root.opcode[x]=string.format("%02x",opcode.op_end)
      else
        _AST.root.opcode[x]='_'
      end 
      steps = steps + 1
      if steps >=3 then action = nil; steps=0; end
    end  
  end
end



--------------------------------------------------
-- Remove 'exec' near 'end'
--------------------------------------------------
local lblL,lblH;
local lastOp,execOp,lastLabel, execLabel, prevLabel
for x,op in pairs(_AST.root.opcode) do
--print(x,op)
  if (string.sub(op,1,1) ~= 'L') then
    if (string.sub(op,1,1) == '.') then
      if (lblH==nil) then
        lblH = string.sub(op,2,3)
        local op_num = tonumber('0x'..lastOp)
        if op_num == opcode.op_exec+1 then
          execOp = true
          prevLabel = lastLabel 
        end
      else
        lblL = string.sub(op,2,3)
        execLabel = tonumber(('0x'..lblH))*256 + tonumber('0x'..lblL)
        lblH = nil
      end
    else
      local op_num = tonumber('0x'..op)
      if execOp and op_num==opcode.op_end then -- next opcode is an 'end'
--print('*********************:', prevLabel,execLabel,lastLabel) 
        if (prevLabel~=execLabel and execLabel==lastLabel) then -- remove the 'exec' oper
          local count = 1
          local remove = true
          while remove do
            if (string.sub(_AST.root.opcode[x-count],1,1) == '.') then
--print('removing: ',x-count-2,_AST.root.opcode[x-count-2],_AST.root.opcode[x-count-1],_AST.root.opcode[x-count])
              _AST.root.opcode[x-count]   = '_'
              _AST.root.opcode[x-count-1] = '_'
              _AST.root.opcode[x-count-2] = '_'
              remove = false
              execOp = false
            else
              count = count + 1
            end
          end
        end      
      else
        execOp = false
      end 
    end
  else
    lastLabel = tonumber('0x'..string.sub(op,2,5))  
  end
  lastOp = op 
end



--------------------------------------------------
-- Convert to 'end' any 'exec' pointing to 'end'
--------------------------------------------------
local lblL,lblH;
local lastOp,execOp,execLabel
for x,op in pairs(_AST.root.opcode) do
--print(x,op)
  if (string.sub(op,1,1) ~= 'L') then
    if (string.sub(op,1,1) == '.') then
      if (lblH==nil) then
        lblH = string.sub(op,2,3)
        local op_num = tonumber('0x'..lastOp)
        if op_num == opcode.op_exec+1 then
          execOp = true
        end
      else
        lblL = string.sub(op,2,3)
        execLabel = tonumber(('0x'..lblH))*256 + tonumber('0x'..lblL)
        lblH = nil
        if execOp and _AST.root.label2label[execLabel]==0 then -- point to an 'end' opcode
              _AST.root.opcode[x]   = '_'
              _AST.root.opcode[x-1] = '_'
              _AST.root.opcode[x-2] = string.format("%02x",opcode.op_end)
              _AST.root.code2[x-2] = 'end                           | end'
        end
        execOp = false
      end 
    end
  end
  lastOp = op 
end


--------------------------------------------------
-- Remove 'end' + 'end'
--------------------------------------------------
for x,op in pairs(_AST.root.opcode) do
--print(x,op)
  if (string.sub(op,1,1) ~= 'L') then
    local op_num = tonumber('0x'..op)
    if op_num == opcode.op_end  and string.sub((_AST.root.code2[x] or ''),1,3)=='end' then
      if _AST.root.opcode[x-1]==string.format("%02x",opcode.op_end) and string.sub((_AST.root.code2[x-1] or ''),1,3)=='end' then
        _AST.root.opcode[x-1]='_'
      end
    end
  end
end



end

  end
end
-- Count Opcode address
_AST.root.op_addr={}

codeAddr = ((ALL.n_tracks+1)*4) + ALL.n_mem
--print("terrac:: n_tracks=",ALL.n_tracks)

pos = codeAddr
nLbl=0
for x,op in ipairs(_AST.root.opcode) do
--print(x,op)
  _AST.root.op_addr[x]=pos
  if string.sub(op,1,1) ~= '_' then
    if string.sub(op,1,1) ~= 'L'  then 
      pos = pos + 1
    else
      nLbl=nLbl+1
    end 
  end
end
endCode = pos;



-- build Label x Addr Table
_AST.root.labeltable={}
for x,op in ipairs(_AST.root.opcode) do
	if (string.sub(op,1,1) == 'L') then 
--print("terrac::L",op, tonumber('0x'..string.sub(op,2,5)))
		_AST.root.labeltable[tonumber('0x'..string.sub(op,2,5))]={addr=_AST.root.op_addr[x]};
	end	
end


-- Rebuild 'op' with real addrs lbls in opcode_aux field
_AST.root.opcode_aux={}
local lblL,lblH;
for x,op in pairs(_AST.root.opcode) do
--print(x,op, lblH)
  if (string.sub(op,1,1) ~= 'L') then
    _AST.root.opcode_aux[x] = op
    if (string.sub(op,1,1) == '.') then
      if (lblH==nil) then
        lblH = string.sub(op,2,3)
      else
        lblL = string.sub(op,2,3)
        local lbl = tonumber(('0x'..lblH))*256 + tonumber('0x'..lblL)
--print("terrac::--",lbl,lblH,lblL,_AST.root.labeltable[lbl])
        local addr = ((_AST.root.labeltable[lbl] and _AST.root.labeltable[lbl] .addr) or 0)
--print(string.format('>>%04d',_AST.root.op_addr[x-1]),lbl,addr,_TP.getConstBytes(addr,2))
        _AST.root.opcode_aux[x-1]=string.format('%02x',addr / 256)
        _AST.root.opcode_aux[x]=string.format('%02x',addr % 256)
        _AST.root.code2[x-1] = 'addr:'..(addr or 0)
        lblH = nil
      end
    end
  end 
end


pos=endCode
idx=table.getn(_AST.root.opcode)+1

asmText=''
asmTextHeader=''
-- === Tracks ===
xAddr=0
for x=1,ALL.n_tracks+1,1 do
  asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. 0 ..' '..'track '.. x-1 ..'\n'; xAddr=xAddr+1;
  for y=1,(4-1),1 do
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. 0 ..'\n'; xAddr=xAddr+1;
  end
end
xMemAddr=(ALL.n_tracks+1)*4;
-- === WClocks ===
for x=1,_ENV.n_wclocks,1 do
  asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..' '..'wClock '.. x-1 ..'\n'; xAddr=xAddr+1;
  for y=1,_ENV.c.tceu_wclock.len-1,1 do
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  end
end
-- === Asyncs ===
for x=1,_ENV.n_asyncs,1 do
  asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..' '..'async_'.. x-1 ..'\n'; xAddr=xAddr+1;
  for y=1,_ENV.c.tceu_nlbl.len-1,1 do
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  end
end
-- === Emits ===
for x=1,_ENV.n_emits,1 do
  asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..' '..'emits '.. x-1 ..'\n'; xAddr=xAddr+1;
  for y=1,_ENV.c.tceu_nlbl.len-1,1 do
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
  end
end
-- === Gates ===
for _,ext in ipairs(_ENV.exts) do
  if (ext.pre == 'input') and (_ENV.awaits[ext] or 0) > 0 then  -- save code to write 0
--print("terrac:: gates",_ENV.awaits[ext],xAddr)
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '..string.format('%04d',xAddr-xMemAddr)..' inEvt '.. string.format('%03d',ext.idx) ..' : '.. ext.id  ..'\n'; xAddr=xAddr+1;
    asmText = asmText ..'00 | '..string.format('%05d',xAddr)..' '..string.format('%04d',xAddr-xMemAddr)..'           : '.. string.format('%02d',(_ENV.awaits[ext] or 0)) ..' gates\n'; xAddr=xAddr+1;
    for x= 0, (_ENV.awaits[ext] or 0)-1,1 do 
--print("terrac:: gate",x,xAddr)
	    asmText = asmText .. '00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
      asmText = asmText .. '00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
      if (ext.inArg) then  -- more one line for auxId in events with one arg
        asmText = asmText .. '00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr) ..'\n'; xAddr=xAddr+1;
      end
	  end
  end
end
-- === Vars ===
--print("terrac:: $ret offset",_AST.root[1][1].var[1].val+xMemAddr,xAddr)
for x=xAddr,codeAddr-1,1 do
	  asmText = asmText .. '00 | '..string.format('%05d',xAddr)..' '.. string.format('%04d',xAddr-xMemAddr)..' '..(_MEM.vars[xAddr-xMemAddr] or '')..'\n'; xAddr=xAddr+1;
end
-- === Opcodes ===
nlines=0;
lastBytes=0
_AST.root.x_stack = 0;
_AST.root.max_stack = 0;
for x,op in pairs(_AST.root.opcode) do
  if x > endCode then break end
	if (string.sub(op,1,1) ~= 'L' and string.sub(op,1,1) ~= '_') then 
--print("--",_AST.root.x_stack,(_AST.root.n_stack[x] or 0),_AST.root.max_stack); 
		_AST.root.x_stack = _AST.root.x_stack + (_AST.root.n_stack[x] or 0);
		_AST.root.max_stack = math.max(_AST.root.max_stack,_AST.root.x_stack);
--print("  ",_AST.root.x_stack,(_AST.root.n_stack[x] or 0),_AST.root.max_stack); 
    asmText = asmText .. (_AST.root.opcode_aux[x] or '--') ..' | '..string.format('%05d',_AST.root.op_addr[x])..' '..op..' '..(_AST.root.code2[x] or '')..'\n'
		nlines=nlines+1;
		lastBytes=_AST.root.op_addr[x];
	else
		--_AST.root.x_stack = 0;
	end	
end

local BlockSize = 22
local CodeSize = endCode-codeAddr
local Stack    = _AST.root.max_stack*4 + 6
local Tracks = (ALL.n_tracks+1)*4
local CtlVars  = codeAddr - Tracks
--local LblTab   = LblTableEnd_addr-endCode
local TotalMem = Tracks + CtlVars + CodeSize + Stack
local RadioMsgs = ((codeAddr%BlockSize) == 0 and math.ceil((CodeSize)/BlockSize)) or 1+math.ceil((CodeSize-(BlockSize-codeAddr%BlockSize))/BlockSize)
local lowMaxMem=999999

-- ====  Environment parameters  ====
-- codeAddr,LblTable11_addr,LblTable12_addr,LblTable21_addr,LblTable22_addr,LblTableEnd_addr,n_tracks,n_wavlocks,wclock0,gate0
asmTextHeader = codeAddr..' '..endCode --LblTable11_addr..' '..LblTable12_addr..' '..LblTable21_addr..' '..LblTable22_addr..' '..LblTableEnd_addr
asmTextHeader = asmTextHeader ..' '..ALL.n_tracks..' '.._ENV.n_wclocks..' '.. _ENV.n_asyncs ..' '.._MEM.gtes.wclock0
asmTextHeader = asmTextHeader ..' '.._ENV.gate0..' '.._ENV.n_ins_active..' '.._MEM.gtes.async0
asmTextHeader = asmTextHeader ..' '.. TotalMem ..'\n'

asmText = asmTextHeader .. asmText


--print((codeAddr%BlockSize) == 0 , ((LblTableEnd_addr-codeAddr)/BlockSize) , 1,LblTableEnd_addr-codeAddr,(BlockSize-codeAddr%BlockSize))
print('---------------------------------------------------------------------')
print('-- Terra Compiler: '..string.format('%-20s',_ENV.vm_name)..'     VM Code: '.. string.format('%12s',_ENV.vm_version) .. '  --')
print('---------------------------------------------------------------------')
print('--   Memory allocation in bytes:  '.. ((_OPTS.opt and '(code optimized)    ') or '(code not optimized)') ..'             --')
print('--   Total =  Tracks + Code + Ctl/Vars + Stack   |   Radio Msgs    --')
print(string.format('--    %4d    %3d    %4d     %4d     %4d      |      %3d        --',
                    TotalMem,Tracks,CodeSize,CtlVars,Stack,RadioMsgs))
print('---------------------------------------------------------------------')
print('--   Target platforms x Max program size                           --')
for k,v in pairs(_ENV.motes_max_size) do
  print(string.format('--   %16s = %4s bytes %1s                               --',k,v,(TotalMem>v and '?')or ' '))
  lowMaxMem = ( v < lowMaxMem  and v) or lowMaxMem 
end
print('---------------------------------------------------------------------')

if (TotalMem > lowMaxMem) then
  WRN(false,_AST.root,'Please check the maximum program size for each mote type!')
end

if _WRN.n_wrns > 0 then
  if _WRN.n_wrns > 1 then
    print('** Success with  '.. _WRN.n_wrns ..' warning messages **')
  else
    print('** Success with  '.. _WRN.n_wrns ..' warning message **')
  end
end

-- OUTPUT_ASM
local out2
if _OPTS.output2 == '-' then
    out2 = io.stdout
else
	out2_fname = string.match(_OPTS.input, "(.*)%.terra")..'.vmx'
    out2 = assert(io.open(out2_fname,'w'))
end
out2:write(asmText)

