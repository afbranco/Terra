---
---
{% include header.html %}

<style>
xb {font-weight:bold; color: blue;}
xr {font-weight:bold; color: red;}
xg {font-weight:bold; color: green;}
xz {font-weight:bold; color: gray;}

body {counter-reset: h3}
  h1 {counter-reset: h3}
  h2 {counter-reset: h3}
  h3 {counter-reset: h4}
  h4 {counter-reset: h5}
  h5 {counter-reset: h6}

  h3:before {counter-increment: h3; content: counter(h3) ". "}
  h4:before {counter-increment: h4; content: counter(h3) "." counter(h4) ". "}
  h5:before {counter-increment: h5; content: counter(h3) "." counter(h4) "." counter(h5) ". "}
  h6:before {counter-increment: h6; content: counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". "}

  h2.nocount:before, h3.nocount:before, h4.nocount:before, h5.nocount:before, h6.nocount:before { content: ""; counter-increment: none } 

    
</style>

<h2>Tutorial for new customizations</h2>
<p>
Basic concepts

User script - Semantic and syntax for events and functions
ubyte stat = emit EVENT(arg);
ubyte ret = await EVENT(ubyte);
type ret = FUNCTION(arg1,..., argn);

".defs" file
	Constant definitions
	Custom data structures
	output event ID, arg1, return1
	input event ID, arg1, return1
	functions ID, args, return1

"TerraCustom.h"
	Constant definitions
	Custom data structures
	output event ID
	input event ID
	functions ID

"TerraCustomP.nc"
	switch/case - output events
	switch/case - functions
	
	Custom events/functions implementation
		Resources - push and pop the stack - number of arguments must comply with .defs file.
		Insert a input event - Data structure pointer or basic type value must comply with .defs file.


IDs ..



</p>


<h3>Customization Process</h3>

<p> The next figure presents the customization and usage flows.
The developer activities related to customization are indicated in <xb>blue</xb> and 
the user activities related to application script are indicated in <xr>red</xr>.
The user activities are presented in more details in
the <a target="_blank" href="http://www.inf.puc-rio.br/~abranco/index.html#tab2-5">Terra tutorial page</a> 
and at the end of each Terra Platform page.
Next section presents the developer activities to customize a basic Terra implementation.
</p>
<p> The main developer activities are:
</p>
<ul>
<li><xb>(1)</xb> modifications in TerraVM source code. Optionally, the developer may create new components and/or libs.</li>
<li><xb>(2)</xb> creation of a new <code>.defs</code> file or modification on an existing one.</li>
<li><xb>(3)</xb> build and flash TerraVM.</li>
</ul>

<br>
<figure>
<figcaption >Figure: Customization flow (<xb>Dev</xb>) <i>vs</i> Usage flow (<xr>User</xr>)</figcaption>
<img class="img-responsive" style='clear:both;margin-right:10px; margin-top:10px; outline: 1px solid black;' 
	src="images/CustomizationDiagram.png" alt="Customization Process Diagram">
</figure>


<h3>The developer activities</h4>
<div class="alert alert-info">
  <strong>Note:</strong> This procedure assumes that you already have Terra  
ported to the desired platform with a very basic customization.
In general this very basic customization is based on TerraNet customization.
</div>

<p>At least three files must be edited to add new functionalities to a specific customization.</p>
<ul>
<li>The Terra<i>XXX</i>.defs file located in <code>~/Terra/TerraVM/src/TerraDefs</code> directory, where <i>XXX</i> is the base customization for target platform.</li>
<li>The VMCustom.h file located in <code>~/Terra/TerraVM/src/platform/<i>XXX</i></code> directory.</li>
<li>The VMCustomP.nc file also located in <code>~/Terra/TerraVM/src/platform/<i>XXX</i></code> directory.</li>
</ul>

<p>The definitions between these three files must be compatibles.
In the case of events, the numeric IDs must be equal to equivalent operations.
In the case of data structures, the type and position of the each fields must be equivalent. 
Same events and functions may have different names between the files, 
considering that the numeric IDs are the same.
</p>
<p>The syntax of each type of operations are described in the sequence.
The last section presents some real code examples.
</p> 

<p>In general, small functionalities are written inside <i>VMCustomP.nc</i> file.
If a new functionality requires additional files, a nesC component and/or a library of external functions may be created.
In this case the developer may need to modify the <i>VMCustom<b>C</b>.nc</i> file and 
must modify the Make system to be able to compile the new functionalities.
These modifications are out of scope of this tutorial.
</p>

<h4>Terra<i>XXX</i>.defs file</h4>
<p>
This file is used during <i>terrac</i> compilation to validate the event and function names. 
Any customized data structure used by events or functions are also defined in this file.
Additionally, the developer may define constant values to be used in the new functionalities. 
</p>
<h5>Constant definition</h5>
<p>A constant definition use the <code>#define</code> command as used in the C language.
Some examples are:</p>
<pre><code>#define HIGH 1
#define LOW 0
#define ON 1
#define OFF 0
</code></pre>

<h5>Data structures definitions</h5>

<div class="alert alert-info">
  <strong>Note:</strong> you need to be familiar with Terra data structures.
The page <a target="_blank" href="http://www.inf.puc-rio.br/~abranco/#tab2-2">Céu-T Language</a>
presents details about the <em>Types and data structures</em> of Terra scripting language.
</div>

<p><b>Registers</b> - Some new functionalities may need exchange values that a single basic type 
cannot support.
In these cases we need to create a specific data structure that includes all needed values.
In Céu-T language, a <code>regtype</code> declaration creates a new register type. 
A register can only have fields that are values of basic Terra types or arrays of basic types.
</p>
<pre><code><xz>// regtype example</xz>
regtype dhtData_t with
	var ubyte stat;
	var ubyte hum;
	var ubyte temp;
end
</code></pre>

<p><b>Packets</b> - In special cases the new functionality may leave some fields to be defined by the user.
This is the case of Radio messages where one part of the message (header) is predefined by the Terra message protocol
 and second part (payload) is application dependent.
 The <code>pktype</code> declaration creates a new abstract type with predefined fields and a payload section.
 The predefined fields depend on the new functionality needs and the payload section is left to the user application needs.
</p>
<pre><code><xz>// pktype example</xz>
packet radioMsg with
	var ubyte type;
	var ushort source;
	var ushort target;
	var payload[20] data;
end
</code></pre>

<p>When using register in events or functions, Terra system always pass the data address instead of data values.
Then, you must use the TerraVM internal support to copy memory data when building your customized function.
See below the "VMCustomP.nc file" section to find some examples.
</p>

<h5>Output event  definition</h5>
<p>Output events are defined by:</p>
<pre><code><b>output void</b> <i>EventName</i> <i>ArgumentType</i> <i>NumericID</i>;</code></pre>
<p>Where:</p>
<ul>
  <li> <i>EventName</i> is the event name used in the Terra Script.</li>
  <li> <i>ArgumentType</i> is the type of the argument. Must be any basic Terra type, void or any custom data structure. </li>
  <li> <i>NumericID</i> is an integer number that identifies internally the event. This number must be unique in all output events.</li>
</ul>
<p>A an example of output event definition is:</p>
<pre><code>output void REQ_DHT ubyte 10;</code></pre>
<div class="alert alert-info">
  <strong>Note:</strong> all output events must return void.
</div>

<h5>Input event  definition</h5>
<p>Input events are defined by:</p>
<pre><code><b>input</b> <i>ReturnType</i> <i>EventName</i> <i>ArgumentType</i> <i>NumericID</i>;</code></pre>
<p>Where:</p>
<ul>
  <li> <i>ReturnType</i> is the type of the <i>await</i> value. Must be any basic Terra type, void or any custom data structure. </li>
  <li> <i>EventName</i> is the event name used in the Terra Script.</li>
  <li> <i>ArgumentType</i> is the type of the argument. Must be an ubyte type or void. This argument, in general, identifies a <i>sub-event</i> type.</li>
  <li> <i>NumericID</i> is an integer number that identifies internally the event. This number must be unique in all input events.</li>
</ul>
<p>A an example of input event definition is:</p>
<pre><code>input ubyte SEND_DONE void 41;</code></pre>

<h5>Function  definition</h5>
<p>Functions events are defined by:</p>
<pre><code><b>function</b> <i>ReturnType</i> <i>FunctionName</i>(<i>ListOfArgumentsType</i>) <i>NumericID</i>;</code></pre>
<p>Where:</p>
<ul>
  <li> <i>ReturnType</i> is the type of the function return value. Accept only basic Terra types. Leave it empty in the case of void. </li>
  <li> <i>FunctionName</i> is the function name used in the Terra Script.</li>
  <li> <i>ListOfArgumentsType</i> May be empty or a list of types. The types must be any basic Terra type or any custom data structure. Cannot be void. </li>
  <li> <i>NumericID</i> is an integer number that identifies internally the function. This number must be unique in all functions.</li>
</ul>
<p>Examples of function definition are:</p>
<pre><code>function ushort getNodeId() 0;
function ubyte  pinWrite(ubyte,ubyte,ubyte) 21;</code></pre>


<h4>VMCustom.h file</h4>
<p>
This file defines the events and function numeric identifiers to be used during the building of TerraVM firmware.
Each numeric ID must be equal to the equivalent one in the <code>.defs</code> file.
These IDs are defined as a list of enumeration values as:
</p>
<pre><code>enum{
  <i>OutEvent1</i> =<i>NumericId1</i>,
  <i>OutEvent2</i> =<i>NumericId2</i>,
  <i>InEvent1</i>  =<i>NumericId1</i>,
  <i>InEvent2</i>  =<i>NumericId2</i>,
  <i>Function1</i> =<i>NumericId1</i>,
  <i>Function2</i> =<i>NumericId2</i>,
}
</code></pre>
<div class="alert alert-info">
  <strong>Note:</strong> the Numeric ID must be different only for each group of OutEvent, InEvent, and Function.
</div>

<h4>TVMCustomP.nc file</h4>
<p>TBD</p>

<h3>Simple Example</h3>

<h4>Example file for <code>TerraXXX.defs</code></h4>
<pre><code>// Interruption used for DHT sensor
#define INT0 0  // PD0
#define INT1 1  // PD1 
#define INT2 2  // PD2 
#define INT3 3  // PD3 

// DHT11 data structure
regtype <i>dhtData_t</i> with
	var ubyte stat;
	var ubyte hum;
	var ubyte temp;
end

// radioMsg - Radio/Queue Data Message Register
packet <i>radioMsg</i> with
	var ubyte type;
	var ushort source;
	var ushort target;
	var payload[20] data;
end

output void   REQ_DHT   ubyte    <xb>10</xb>;
output void   SEND      <i>radioMsg</i> <xb>40</xb>;

input  <i>dhtData_t</i> DHT    void      <xr>6</xr>;
input  ubyte     SEND_DONE ubyte <xr>40</xr>;
input  ubyte     SEND_DONE void  <xr>41</xr>;

function ushort getNodeId()                      <xg>0</xg>;
function ubyte  pinWrite(ubyte,ubyte,ubyte) 	<xg>21</xg>;
</code></pre>

<h4>Example file for <code>VMCustom.h</code></h4>
<pre><code>enum{
  O_DHT           =<xb>10</xb>,
  O_SEND          =<xb>40</xb>,

  I_DHT           = <xr>6</xr>,
  I_SEND_DONE_ID  =<xr>40</xr>,
  I_SEND_DONE     =<xr>41</xr>,
  
  F_GETNODEID     =  <xg>0</xg>,
  F_PIN_WRITE     = <xg>21</xg>,
}
</code></pre>

<h4>Example file for <code>VMCustomP.nc</code></h4>
<pre><code>void <b>proc_req_dht_read(uint16_t id, uint32_t value)</b>{
	call dht.read((uint8_t)value);
}

void  <b>proc_send(uint16_t id, uint32_t addr)</b>{
  usrMsg_t* usrMsg;
  usrMsg = (usrMsg_t*)signal VM.getRealAddr(addr);
  // .....
}

void  <b>func_getNodeId(uint16_t id)</b>{
  uint16_t stat;
  stat = TOS_NODE_ID;
  signal VM.push(stat);<xz>// Returns a value</xz>
}	

void <b>func_pinWrite(uint16_t id)</b>{
  uint8_t stat=0;
  uint8_t port, pin, val;
  val  = (uint8_t)signal VM.pop(); <xz>// pop 3⁰ arg from stack</xz>
  pin  = (uint8_t)signal VM.pop(); <xz>// pop 2⁰ arg from stack</xz>
  port = (uint8_t)signal VM.pop(); <xz>// pop 1⁰ arg from stack</xz>
  stat = pinWrite(port,pin,val);   <xz>// execute local function</xz>
  signal VM.push(stat);            <xz>// Returns a value</xz>
}

dhtData_t ExtDHTData;
event void dht.readDone(dhtData_t* data){
  memcpy(&ExtDHTData,data,sizeof(dhtData_t));  <xz>// copy data to event buffer</xz>
  signal VM.queueEvt(<xr>I_DHT</xr>, 0, &ExtDHTData); <xz>// Generates a Terra event</xz>
}

nx_uint8_t ExtDataSendDoneError;
event void BSRadio.sendDone(uint8_t am_id,message_t* msg,void* dataMsg, error_t error){
  if (am_id == AM_USRMSG){
    ExtDataSendDoneError = (uint8_t)error;
    signal VM.queueEvt(<xr>I_SEND_DONE_ID</xr>, ((usrMsg_t*)dataMsg)->type, &ExtDataSendDoneError);
    signal VM.queueEvt(<xr>I_SEND_DONE</xr>   ,                          0, &ExtDataSendDoneError);
  }
}

command void VM.procOutEvt(uint8_t id,uint32_t value){
  switch (id){
    case <xb>O_DHT</xb>  : <b>proc_req_dht_read(id,value)</b>; break;
    case <xb>O_SEND</xb> : <b>proc_send(id,value)</b>; break;
  }
}

command void VM.callFunction(uint8_t id){
  switch (id){
    case <xg>F_GETNODEID</xg> : <b>func_getNodeId(id)</b>; break;
    case <xg>F_PIN_WRITE</xg> : <b>func_pinWrite(id)</b>; break;
  }
}
</code></pre>


<p>

{% include footer.html %}
